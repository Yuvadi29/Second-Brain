module.exports = [
"[project]/node_modules/chromadb/dist/cjs/chromadb.cjs [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    Abs: ()=>Abs,
    AdminClient: ()=>AdminClient,
    AdminCloudClient: ()=>AdminCloudClient,
    BoolInvertedIndexConfig: ()=>BoolInvertedIndexConfig,
    BoolInvertedIndexType: ()=>BoolInvertedIndexType,
    BoolValueType: ()=>BoolValueType,
    ChromaClient: ()=>ChromaClient,
    ChromaClientError: ()=>ChromaClientError,
    ChromaConnectionError: ()=>ChromaConnectionError,
    ChromaError: ()=>ChromaError,
    ChromaForbiddenError: ()=>ChromaForbiddenError,
    ChromaNotFoundError: ()=>ChromaNotFoundError,
    ChromaQuotaExceededError: ()=>ChromaQuotaExceededError,
    ChromaRateLimitError: ()=>ChromaRateLimitError,
    ChromaServerError: ()=>ChromaServerError,
    ChromaUnauthorizedError: ()=>ChromaUnauthorizedError,
    ChromaUniqueError: ()=>ChromaUniqueError,
    ChromaValueError: ()=>ChromaValueError,
    CloudClient: ()=>CloudClient,
    DOCUMENT_KEY: ()=>DOCUMENT_KEY,
    Div: ()=>Div,
    EMBEDDING_KEY: ()=>EMBEDDING_KEY,
    Exp: ()=>Exp,
    FloatInvertedIndexConfig: ()=>FloatInvertedIndexConfig,
    FloatInvertedIndexType: ()=>FloatInvertedIndexType,
    FloatListValueType: ()=>FloatListValueType,
    FloatValueType: ()=>FloatValueType,
    FtsIndexConfig: ()=>FtsIndexConfig,
    FtsIndexType: ()=>FtsIndexType,
    GetResult: ()=>GetResult,
    IncludeEnum: ()=>IncludeEnum,
    IntInvertedIndexConfig: ()=>IntInvertedIndexConfig,
    IntInvertedIndexType: ()=>IntInvertedIndexType,
    IntValueType: ()=>IntValueType,
    InvalidArgumentError: ()=>InvalidArgumentError,
    InvalidCollectionError: ()=>InvalidCollectionError,
    K: ()=>K,
    Key: ()=>Key,
    Knn: ()=>Knn,
    Limit: ()=>Limit,
    Log: ()=>Log,
    Max: ()=>Max,
    Min: ()=>Min,
    Mul: ()=>Mul,
    QueryResult: ()=>QueryResult,
    RankExpression: ()=>RankExpression,
    Rrf: ()=>Rrf,
    Schema: ()=>Schema,
    Search: ()=>Search,
    SearchResult: ()=>SearchResult,
    Select: ()=>Select,
    SparseVectorIndexConfig: ()=>SparseVectorIndexConfig,
    SparseVectorIndexType: ()=>SparseVectorIndexType,
    SparseVectorValueType: ()=>SparseVectorValueType,
    StringInvertedIndexConfig: ()=>StringInvertedIndexConfig,
    StringInvertedIndexType: ()=>StringInvertedIndexType,
    StringValueType: ()=>StringValueType,
    Sub: ()=>Sub,
    Sum: ()=>Sum,
    Val: ()=>Val,
    ValueTypes: ()=>ValueTypes,
    VectorIndexConfig: ()=>VectorIndexConfig,
    VectorIndexType: ()=>VectorIndexType,
    WhereExpression: ()=>WhereExpression,
    baseRecordSetFields: ()=>baseRecordSetFields,
    createErrorByType: ()=>createErrorByType,
    getDefaultEFConfig: ()=>getDefaultEFConfig,
    getEmbeddingFunction: ()=>getEmbeddingFunction,
    getSparseEmbeddingFunction: ()=>getSparseEmbeddingFunction,
    knownEmbeddingFunctions: ()=>knownEmbeddingFunctions,
    knownSparseEmbeddingFunctions: ()=>knownSparseEmbeddingFunctions,
    processCreateCollectionConfig: ()=>processCreateCollectionConfig,
    processUpdateCollectionConfig: ()=>processUpdateCollectionConfig,
    recordSetFields: ()=>recordSetFields,
    registerEmbeddingFunction: ()=>registerEmbeddingFunction,
    registerSparseEmbeddingFunction: ()=>registerSparseEmbeddingFunction,
    serializeEmbeddingFunction: ()=>serializeEmbeddingFunction,
    toSearch: ()=>toSearch,
    withChroma: ()=>withChroma
});
module.exports = __toCommonJS(src_exports);
// src/deno.ts
if (typeof globalThis.Deno !== "undefined") {
    const OriginalRequest = globalThis.Request;
    const PatchedRequest = function(input, init) {
        if (init && typeof init === "object") {
            const cleanInit = {
                ...init
            };
            if ("client" in cleanInit) {
                delete cleanInit.client;
            }
            return new OriginalRequest(input, cleanInit);
        }
        return new OriginalRequest(input, init);
    };
    Object.setPrototypeOf(PatchedRequest, OriginalRequest);
    Object.defineProperty(PatchedRequest, "prototype", {
        value: OriginalRequest.prototype,
        writable: false
    });
    globalThis.Request = PatchedRequest;
}
// src/types.ts
var baseRecordSetFields = [
    "ids",
    "embeddings",
    "metadatas",
    "documents",
    "uris"
];
var recordSetFields = [
    ...baseRecordSetFields,
    "ids"
];
var IncludeEnum = /* @__PURE__ */ ((IncludeEnum2)=>{
    IncludeEnum2["distances"] = "distances";
    IncludeEnum2["documents"] = "documents";
    IncludeEnum2["embeddings"] = "embeddings";
    IncludeEnum2["metadatas"] = "metadatas";
    IncludeEnum2["uris"] = "uris";
    return IncludeEnum2;
})(IncludeEnum || {});
var GetResult = class {
    /**
   * Creates a new GetResult instance.
   * @param data - The result data containing all fields
   */ constructor({ documents, embeddings, ids, include, metadatas, uris }){
        this.documents = documents;
        this.embeddings = embeddings;
        this.ids = ids;
        this.include = include;
        this.metadatas = metadatas;
        this.uris = uris;
    }
    /**
   * Converts the result to a row-based format for easier iteration.
   * @returns Object containing include fields and array of record objects
   */ rows() {
        return this.ids.map((id, index)=>{
            return {
                id,
                document: this.include.includes("documents") ? this.documents[index] : void 0,
                embedding: this.include.includes("embeddings") ? this.embeddings[index] : void 0,
                metadata: this.include.includes("metadatas") ? this.metadatas[index] : void 0,
                uri: this.include.includes("uris") ? this.uris[index] : void 0
            };
        });
    }
};
var QueryResult = class {
    /**
   * Creates a new QueryResult instance.
   * @param data - The query result data containing all fields
   */ constructor({ distances, documents, embeddings, ids, include, metadatas, uris }){
        this.distances = distances;
        this.documents = documents;
        this.embeddings = embeddings;
        this.ids = ids;
        this.include = include;
        this.metadatas = metadatas;
        this.uris = uris;
    }
    /**
   * Converts the query result to a row-based format for easier iteration.
   * @returns Object containing include fields and structured query results
   */ rows() {
        const queries = [];
        for(let q2 = 0; q2 < this.ids.length; q2++){
            const records = this.ids[q2].map((id, index)=>{
                return {
                    id,
                    document: this.include.includes("documents") ? this.documents[q2][index] : void 0,
                    embedding: this.include.includes("embeddings") ? this.embeddings[q2][index] : void 0,
                    metadata: this.include.includes("metadatas") ? this.metadatas[q2][index] : void 0,
                    uri: this.include.includes("uris") ? this.uris[q2][index] : void 0,
                    distance: this.include.includes("distances") ? this.distances[q2][index] : void 0
                };
            });
            queries.push(records);
        }
        return queries;
    }
};
// ../../node_modules/.pnpm/@hey-api+client-fetch@0.10.0_@hey-api+openapi-ts@0.67.3_typescript@5.8.3_/node_modules/@hey-api/client-fetch/dist/index.js
var A = async (t, r)=>{
    let e = typeof r == "function" ? await r(t) : r;
    if (e) return t.scheme === "bearer" ? `Bearer ${e}` : t.scheme === "basic" ? `Basic ${btoa(e)}` : e;
};
var R = {
    bodySerializer: (t)=>JSON.stringify(t, (r, e)=>typeof e == "bigint" ? e.toString() : e)
};
var U = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
};
var _ = (t)=>{
    switch(t){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
};
var D = (t)=>{
    switch(t){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
};
var O = ({ allowReserved: t, explode: r, name: e, style: a, value: i })=>{
    if (!r) {
        let s = (t ? i : i.map((l)=>encodeURIComponent(l))).join(_(a));
        switch(a){
            case "label":
                return `.${s}`;
            case "matrix":
                return `;${e}=${s}`;
            case "simple":
                return s;
            default:
                return `${e}=${s}`;
        }
    }
    let o = U(a), n = i.map((s)=>a === "label" || a === "simple" ? t ? s : encodeURIComponent(s) : y({
            allowReserved: t,
            name: e,
            value: s
        })).join(o);
    return a === "label" || a === "matrix" ? o + n : n;
};
var y = ({ allowReserved: t, name: r, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${r}=${t ? e : encodeURIComponent(e)}`;
};
var q = ({ allowReserved: t, explode: r, name: e, style: a, value: i })=>{
    if (i instanceof Date) return `${e}=${i.toISOString()}`;
    if (a !== "deepObject" && !r) {
        let s = [];
        Object.entries(i).forEach(([f, u])=>{
            s = [
                ...s,
                f,
                t ? u : encodeURIComponent(u)
            ];
        });
        let l = s.join(",");
        switch(a){
            case "form":
                return `${e}=${l}`;
            case "label":
                return `.${l}`;
            case "matrix":
                return `;${e}=${l}`;
            default:
                return l;
        }
    }
    let o = D(a), n = Object.entries(i).map(([s, l])=>y({
            allowReserved: t,
            name: a === "deepObject" ? `${e}[${s}]` : s,
            value: l
        })).join(o);
    return a === "label" || a === "matrix" ? o + n : n;
};
var H = /\{[^{}]+\}/g;
var B = ({ path: t, url: r })=>{
    let e = r, a = r.match(H);
    if (a) for (let i of a){
        let o = false, n = i.substring(1, i.length - 1), s = "simple";
        n.endsWith("*") && (o = true, n = n.substring(0, n.length - 1)), n.startsWith(".") ? (n = n.substring(1), s = "label") : n.startsWith(";") && (n = n.substring(1), s = "matrix");
        let l = t[n];
        if (l == null) continue;
        if (Array.isArray(l)) {
            e = e.replace(i, O({
                explode: o,
                name: n,
                style: s,
                value: l
            }));
            continue;
        }
        if (typeof l == "object") {
            e = e.replace(i, q({
                explode: o,
                name: n,
                style: s,
                value: l
            }));
            continue;
        }
        if (s === "matrix") {
            e = e.replace(i, `;${y({
                name: n,
                value: l
            })}`);
            continue;
        }
        let f = encodeURIComponent(s === "label" ? `.${l}` : l);
        e = e.replace(i, f);
    }
    return e;
};
var E = ({ allowReserved: t, array: r, object: e } = {})=>(i)=>{
        let o = [];
        if (i && typeof i == "object") for(let n in i){
            let s = i[n];
            if (s != null) {
                if (Array.isArray(s)) {
                    o = [
                        ...o,
                        O({
                            allowReserved: t,
                            explode: true,
                            name: n,
                            style: "form",
                            value: s,
                            ...r
                        })
                    ];
                    continue;
                }
                if (typeof s == "object") {
                    o = [
                        ...o,
                        q({
                            allowReserved: t,
                            explode: true,
                            name: n,
                            style: "deepObject",
                            value: s,
                            ...e
                        })
                    ];
                    continue;
                }
                o = [
                    ...o,
                    y({
                        allowReserved: t,
                        name: n,
                        value: s
                    })
                ];
            }
        }
        return o.join("&");
    };
var P = (t)=>{
    if (!t) return "stream";
    let r = t.split(";")[0]?.trim();
    if (r) {
        if (r.startsWith("application/json") || r.endsWith("+json")) return "json";
        if (r === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((e)=>r.startsWith(e))) return "blob";
        if (r.startsWith("text/")) return "text";
    }
};
var I = async ({ security: t, ...r })=>{
    for (let e of t){
        let a = await A(e, r.auth);
        if (!a) continue;
        let i = e.name ?? "Authorization";
        switch(e.in){
            case "query":
                r.query || (r.query = {}), r.query[i] = a;
                break;
            case "cookie":
                r.headers.append("Cookie", `${i}=${a}`);
                break;
            case "header":
            default:
                r.headers.set(i, a);
                break;
        }
        return;
    }
};
var S = (t)=>W({
        baseUrl: t.baseUrl,
        path: t.path,
        query: t.query,
        querySerializer: typeof t.querySerializer == "function" ? t.querySerializer : E(t.querySerializer),
        url: t.url
    });
var W = ({ baseUrl: t, path: r, query: e, querySerializer: a, url: i })=>{
    let o = i.startsWith("/") ? i : `/${i}`, n = (t ?? "") + o;
    r && (n = B({
        path: r,
        url: n
    }));
    let s = e ? a(e) : "";
    return s.startsWith("?") && (s = s.substring(1)), s && (n += `?${s}`), n;
};
var C = (t, r)=>{
    let e = {
        ...t,
        ...r
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = x(t.headers, r.headers), e;
};
var x = (...t)=>{
    let r = new Headers();
    for (let e of t){
        if (!e || typeof e != "object") continue;
        let a = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [i, o] of a)if (o === null) r.delete(i);
        else if (Array.isArray(o)) for (let n of o)r.append(i, n);
        else o !== void 0 && r.set(i, typeof o == "object" ? JSON.stringify(o) : o);
    }
    return r;
};
var h = class {
    constructor(){
        __publicField(this, "_fns");
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    exists(r) {
        return this._fns.indexOf(r) !== -1;
    }
    eject(r) {
        let e = this._fns.indexOf(r);
        e !== -1 && (this._fns = [
            ...this._fns.slice(0, e),
            ...this._fns.slice(e + 1)
        ]);
    }
    use(r) {
        this._fns = [
            ...this._fns,
            r
        ];
    }
};
var T = ()=>({
        error: new h(),
        request: new h(),
        response: new h()
    });
var N = E({
    allowReserved: false,
    array: {
        explode: true,
        style: "form"
    },
    object: {
        explode: true,
        style: "deepObject"
    }
});
var Q = {
    "Content-Type": "application/json"
};
var w = (t = {})=>({
        ...R,
        headers: Q,
        parseAs: "auto",
        querySerializer: N,
        ...t
    });
var J = (t = {})=>{
    let r = C(w(), t), e = ()=>({
            ...r
        }), a = (n)=>(r = C(r, n), e()), i = T(), o = async (n)=>{
        let s = {
            ...r,
            ...n,
            fetch: n.fetch ?? r.fetch ?? globalThis.fetch,
            headers: x(r.headers, n.headers)
        };
        s.security && await I({
            ...s,
            security: s.security
        }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
        let l = S(s), f = {
            redirect: "follow",
            ...s
        }, u = new Request(l, f);
        for (let p of i.request._fns)u = await p(u, s);
        let k = s.fetch, c = await k(u);
        for (let p of i.response._fns)c = await p(c, u, s);
        let m = {
            request: u,
            response: c
        };
        if (c.ok) {
            if (c.status === 204 || c.headers.get("Content-Length") === "0") return {
                data: {},
                ...m
            };
            let p = (s.parseAs === "auto" ? P(c.headers.get("Content-Type")) : s.parseAs) ?? "json";
            if (p === "stream") return {
                data: c.body,
                ...m
            };
            let b = await c[p]();
            return p === "json" && (s.responseValidator && await s.responseValidator(b), s.responseTransformer && (b = await s.responseTransformer(b))), {
                data: b,
                ...m
            };
        }
        let g = await c.text();
        try {
            g = JSON.parse(g);
        } catch  {}
        let d = g;
        for (let p of i.error._fns)d = await p(g, c, u, s);
        if (d = d || {}, s.throwOnError) throw d;
        return {
            error: d,
            ...m
        };
    };
    return {
        buildUrl: S,
        connect: (n)=>o({
                ...n,
                method: "CONNECT"
            }),
        delete: (n)=>o({
                ...n,
                method: "DELETE"
            }),
        get: (n)=>o({
                ...n,
                method: "GET"
            }),
        getConfig: e,
        head: (n)=>o({
                ...n,
                method: "HEAD"
            }),
        interceptors: i,
        options: (n)=>o({
                ...n,
                method: "OPTIONS"
            }),
        patch: (n)=>o({
                ...n,
                method: "PATCH"
            }),
        post: (n)=>o({
                ...n,
                method: "POST"
            }),
        put: (n)=>o({
                ...n,
                method: "PUT"
            }),
        request: o,
        setConfig: a,
        trace: (n)=>o({
                ...n,
                method: "TRACE"
            })
    };
};
// src/api/client.gen.ts
var client = J(w({
    baseUrl: "http://localhost:8000",
    throwOnError: true
}));
// src/api/sdk.gen.ts
var DefaultService = class {
    /**
   * Retrieves the current user's identity, tenant, and databases.
   */ static getUserIdentity(options) {
        return (options?.client ?? client).get({
            url: "/api/v2/auth/identity",
            ...options
        });
    }
    /**
   * Retrieves a collection by Chroma Resource Name.
   */ static getCollectionByCrn(options) {
        return (options.client ?? client).get({
            url: "/api/v2/collections/{crn}",
            ...options
        });
    }
    /**
   * Health check endpoint that returns 200 if the server and executor are ready
   */ static healthcheck(options) {
        return (options?.client ?? client).get({
            url: "/api/v2/healthcheck",
            ...options
        });
    }
    /**
   * Heartbeat endpoint that returns a nanosecond timestamp of the current time.
   */ static heartbeat(options) {
        return (options?.client ?? client).get({
            url: "/api/v2/heartbeat",
            ...options
        });
    }
    /**
   * Pre-flight checks endpoint reporting basic readiness info.
   */ static preFlightChecks(options) {
        return (options?.client ?? client).get({
            url: "/api/v2/pre-flight-checks",
            ...options
        });
    }
    /**
   * Reset endpoint allowing authorized users to reset the database.
   */ static reset(options) {
        return (options?.client ?? client).post({
            url: "/api/v2/reset",
            ...options
        });
    }
    /**
   * Creates a new tenant.
   */ static createTenant(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Returns an existing tenant by name.
   */ static getTenant(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant_name}",
            ...options
        });
    }
    /**
   * Updates an existing tenant by name.
   */ static updateTenant(options) {
        return (options.client ?? client).patch({
            url: "/api/v2/tenants/{tenant_name}",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Lists all databases for a given tenant.
   */ static listDatabases(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases",
            ...options
        });
    }
    /**
   * Creates a new database for a given tenant.
   */ static createDatabase(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Deletes a specific database.
   */ static deleteDatabase(options) {
        return (options.client ?? client).delete({
            url: "/api/v2/tenants/{tenant}/databases/{database}",
            ...options
        });
    }
    /**
   * Retrieves a specific database by name.
   */ static getDatabase(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases/{database}",
            ...options
        });
    }
    /**
   * Detach a function
   */ static detachFunction(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/attached_functions/{attached_function_id}/detach",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Lists all collections in the specified database.
   */ static listCollections(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections",
            ...options
        });
    }
    /**
   * Creates a new collection under the specified database.
   */ static createCollection(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Deletes a collection in a given database.
   */ static deleteCollection(options) {
        return (options.client ?? client).delete({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",
            ...options
        });
    }
    /**
   * Retrieves a collection by ID or name.
   */ static getCollection(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",
            ...options
        });
    }
    /**
   * Updates an existing collection's name or metadata.
   */ static updateCollection(options) {
        return (options.client ?? client).put({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Adds records to a collection.
   */ static collectionAdd(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Retrieves the number of records in a collection.
   */ static collectionCount(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count",
            ...options
        });
    }
    /**
   * Deletes records in a collection. Can filter by IDs or metadata.
   */ static collectionDelete(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Forks an existing collection.
   */ static forkCollection(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Attach a function to a collection
   */ static attachFunction(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/attach",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Retrieves records from a collection by ID or metadata filter.
   */ static collectionGet(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search
   */ static collectionQuery(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Search records from a collection with hybrid criterias.
   */ static collectionSearch(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Updates records in a collection by ID.
   */ static collectionUpdate(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Upserts records in a collection (create if not exists, otherwise update).
   */ static collectionUpsert(options) {
        return (options.client ?? client).post({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert",
            ...options,
            headers: {
                "Content-Type": "application/json",
                ...options?.headers
            }
        });
    }
    /**
   * Retrieves the total number of collections in a given database.
   */ static countCollections(options) {
        return (options.client ?? client).get({
            url: "/api/v2/tenants/{tenant}/databases/{database}/collections_count",
            ...options
        });
    }
    /**
   * Returns the version of the server.
   */ static version(options) {
        return (options?.client ?? client).get({
            url: "/api/v2/version",
            ...options
        });
    }
};
// src/errors.ts
var ChromaError = class extends Error {
    constructor(name, message, cause){
        super(message);
        this.cause = cause;
        this.name = name;
    }
};
var ChromaConnectionError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaConnectionError";
    }
};
var ChromaServerError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaServerError";
    }
};
var ChromaClientError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaClientError";
    }
};
var ChromaUnauthorizedError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaAuthError";
    }
};
var ChromaForbiddenError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaForbiddenError";
    }
};
var ChromaNotFoundError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaNotFoundError";
    }
};
var ChromaValueError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaValueError";
    }
};
var InvalidCollectionError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "InvalidCollectionError";
    }
};
var InvalidArgumentError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "InvalidArgumentError";
    }
};
var ChromaUniqueError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaUniqueError";
    }
};
var ChromaQuotaExceededError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaQuotaExceededError";
    }
};
var ChromaRateLimitError = class extends Error {
    constructor(message, cause){
        super(message);
        this.cause = cause;
        this.name = "ChromaRateLimitError";
    }
};
function createErrorByType(type, message) {
    switch(type){
        case "InvalidCollection":
            return new InvalidCollectionError(message);
        case "InvalidArgumentError":
            return new InvalidArgumentError(message);
        default:
            return void 0;
    }
}
// src/utils.ts
var DEFAULT_TENANT = "default_tenant";
var DEFAULT_DATABASE = "default_database";
var defaultAdminClientArgs = {
    host: "localhost",
    port: 8e3,
    ssl: false
};
var defaultChromaClientArgs = {
    ...defaultAdminClientArgs,
    tenant: DEFAULT_TENANT,
    database: DEFAULT_DATABASE
};
var normalizeMethod = (method)=>{
    if (method) {
        switch(method.toUpperCase()){
            case "GET":
                return "GET";
            case "POST":
                return "POST";
            case "PUT":
                return "PUT";
            case "DELETE":
                return "DELETE";
            case "HEAD":
                return "HEAD";
            case "CONNECT":
                return "CONNECT";
            case "OPTIONS":
                return "OPTIONS";
            case "PATCH":
                return "PATCH";
            case "TRACE":
                return "TRACE";
            default:
                return void 0;
        }
    }
    return void 0;
};
var validateRecordSetLengthConsistency = (recordSet)=>{
    const lengths = Object.entries(recordSet).filter(([field, value])=>recordSetFields.includes(field) && value !== void 0).map(([field, value])=>[
            field,
            value.length
        ]);
    if (lengths.length === 0) {
        throw new ChromaValueError(`At least one of ${recordSetFields.join(", ")} must be provided`);
    }
    const zeroLength = lengths.filter(([_2, length])=>length === 0).map(([field, _2])=>field);
    if (zeroLength.length > 0) {
        throw new ChromaValueError(`Non-empty lists are required for ${zeroLength.join(", ")}`);
    }
    if (new Set(lengths.map(([_2, length])=>length)).size > 1) {
        throw new ChromaValueError(`Unequal lengths for fields ${lengths.map(([field, _2])=>field).join(", ")}`);
    }
};
var validateEmbeddings = ({ embeddings, fieldName = "embeddings" })=>{
    if (!Array.isArray(embeddings)) {
        throw new ChromaValueError(`Expected '${fieldName}' to be an array, but got ${typeof embeddings}`);
    }
    if (embeddings.length === 0) {
        throw new ChromaValueError("Expected embeddings to be an array with at least one item");
    }
    if (!embeddings.filter((e)=>e.every((n)=>typeof n === "number"))) {
        throw new ChromaValueError("Expected each embedding to be an array of numbers");
    }
    embeddings.forEach((embedding, i)=>{
        if (embedding.length === 0) {
            throw new ChromaValueError(`Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`);
        }
    });
};
var validateDocuments = ({ documents, nullable = false, fieldName = "documents" })=>{
    if (!Array.isArray(documents)) {
        throw new ChromaValueError(`Expected '${fieldName}' to be an array, but got ${typeof documents}`);
    }
    if (documents.length === 0) {
        throw new ChromaValueError(`Expected '${fieldName}' to be a non-empty list`);
    }
    documents.forEach((document)=>{
        if (!nullable && typeof document !== "string" && !document) {
            throw new ChromaValueError(`Expected each document to be a string, but got ${typeof document}`);
        }
    });
};
var validateIDs = (ids)=>{
    if (!Array.isArray(ids)) {
        throw new ChromaValueError(`Expected 'ids' to be an array, but got ${typeof ids}`);
    }
    if (ids.length === 0) {
        throw new ChromaValueError("Expected 'ids' to be a non-empty list");
    }
    const nonStrings = ids.map((id, i)=>[
            id,
            i
        ]).filter(([id, _2])=>typeof id !== "string").map(([_2, i])=>i);
    if (nonStrings.length > 0) {
        throw new ChromaValueError(`Found non-string IDs at ${nonStrings.join(", ")}`);
    }
    const seen = /* @__PURE__ */ new Set();
    const duplicates = ids.filter((id)=>{
        if (seen.has(id)) {
            return id;
        }
        seen.add(id);
    });
    let message = "Expected IDs to be unique, but found duplicates of";
    if (duplicates.length > 0 && duplicates.length <= 5) {
        throw new ChromaValueError(`${message} ${duplicates.join(", ")}`);
    }
    if (duplicates.length > 0) {
        throw new ChromaValueError(`${message} ${duplicates.slice(0, 5).join(", ")}, ..., ${duplicates.slice(duplicates.length - 5).join(", ")}`);
    }
};
var validateSparseVector = (v)=>{
    if (typeof v !== "object" || v === null) {
        return false;
    }
    const candidate = v;
    const indices = candidate.indices;
    const values = candidate.values;
    if (!Array.isArray(indices) || !Array.isArray(values)) {
        return false;
    }
    return indices.every((e)=>typeof e === "number") && values.every((e)=>typeof e === "number");
};
var validateMetadata = (metadata)=>{
    if (!metadata) {
        return;
    }
    if (Object.keys(metadata).length === 0) {
        throw new ChromaValueError("Expected metadata to be non-empty");
    }
    if (!Object.values(metadata).every((v)=>v === null || v === void 0 || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || validateSparseVector(v))) {
        throw new ChromaValueError("Expected metadata to be a string, number, boolean, SparseVector, or nullable");
    }
};
var SPARSE_VECTOR_TYPE = "sparse_vector";
var toSerializedSparseVector = (vector)=>({
        "#type": SPARSE_VECTOR_TYPE,
        indices: vector.indices,
        values: vector.values
    });
var serializeMetadata = (metadata)=>{
    if (metadata === void 0) {
        return void 0;
    }
    if (metadata === null) {
        return null;
    }
    const result = {};
    Object.entries(metadata).forEach(([key, value])=>{
        if (validateSparseVector(value)) {
            result[key] = toSerializedSparseVector(value);
        } else {
            result[key] = value ?? null;
        }
    });
    return result;
};
var serializeMetadatas = (metadatas)=>{
    if (metadatas === void 0) {
        return void 0;
    }
    if (metadatas === null) {
        return null;
    }
    return metadatas.map((metadata)=>serializeMetadata(metadata) ?? null);
};
var isSerializedSparseVector = (value)=>{
    if (typeof value !== "object" || value === null) {
        return false;
    }
    const candidate = value;
    if (candidate["#type"] !== SPARSE_VECTOR_TYPE) {
        return false;
    }
    return validateSparseVector(candidate);
};
var deserializeMetadataValue = (value)=>{
    if (isSerializedSparseVector(value)) {
        return {
            indices: value.indices,
            values: value.values
        };
    }
    return value;
};
var deserializeMetadata = (metadata)=>{
    if (metadata === void 0) {
        return void 0;
    }
    if (metadata === null) {
        return null;
    }
    const result = {};
    Object.entries(metadata).forEach(([key, value])=>{
        result[key] = deserializeMetadataValue(value);
    });
    return result;
};
var deserializeMetadatas = (metadatas)=>{
    if (metadatas === void 0) {
        return void 0;
    }
    if (metadatas === null) {
        return null;
    }
    return metadatas.map((metadata)=>deserializeMetadata(metadata) ?? null);
};
var deserializeMetadataMatrix = (metadatas)=>{
    if (metadatas === void 0) {
        return void 0;
    }
    if (metadatas === null) {
        return null;
    }
    return metadatas.map((metadataArray)=>{
        if (metadataArray === null) {
            return null;
        }
        const deserialized = deserializeMetadatas(metadataArray);
        return deserialized ?? [];
    });
};
var validateMetadatas = (metadatas)=>{
    if (!Array.isArray(metadatas)) {
        throw new ChromaValueError(`Expected metadatas to be an array, but got ${typeof metadatas}`);
    }
    metadatas.forEach((metadata)=>validateMetadata(metadata));
};
var validateBaseRecordSet = ({ recordSet, update = false, embeddingsField = "embeddings", documentsField = "documents" })=>{
    if (!recordSet.embeddings && !recordSet.documents && !update) {
        throw new ChromaValueError(`At least one of '${embeddingsField}' and '${documentsField}' must be provided`);
    }
    if (recordSet.embeddings) {
        validateEmbeddings({
            embeddings: recordSet.embeddings,
            fieldName: embeddingsField
        });
    }
    if (recordSet.documents) {
        validateDocuments({
            documents: recordSet.documents,
            fieldName: documentsField
        });
    }
    if (recordSet.metadatas) {
        validateMetadatas(recordSet.metadatas);
    }
};
var validateMaxBatchSize = (recordSetLength, maxBatchSize)=>{
    if (recordSetLength > maxBatchSize) {
        throw new ChromaValueError(`Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`);
    }
};
var validateWhere = (where)=>{
    if (typeof where !== "object") {
        throw new ChromaValueError("Expected where to be a non-empty object");
    }
    if (Object.keys(where).length != 1) {
        throw new ChromaValueError(`Expected 'where' to have exactly one operator, but got ${Object.keys(where).length}`);
    }
    Object.entries(where).forEach(([key, value])=>{
        if (key !== "$and" && key !== "$or" && key !== "$in" && key !== "$nin" && ![
            "string",
            "number",
            "boolean",
            "object"
        ].includes(typeof value)) {
            throw new ChromaValueError(`Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`);
        }
        if (key === "$and" || key === "$or") {
            if (Object.keys(value).length <= 1) {
                throw new ChromaValueError(`Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`);
            }
            value.forEach((w2)=>validateWhere(w2));
            return;
        }
        if (typeof value === "object") {
            if (Object.keys(value).length != 1) {
                throw new ChromaValueError(`Expected operator expression to have one operator, but got ${value}`);
            }
            const [operator, operand] = Object.entries(value)[0];
            if ([
                "$gt",
                "$gte",
                "$lt",
                "$lte"
            ].includes(operator) && typeof operand !== "number") {
                throw new ChromaValueError(`Expected operand value to be a number for ${operator}, but got ${typeof operand}`);
            }
            if ([
                "$in",
                "$nin"
            ].includes(operator) && !Array.isArray(operand)) {
                throw new ChromaValueError(`Expected operand value to be an array for ${operator}, but got ${operand}`);
            }
            if (![
                "$gt",
                "$gte",
                "$lt",
                "$lte",
                "$ne",
                "$eq",
                "$in",
                "$nin"
            ].includes(operator)) {
                throw new ChromaValueError(`Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`);
            }
            if (![
                "string",
                "number",
                "boolean"
            ].includes(typeof operand) && !Array.isArray(operand)) {
                throw new ChromaValueError("Expected operand value to be a string, number, boolean, or a list of those types");
            }
            if (Array.isArray(operand) && (operand.length === 0 || !operand.every((item)=>typeof item === typeof operand[0]))) {
                throw new ChromaValueError("Expected 'where' operand value to be a non-empty list and all values to be of the same type");
            }
        }
    });
};
var validateWhereDocument = (whereDocument)=>{
    if (typeof whereDocument !== "object") {
        throw new ChromaValueError("Expected 'whereDocument' to be a non-empty object");
    }
    if (Object.keys(whereDocument).length != 1) {
        throw new ChromaValueError(`Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`);
    }
    const [operator, operand] = Object.entries(whereDocument)[0];
    if (![
        "$contains",
        "$not_contains",
        "$matches",
        "$not_matches",
        "$regex",
        "$not_regex",
        "$and",
        "$or"
    ].includes(operator)) {
        throw new ChromaValueError(`Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`);
    }
    if (operator === "$and" || operator === "$or") {
        if (!Array.isArray(operand)) {
            throw new ChromaValueError(`Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`);
        }
        if (operand.length <= 1) {
            throw new ChromaValueError(`Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`);
        }
        operand.forEach((item)=>validateWhereDocument(item));
    }
    if ((operand === "$contains" || operand === "$not_contains" || operand === "$regex" || operand === "$not_regex") && (typeof operator !== "string" || operator.length === 0)) {
        throw new ChromaValueError(`Expected operand for ${operator} to be a non empty string, but got ${operand}`);
    }
};
var validateInclude = ({ include, exclude })=>{
    if (!Array.isArray(include)) {
        throw new ChromaValueError("Expected 'include' to be a non-empty array");
    }
    const validValues = Object.keys(IncludeEnum);
    include.forEach((item)=>{
        if (typeof item !== "string") {
            throw new ChromaValueError("Expected 'include' items to be strings");
        }
        if (!validValues.includes(item)) {
            throw new ChromaValueError(`Expected 'include' items to be one of ${validValues.join(", ")}, but got ${item}`);
        }
        if (exclude?.includes(item)) {
            throw new ChromaValueError(`${item} is not allowed for this operation`);
        }
    });
};
var validateNResults = (nResults)=>{
    if (typeof nResults !== "number") {
        throw new ChromaValueError(`Expected 'nResults' to be a number, but got ${typeof nResults}`);
    }
    if (nResults <= 0) {
        throw new ChromaValueError("Number of requested results has to positive");
    }
};
var parseConnectionPath = (path)=>{
    try {
        const url = new URL(path);
        const ssl = url.protocol === "https:";
        const host = url.hostname;
        const port = url.port;
        return {
            ssl,
            host,
            port: Number(port)
        };
    } catch  {
        throw new ChromaValueError(`Invalid URL: ${path}`);
    }
};
var packEmbedding = (embedding)=>{
    const buffer = new ArrayBuffer(embedding.length * 4);
    const view = new Float32Array(buffer);
    for(let i = 0; i < embedding.length; i++){
        view[i] = embedding[i];
    }
    return buffer;
};
var embeddingsToBase64Bytes = (embeddings)=>{
    return embeddings.map((embedding)=>{
        const buffer = packEmbedding(embedding);
        const uint8Array = new Uint8Array(buffer);
        const binaryString = Array.from(uint8Array, (byte)=>String.fromCharCode(byte)).join("");
        return btoa(binaryString);
    });
};
// src/embedding-function.ts
var knownEmbeddingFunctions = /* @__PURE__ */ new Map();
var pythonEmbeddingFunctions = {
    onnx_mini_lm_l6_v2: "default-embed",
    default: "default-embed",
    together_ai: "together-ai",
    sentence_transformer: "sentence-transformer"
};
var unsupportedEmbeddingFunctions = /* @__PURE__ */ new Set([
    "amazon_bedrock",
    "baseten",
    "langchain",
    "google_palm",
    "huggingface",
    "instructor",
    "open_clip",
    "roboflow",
    "text2vec"
]);
var knownSparseEmbeddingFunctions = /* @__PURE__ */ new Map();
var pythonSparseEmbeddingFunctions = {
    chroma_bm25: "chroma-bm25"
};
var unsupportedSparseEmbeddingFunctions = /* @__PURE__ */ new Set([
    "bm25",
    "fastembed_sparse",
    "huggingface_sparse"
]);
var registerEmbeddingFunction = (name, fn)=>{
    if (knownEmbeddingFunctions.has(name)) {
        throw new ChromaValueError(`Embedding function with name ${name} is already registered.`);
    }
    knownEmbeddingFunctions.set(name, fn);
};
var registerSparseEmbeddingFunction = (name, fn)=>{
    if (knownSparseEmbeddingFunctions.has(name)) {
        throw new ChromaValueError(`Sparse embedding function with name ${name} is already registered.`);
    }
    knownSparseEmbeddingFunctions.set(name, fn);
};
var getEmbeddingFunction = async (args)=>{
    const { collectionName, client: client2, efConfig } = args;
    if (!efConfig) {
        console.warn(`No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`);
        return void 0;
    }
    if (efConfig.type === "legacy") {
        console.warn(`No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`);
        return void 0;
    }
    if (efConfig.type === "unknown") {
        console.warn(`Unknown embedding function configuration for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`);
        return void 0;
    }
    if (efConfig.type !== "known") {
        return void 0;
    }
    if (unsupportedEmbeddingFunctions.has(efConfig.name)) {
        console.warn(`Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.`);
        return void 0;
    }
    const packageName = pythonEmbeddingFunctions[efConfig.name] || efConfig.name;
    if (packageName === "default-embed") {
        await getDefaultEFConfig();
    }
    let embeddingFunction = knownEmbeddingFunctions.get(packageName);
    if (!embeddingFunction) {
        try {
            const fullPackageName = `@chroma-core/${packageName}`;
            await __turbopack_context__.f({
                "@chroma-core/default-embed": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common/dist/index.d.mts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common/dist/index": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/index.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/index.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)")
                },
                "@chroma-core/ai-embeddings-common/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/dist/cjs/default-embed.cjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/cjs/default-embed.cjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/cjs/default-embed.cjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/cjs/default-embed.d.cts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/dist/default-embed.legacy-esm": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/default-embed.legacy-esm.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/default-embed.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/src/index.test.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/src/index.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/dist/cjs/openai.cjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/cjs/openai.cjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/cjs/openai.cjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/cjs/openai.d.cts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/dist/openai.legacy-esm": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/openai.legacy-esm.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/openai.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/package.json (json, async loader)")
                },
                "@chroma-core/openai/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/package.json (json, async loader)")
                },
                "@chroma-core/openai/src/index.test.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/src/index.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                }
            }).import(fullPackageName);
            embeddingFunction = knownEmbeddingFunctions.get(packageName);
        } catch (error) {}
        if (!embeddingFunction) {
            console.warn(`Collection ${collectionName} was created with the ${packageName} embedding function. However, the @chroma-core/${packageName} package is not installed. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${packageName} package.`);
            return void 0;
        }
    }
    let constructorConfig = efConfig.type === "known" ? efConfig.config : {};
    try {
        if (embeddingFunction.buildFromConfig) {
            return embeddingFunction.buildFromConfig(constructorConfig, client2);
        }
        console.warn(`Embedding function ${packageName} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`);
        return void 0;
    } catch (e) {
        console.warn(`Embedding function ${packageName} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`);
        return void 0;
    }
};
var getSparseEmbeddingFunction = async (collectionName, client2, efConfig)=>{
    if (!efConfig) {
        return void 0;
    }
    if (efConfig.type === "legacy") {
        return void 0;
    }
    if (efConfig.type !== "known") {
        return void 0;
    }
    if (unsupportedSparseEmbeddingFunctions.has(efConfig.name)) {
        console.warn("Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.");
        return void 0;
    }
    const packageName = pythonSparseEmbeddingFunctions[efConfig.name] || efConfig.name;
    let sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);
    if (!sparseEmbeddingFunction) {
        try {
            const fullPackageName = `@chroma-core/${packageName}`;
            await __turbopack_context__.f({
                "@chroma-core/ai-embeddings-common/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common/dist/index.d.mts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common/dist/index": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/index.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/index.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)")
                },
                "@chroma-core/ai-embeddings-common/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/dist/cjs/default-embed.cjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/cjs/default-embed.cjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/cjs/default-embed.cjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/cjs/default-embed.d.cts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/dist/default-embed.legacy-esm": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/default-embed.legacy-esm.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/dist/default-embed.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/package.json (json, async loader)")
                },
                "@chroma-core/default-embed/src/index.test.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/default-embed/src/index.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/README.md": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/dist/cjs/openai.cjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/cjs/openai.cjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/cjs/openai.cjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/cjs/openai.d.cts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/dist/openai.legacy-esm": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/openai.legacy-esm.js": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/dist/openai.mjs": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/package": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/package.json (json, async loader)")
                },
                "@chroma-core/openai/package.json": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/package.json (json, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/package.json (json, async loader)")
                },
                "@chroma-core/openai/src/index.test.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/openai/src/index.ts": {
                    id: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })(),
                    module: ()=>(()=>{
                            const e = new Error("Cannot find module 'unknown module type'");
                            e.code = 'MODULE_NOT_FOUND';
                            throw e;
                        })()
                },
                "@chroma-core/ai-embeddings-common": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.mjs [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/ai-embeddings-common/dist/": {
                    id: ()=>"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/default-embed/": {
                    id: ()=>"[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                },
                "@chroma-core/openai/": {
                    id: ()=>"[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)",
                    module: ()=>__turbopack_context__.A("[project]/node_modules/@chroma-core/openai/dist/openai.legacy-esm.js [app-route] (ecmascript, async loader)")
                }
            }).import(fullPackageName);
            sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);
        } catch (error) {}
        if (!sparseEmbeddingFunction) {
            console.warn(`Collection ${collectionName} was created with the ${packageName} sparse embedding function. However, the @chroma-core/${packageName} package is not installed.`);
            return void 0;
        }
    }
    let constructorConfig = efConfig.type === "known" ? efConfig.config : {};
    try {
        if (sparseEmbeddingFunction.buildFromConfig) {
            return sparseEmbeddingFunction.buildFromConfig(constructorConfig, client2);
        }
        console.warn(`Sparse embedding function ${packageName} does not define a 'buildFromConfig' function.`);
        return void 0;
    } catch (e) {
        console.warn(`Sparse embedding function ${packageName} failed to build with config: ${constructorConfig}. Error: ${e}`);
        return void 0;
    }
};
var serializeEmbeddingFunction = ({ embeddingFunction, configEmbeddingFunction })=>{
    if (embeddingFunction && configEmbeddingFunction) {
        throw new ChromaValueError("Embedding function provided when already defined in the collection configuration");
    }
    if (!embeddingFunction && !configEmbeddingFunction) {
        return void 0;
    }
    const ef = embeddingFunction || configEmbeddingFunction;
    if (!ef.getConfig || !ef.name || !ef.constructor.buildFromConfig) {
        return {
            type: "legacy"
        };
    }
    if (ef.validateConfig) ef.validateConfig(ef.getConfig());
    return {
        name: ef.name,
        type: "known",
        config: ef.getConfig()
    };
};
var getDefaultEFConfig = async ()=>{
    try {
        const { DefaultEmbeddingFunction } = await __turbopack_context__.A("[project]/node_modules/@chroma-core/default-embed/dist/default-embed.mjs [app-route] (ecmascript, async loader)");
        if (!knownEmbeddingFunctions.has("default-embed")) {
            registerEmbeddingFunction("default-embed", DefaultEmbeddingFunction);
        }
    } catch (e) {
        console.warn("Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function");
    }
    return {
        name: "default",
        type: "known",
        config: {}
    };
};
// src/collection-configuration.ts
var processCreateCollectionConfig = async ({ configuration, embeddingFunction, metadata, schema })=>{
    let schemaEmbeddingFunction = void 0;
    if (schema) {
        schemaEmbeddingFunction = schema.resolveEmbeddingFunction();
    }
    if (configuration?.hnsw && configuration?.spann) {
        throw new ChromaValueError("Cannot specify both HNSW and SPANN configurations");
    }
    let embeddingFunctionConfiguration = serializeEmbeddingFunction({
        embeddingFunction: embeddingFunction ?? void 0,
        configEmbeddingFunction: configuration?.embeddingFunction
    });
    if (!embeddingFunctionConfiguration && embeddingFunction !== null && schemaEmbeddingFunction === void 0) {
        embeddingFunctionConfiguration = await getDefaultEFConfig();
    }
    const overallEf = embeddingFunction || configuration?.embeddingFunction;
    if (overallEf && overallEf.defaultSpace && overallEf.supportedSpaces) {
        if (configuration?.hnsw === void 0 && configuration?.spann === void 0) {
            if (metadata === void 0 || metadata?.["hnsw:space"] === void 0) {
                if (!configuration) configuration = {};
                configuration.hnsw = {
                    space: overallEf.defaultSpace()
                };
            }
        }
        if (configuration?.hnsw && !configuration.hnsw.space && overallEf.defaultSpace) {
            configuration.hnsw.space = overallEf.defaultSpace();
        }
        if (configuration?.spann && !configuration.spann.space && overallEf.defaultSpace) {
            configuration.spann.space = overallEf.defaultSpace();
        }
        if (overallEf.supportedSpaces) {
            const supportedSpaces = overallEf.supportedSpaces();
            if (configuration?.hnsw?.space && !supportedSpaces.includes(configuration.hnsw.space)) {
                console.warn(`Space '${configuration.hnsw.space}' is not supported by embedding function '${overallEf.name || "unknown"}'. Supported spaces: ${supportedSpaces.join(", ")}`);
            }
            if (configuration?.spann?.space && !supportedSpaces.includes(configuration.spann.space)) {
                console.warn(`Space '${configuration.spann.space}' is not supported by embedding function '${overallEf.name || "unknown"}'. Supported spaces: ${supportedSpaces.join(", ")}`);
            }
            if (!configuration?.hnsw && !configuration?.spann && metadata && typeof metadata["hnsw:space"] === "string" && !supportedSpaces.includes(metadata["hnsw:space"])) {
                console.warn(`Space '${metadata["hnsw:space"]}' from metadata is not supported by embedding function '${overallEf.name || "unknown"}'. Supported spaces: ${supportedSpaces.join(", ")}`);
            }
        }
    }
    return {
        ...configuration || {},
        embedding_function: embeddingFunctionConfiguration
    };
};
var processUpdateCollectionConfig = async ({ collectionName, currentConfiguration, currentEmbeddingFunction, newConfiguration, client: client2 })=>{
    if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== "object") {
        throw new ChromaValueError("Invalid HNSW config provided in UpdateCollectionConfiguration");
    }
    if (newConfiguration.spann && typeof newConfiguration.spann !== "object") {
        throw new ChromaValueError("Invalid SPANN config provided in UpdateCollectionConfiguration");
    }
    const embeddingFunction = currentEmbeddingFunction || await getEmbeddingFunction({
        collectionName,
        client: client2,
        efConfig: currentConfiguration.embeddingFunction ?? void 0
    });
    const newEmbeddingFunction = newConfiguration.embeddingFunction;
    if (embeddingFunction && embeddingFunction.validateConfigUpdate && newEmbeddingFunction && newEmbeddingFunction.getConfig) {
        embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());
    }
    return {
        updateConfiguration: {
            hnsw: newConfiguration.hnsw,
            spann: newConfiguration.spann,
            embedding_function: newEmbeddingFunction && serializeEmbeddingFunction({
                embeddingFunction: newEmbeddingFunction
            })
        },
        updateEmbeddingFunction: newEmbeddingFunction
    };
};
// src/execution/expression/common.ts
var isPlainObject = (value)=>{
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (Array.isArray(value)) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === Object.prototype || prototype === null;
};
var deepClone = (value)=>JSON.parse(JSON.stringify(value));
var iterableToArray = (values)=>{
    if (Array.isArray(values)) {
        return values.slice();
    }
    return Array.from(values);
};
var assertNonEmptyArray = (values, message)=>{
    if (values.length === 0) {
        throw new Error(message);
    }
};
// src/execution/expression/where.ts
var WhereExpressionBase = class {
    and(other) {
        const target = WhereExpression.from(other);
        if (!target) {
            return this;
        }
        return AndWhere.combine(this, target);
    }
    or(other) {
        const target = WhereExpression.from(other);
        if (!target) {
            return this;
        }
        return OrWhere.combine(this, target);
    }
};
var WhereExpression = class _WhereExpression extends WhereExpressionBase {
    static from(input) {
        if (input instanceof _WhereExpression) {
            return input;
        }
        if (input === null || input === void 0) {
            return void 0;
        }
        if (!isPlainObject(input)) {
            throw new TypeError("Where input must be a WhereExpression or plain object");
        }
        return parseWhereDict(input);
    }
};
var AndWhere = class _AndWhere extends WhereExpression {
    constructor(conditions){
        super();
        this.conditions = conditions;
    }
    toJSON() {
        return {
            $and: this.conditions.map((condition)=>condition.toJSON())
        };
    }
    get operands() {
        return this.conditions.slice();
    }
    static combine(left, right) {
        const flattened = [];
        const add = (expr)=>{
            if (expr instanceof _AndWhere) {
                flattened.push(...expr.operands);
            } else {
                flattened.push(expr);
            }
        };
        add(left);
        add(right);
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _AndWhere(flattened);
    }
};
var OrWhere = class _OrWhere extends WhereExpression {
    constructor(conditions){
        super();
        this.conditions = conditions;
    }
    toJSON() {
        return {
            $or: this.conditions.map((condition)=>condition.toJSON())
        };
    }
    get operands() {
        return this.conditions.slice();
    }
    static combine(left, right) {
        const flattened = [];
        const add = (expr)=>{
            if (expr instanceof _OrWhere) {
                flattened.push(...expr.operands);
            } else {
                flattened.push(expr);
            }
        };
        add(left);
        add(right);
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _OrWhere(flattened);
    }
};
var ComparisonWhere = class extends WhereExpression {
    constructor(key, operator, value){
        super();
        this.key = key;
        this.operator = operator;
        this.value = value;
    }
    toJSON() {
        return {
            [this.key]: {
                [this.operator]: this.value
            }
        };
    }
};
var comparisonOperatorMap = /* @__PURE__ */ new Map([
    [
        "$eq",
        (key, value)=>new ComparisonWhere(key, "$eq", value)
    ],
    [
        "$ne",
        (key, value)=>new ComparisonWhere(key, "$ne", value)
    ],
    [
        "$gt",
        (key, value)=>new ComparisonWhere(key, "$gt", value)
    ],
    [
        "$gte",
        (key, value)=>new ComparisonWhere(key, "$gte", value)
    ],
    [
        "$lt",
        (key, value)=>new ComparisonWhere(key, "$lt", value)
    ],
    [
        "$lte",
        (key, value)=>new ComparisonWhere(key, "$lte", value)
    ],
    [
        "$in",
        (key, value)=>new ComparisonWhere(key, "$in", value)
    ],
    [
        "$nin",
        (key, value)=>new ComparisonWhere(key, "$nin", value)
    ],
    [
        "$contains",
        (key, value)=>new ComparisonWhere(key, "$contains", value)
    ],
    [
        "$not_contains",
        (key, value)=>new ComparisonWhere(key, "$not_contains", value)
    ],
    [
        "$regex",
        (key, value)=>new ComparisonWhere(key, "$regex", value)
    ],
    [
        "$not_regex",
        (key, value)=>new ComparisonWhere(key, "$not_regex", value)
    ]
]);
var parseWhereDict = (data)=>{
    if ("$and" in data) {
        if (Object.keys(data).length !== 1) {
            throw new Error("$and cannot be combined with other keys");
        }
        const rawConditions = data["$and"];
        if (!Array.isArray(rawConditions) || rawConditions.length === 0) {
            throw new TypeError("$and must be a non-empty array");
        }
        const conditions = rawConditions.map((item, index)=>{
            const expr = WhereExpression.from(item);
            if (!expr) {
                throw new TypeError(`Invalid where clause at index ${index}`);
            }
            return expr;
        });
        if (conditions.length === 1) {
            return conditions[0];
        }
        return conditions.slice(1).reduce((acc, condition)=>AndWhere.combine(acc, condition), conditions[0]);
    }
    if ("$or" in data) {
        if (Object.keys(data).length !== 1) {
            throw new Error("$or cannot be combined with other keys");
        }
        const rawConditions = data["$or"];
        if (!Array.isArray(rawConditions) || rawConditions.length === 0) {
            throw new TypeError("$or must be a non-empty array");
        }
        const conditions = rawConditions.map((item, index)=>{
            const expr = WhereExpression.from(item);
            if (!expr) {
                throw new TypeError(`Invalid where clause at index ${index}`);
            }
            return expr;
        });
        if (conditions.length === 1) {
            return conditions[0];
        }
        return conditions.slice(1).reduce((acc, condition)=>OrWhere.combine(acc, condition), conditions[0]);
    }
    const entries = Object.entries(data);
    if (entries.length !== 1) {
        throw new Error("Where dictionary must contain exactly one field");
    }
    const [field, value] = entries[0];
    if (!isPlainObject(value)) {
        return new ComparisonWhere(field, "$eq", value);
    }
    const operatorEntries = Object.entries(value);
    if (operatorEntries.length !== 1) {
        throw new Error(`Operator dictionary for field "${field}" must contain exactly one operator`);
    }
    const [operator, operand] = operatorEntries[0];
    const factory = comparisonOperatorMap.get(operator);
    if (!factory) {
        throw new Error(`Unsupported where operator: ${operator}`);
    }
    return factory(field, operand);
};
var createComparisonWhere = (key, operator, value)=>new ComparisonWhere(key, operator, value);
// src/execution/expression/key.ts
var _Key = class _Key {
    constructor(name){
        this.name = name;
    }
    eq(value) {
        return createComparisonWhere(this.name, "$eq", value);
    }
    ne(value) {
        return createComparisonWhere(this.name, "$ne", value);
    }
    gt(value) {
        return createComparisonWhere(this.name, "$gt", value);
    }
    gte(value) {
        return createComparisonWhere(this.name, "$gte", value);
    }
    lt(value) {
        return createComparisonWhere(this.name, "$lt", value);
    }
    lte(value) {
        return createComparisonWhere(this.name, "$lte", value);
    }
    isIn(values) {
        const array = iterableToArray(values);
        assertNonEmptyArray(array, "$in requires at least one value");
        return createComparisonWhere(this.name, "$in", array);
    }
    notIn(values) {
        const array = iterableToArray(values);
        assertNonEmptyArray(array, "$nin requires at least one value");
        return createComparisonWhere(this.name, "$nin", array);
    }
    contains(value) {
        if (typeof value !== "string") {
            throw new TypeError("$contains requires a string value");
        }
        return createComparisonWhere(this.name, "$contains", value);
    }
    notContains(value) {
        if (typeof value !== "string") {
            throw new TypeError("$not_contains requires a string value");
        }
        return createComparisonWhere(this.name, "$not_contains", value);
    }
    regex(pattern) {
        if (typeof pattern !== "string") {
            throw new TypeError("$regex requires a string pattern");
        }
        return createComparisonWhere(this.name, "$regex", pattern);
    }
    notRegex(pattern) {
        if (typeof pattern !== "string") {
            throw new TypeError("$not_regex requires a string pattern");
        }
        return createComparisonWhere(this.name, "$not_regex", pattern);
    }
};
_Key.ID = new _Key("#id");
_Key.DOCUMENT = new _Key("#document");
_Key.EMBEDDING = new _Key("#embedding");
_Key.METADATA = new _Key("#metadata");
_Key.SCORE = new _Key("#score");
var Key = _Key;
var createKeyFactory = ()=>{
    const factory = (name)=>new Key(name);
    factory.ID = Key.ID;
    factory.DOCUMENT = Key.DOCUMENT;
    factory.EMBEDDING = Key.EMBEDDING;
    factory.METADATA = Key.METADATA;
    factory.SCORE = Key.SCORE;
    return factory;
};
var K = createKeyFactory();
// src/execution/expression/limit.ts
var Limit = class _Limit {
    constructor(options = {}){
        const { offset = 0, limit } = options;
        if (!Number.isInteger(offset) || offset < 0) {
            throw new TypeError("Limit offset must be a non-negative integer");
        }
        if (limit !== null && limit !== void 0) {
            if (!Number.isInteger(limit) || limit <= 0) {
                throw new TypeError("Limit must be a positive integer when provided");
            }
            this.limit = limit;
        }
        this.offset = offset;
    }
    static from(input, offsetOverride) {
        if (input instanceof _Limit) {
            return new _Limit({
                offset: input.offset,
                limit: input.limit
            });
        }
        if (typeof input === "number") {
            return new _Limit({
                limit: input,
                offset: offsetOverride ?? 0
            });
        }
        if (input === null || input === void 0) {
            return new _Limit();
        }
        if (typeof input === "object") {
            return new _Limit(input);
        }
        throw new TypeError("Invalid limit input");
    }
    toJSON() {
        const result = {
            offset: this.offset
        };
        if (this.limit !== void 0) {
            result.limit = this.limit;
        }
        return result;
    }
};
// src/execution/expression/select.ts
var Select = class _Select {
    constructor(keys = []){
        const unique = /* @__PURE__ */ new Set();
        for (const key of keys){
            const normalized = key instanceof Key ? key.name : key;
            if (typeof normalized !== "string") {
                throw new TypeError("Select keys must be strings or Key instances");
            }
            unique.add(normalized);
        }
        this.keys = Array.from(unique);
    }
    static from(input) {
        if (input instanceof _Select) {
            return new _Select(input.keys);
        }
        if (input === null || input === void 0) {
            return new _Select();
        }
        if (Symbol.iterator in Object(input)) {
            return new _Select(input);
        }
        if (typeof input === "object" && "keys" in input) {
            const { keys } = input;
            return new _Select(keys ?? []);
        }
        throw new TypeError("Unsupported select input");
    }
    static all() {
        return new _Select([
            Key.DOCUMENT,
            Key.EMBEDDING,
            Key.METADATA,
            Key.SCORE
        ]);
    }
    get values() {
        return this.keys.slice();
    }
    toJSON() {
        return {
            keys: this.values
        };
    }
};
// src/execution/expression/rank.ts
var requireNumber = (value, message)=>{
    if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) {
        throw new TypeError(message);
    }
    return value;
};
var RankExpressionBase = class {
    add(...others) {
        if (others.length === 0) {
            return this;
        }
        const expressions = [
            this,
            ...others.map((item, index)=>requireRank(item, `add operand ${index}`))
        ];
        return SumRankExpression.create(expressions);
    }
    subtract(other) {
        return new SubRankExpression(this, requireRank(other, "subtract operand"));
    }
    multiply(...others) {
        if (others.length === 0) {
            return this;
        }
        const expressions = [
            this,
            ...others.map((item, index)=>requireRank(item, `multiply operand ${index}`))
        ];
        return MulRankExpression.create(expressions);
    }
    divide(other) {
        return new DivRankExpression(this, requireRank(other, "divide operand"));
    }
    negate() {
        return this.multiply(-1);
    }
    abs() {
        return new AbsRankExpression(this);
    }
    exp() {
        return new ExpRankExpression(this);
    }
    log() {
        return new LogRankExpression(this);
    }
    max(...others) {
        if (others.length === 0) {
            return this;
        }
        const expressions = [
            this,
            ...others.map((item, index)=>requireRank(item, `max operand ${index}`))
        ];
        return MaxRankExpression.create(expressions);
    }
    min(...others) {
        if (others.length === 0) {
            return this;
        }
        const expressions = [
            this,
            ...others.map((item, index)=>requireRank(item, `min operand ${index}`))
        ];
        return MinRankExpression.create(expressions);
    }
};
var RankExpression = class _RankExpression extends RankExpressionBase {
    static from(input) {
        if (input instanceof _RankExpression) {
            return input;
        }
        if (input === null || input === void 0) {
            return void 0;
        }
        if (typeof input === "number") {
            return new ValueRankExpression(input);
        }
        if (isPlainObject(input)) {
            return new RawRankExpression(input);
        }
        throw new TypeError("Rank input must be a RankExpression, number, or plain object");
    }
};
var RawRankExpression = class extends RankExpression {
    constructor(raw){
        super();
        this.raw = raw;
    }
    toJSON() {
        return deepClone(this.raw);
    }
};
var ValueRankExpression = class extends RankExpression {
    constructor(value){
        super();
        this.value = value;
    }
    toJSON() {
        return {
            $val: this.value
        };
    }
};
var SumRankExpression = class _SumRankExpression extends RankExpression {
    constructor(ranks){
        super();
        this.ranks = ranks;
    }
    static create(ranks) {
        const flattened = [];
        for (const rank of ranks){
            if (rank instanceof _SumRankExpression) {
                flattened.push(...rank.operands);
            } else {
                flattened.push(rank);
            }
        }
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _SumRankExpression(flattened);
    }
    get operands() {
        return this.ranks.slice();
    }
    toJSON() {
        return {
            $sum: this.ranks.map((rank)=>rank.toJSON())
        };
    }
};
var SubRankExpression = class extends RankExpression {
    constructor(left, right){
        super();
        this.left = left;
        this.right = right;
    }
    toJSON() {
        return {
            $sub: {
                left: this.left.toJSON(),
                right: this.right.toJSON()
            }
        };
    }
};
var MulRankExpression = class _MulRankExpression extends RankExpression {
    constructor(ranks){
        super();
        this.ranks = ranks;
    }
    static create(ranks) {
        const flattened = [];
        for (const rank of ranks){
            if (rank instanceof _MulRankExpression) {
                flattened.push(...rank.operands);
            } else {
                flattened.push(rank);
            }
        }
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _MulRankExpression(flattened);
    }
    get operands() {
        return this.ranks.slice();
    }
    toJSON() {
        return {
            $mul: this.ranks.map((rank)=>rank.toJSON())
        };
    }
};
var DivRankExpression = class extends RankExpression {
    constructor(left, right){
        super();
        this.left = left;
        this.right = right;
    }
    toJSON() {
        return {
            $div: {
                left: this.left.toJSON(),
                right: this.right.toJSON()
            }
        };
    }
};
var AbsRankExpression = class extends RankExpression {
    constructor(operand){
        super();
        this.operand = operand;
    }
    toJSON() {
        return {
            $abs: this.operand.toJSON()
        };
    }
};
var ExpRankExpression = class extends RankExpression {
    constructor(operand){
        super();
        this.operand = operand;
    }
    toJSON() {
        return {
            $exp: this.operand.toJSON()
        };
    }
};
var LogRankExpression = class extends RankExpression {
    constructor(operand){
        super();
        this.operand = operand;
    }
    toJSON() {
        return {
            $log: this.operand.toJSON()
        };
    }
};
var MaxRankExpression = class _MaxRankExpression extends RankExpression {
    constructor(ranks){
        super();
        this.ranks = ranks;
    }
    static create(ranks) {
        const flattened = [];
        for (const rank of ranks){
            if (rank instanceof _MaxRankExpression) {
                flattened.push(...rank.operands);
            } else {
                flattened.push(rank);
            }
        }
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _MaxRankExpression(flattened);
    }
    get operands() {
        return this.ranks.slice();
    }
    toJSON() {
        return {
            $max: this.ranks.map((rank)=>rank.toJSON())
        };
    }
};
var MinRankExpression = class _MinRankExpression extends RankExpression {
    constructor(ranks){
        super();
        this.ranks = ranks;
    }
    static create(ranks) {
        const flattened = [];
        for (const rank of ranks){
            if (rank instanceof _MinRankExpression) {
                flattened.push(...rank.operands);
            } else {
                flattened.push(rank);
            }
        }
        if (flattened.length === 1) {
            return flattened[0];
        }
        return new _MinRankExpression(flattened);
    }
    get operands() {
        return this.ranks.slice();
    }
    toJSON() {
        return {
            $min: this.ranks.map((rank)=>rank.toJSON())
        };
    }
};
var KnnRankExpression = class extends RankExpression {
    constructor(config){
        super();
        this.config = config;
    }
    toJSON() {
        const base = {
            query: this.config.query,
            key: this.config.key,
            limit: this.config.limit
        };
        if (this.config.defaultValue !== void 0) {
            base.default = this.config.defaultValue;
        }
        if (this.config.returnRank) {
            base.return_rank = true;
        }
        return {
            $knn: base
        };
    }
};
var normalizeDenseVector = (vector)=>{
    if (Array.isArray(vector)) {
        return vector.slice();
    }
    return Array.from(vector, (value)=>{
        if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) {
            throw new TypeError("Dense query vector values must be finite numbers");
        }
        return value;
    });
};
var normalizeKnnOptions = (options)=>{
    const limit = options.limit ?? 128;
    if (!Number.isInteger(limit) || limit <= 0) {
        throw new TypeError("Knn limit must be a positive integer");
    }
    const queryInput = options.query;
    let query;
    if (typeof queryInput === "string") {
        query = queryInput;
    } else if (isPlainObject(queryInput) && Array.isArray(queryInput.indices) && Array.isArray(queryInput.values)) {
        const sparse = queryInput;
        query = {
            indices: sparse.indices.slice(),
            values: sparse.values.slice()
        };
    } else {
        query = normalizeDenseVector(queryInput);
    }
    const key = options.key instanceof Key ? options.key.name : options.key ?? "#embedding";
    if (typeof key !== "string") {
        throw new TypeError("Knn key must be a string or Key instance");
    }
    const defaultValue = options.default === null || options.default === void 0 ? void 0 : requireNumber(options.default, "Knn default must be a number");
    if (defaultValue !== void 0 && !Number.isFinite(defaultValue)) {
        throw new TypeError("Knn default must be a finite number");
    }
    return {
        query: Array.isArray(query) || typeof query === "string" ? query : deepClone(query),
        key,
        limit,
        defaultValue,
        returnRank: options.returnRank ?? false
    };
};
var requireRank = (input, context)=>{
    const result = RankExpression.from(input);
    if (!result) {
        throw new TypeError(`${context} must be a rank expression`);
    }
    return result;
};
var Val = (value)=>new ValueRankExpression(requireNumber(value, "Val requires a numeric value"));
var Knn = (options)=>new KnnRankExpression(normalizeKnnOptions(options));
var Rrf = ({ ranks, k = 60, weights, normalize = false })=>{
    if (!Number.isInteger(k) || k <= 0) {
        throw new TypeError("Rrf k must be a positive integer");
    }
    if (!Array.isArray(ranks) || ranks.length === 0) {
        throw new TypeError("Rrf requires at least one rank expression");
    }
    const expressions = ranks.map((rank, index)=>requireRank(rank, `ranks[${index}]`));
    let weightValues = weights ? weights.slice() : new Array(expressions.length).fill(1);
    if (weightValues.length !== expressions.length) {
        throw new Error("Number of weights must match number of ranks");
    }
    if (weightValues.some((value)=>typeof value !== "number" || value < 0)) {
        throw new TypeError("Weights must be non-negative numbers");
    }
    if (normalize) {
        const total = weightValues.reduce((sum, value)=>sum + value, 0);
        if (total <= 0) {
            throw new Error("Weights must sum to a positive value when normalize=true");
        }
        weightValues = weightValues.map((value)=>value / total);
    }
    const terms = expressions.map((rank, index)=>{
        const weight = weightValues[index];
        const numerator = Val(weight);
        const denominator = rank.add(k);
        return numerator.divide(denominator);
    });
    const fused = terms.reduce((acc, term)=>acc.add(term));
    return fused.negate();
};
var Sum = (...inputs)=>{
    if (inputs.length === 0) {
        throw new Error("Sum requires at least one rank expression");
    }
    const expressions = inputs.map((rank, index)=>requireRank(rank, `Sum operand ${index}`));
    return SumRankExpression.create(expressions);
};
var Sub = (left, right)=>new SubRankExpression(requireRank(left, "Sub left"), requireRank(right, "Sub right"));
var Mul = (...inputs)=>{
    if (inputs.length === 0) {
        throw new Error("Mul requires at least one rank expression");
    }
    const expressions = inputs.map((rank, index)=>requireRank(rank, `Mul operand ${index}`));
    return MulRankExpression.create(expressions);
};
var Div = (left, right)=>new DivRankExpression(requireRank(left, "Div left"), requireRank(right, "Div right"));
var Abs = (input)=>requireRank(input, "Abs").abs();
var Exp = (input)=>requireRank(input, "Exp").exp();
var Log = (input)=>requireRank(input, "Log").log();
var Max = (...inputs)=>{
    if (inputs.length === 0) {
        throw new Error("Max requires at least one rank expression");
    }
    const expressions = inputs.map((rank, index)=>requireRank(rank, `Max operand ${index}`));
    return MaxRankExpression.create(expressions);
};
var Min = (...inputs)=>{
    if (inputs.length === 0) {
        throw new Error("Min requires at least one rank expression");
    }
    const expressions = inputs.map((rank, index)=>requireRank(rank, `Min operand ${index}`));
    return MinRankExpression.create(expressions);
};
// src/execution/expression/search.ts
var Search = class _Search {
    constructor(init = {}){
        this._where = init.where ? WhereExpression.from(init.where) : void 0;
        this._rank = init.rank ? RankExpression.from(init.rank) : void 0;
        this._limit = Limit.from(init.limit ?? void 0);
        this._select = Select.from(init.select ?? void 0);
    }
    clone(overrides) {
        const next = Object.create(_Search.prototype);
        next._where = overrides.where ?? this._where;
        next._rank = overrides.rank ?? this._rank;
        next._limit = overrides.limit ?? this._limit;
        next._select = overrides.select ?? this._select;
        return next;
    }
    where(where) {
        return this.clone({
            where: WhereExpression.from(where)
        });
    }
    rank(rank) {
        return this.clone({
            rank: RankExpression.from(rank ?? void 0)
        });
    }
    limit(limit, offset) {
        if (typeof limit === "number") {
            return this.clone({
                limit: Limit.from(limit, offset)
            });
        }
        return this.clone({
            limit: Limit.from(limit ?? void 0)
        });
    }
    select(first, ...rest) {
        if (Array.isArray(first) || first instanceof Set) {
            return this.clone({
                select: Select.from(first)
            });
        }
        if (first instanceof Select) {
            return this.clone({
                select: Select.from(first)
            });
        }
        if (typeof first === "object" && first !== null && "keys" in first) {
            return this.clone({
                select: Select.from(first)
            });
        }
        const allKeys = [];
        if (first !== void 0) {
            allKeys.push(first);
        }
        if (rest.length) {
            allKeys.push(...rest);
        }
        return this.clone({
            select: Select.from(allKeys)
        });
    }
    selectAll() {
        return this.clone({
            select: Select.all()
        });
    }
    get whereClause() {
        return this._where;
    }
    get rankExpression() {
        return this._rank;
    }
    get limitConfig() {
        return this._limit;
    }
    get selectConfig() {
        return this._select;
    }
    toPayload() {
        const payload = {
            limit: this._limit.toJSON(),
            select: this._select.toJSON()
        };
        if (this._where) {
            payload.filter = this._where.toJSON();
        }
        if (this._rank) {
            payload.rank = this._rank.toJSON();
        }
        return payload;
    }
};
var toSearch = (input)=>input instanceof Search ? input : new Search(input);
// src/execution/expression/searchResult.ts
var normalizePayloadArray = (payload, count)=>{
    if (!payload) {
        return Array(count).fill(null);
    }
    if (payload.length === count) {
        return payload.map((item)=>item ? item.slice() : null);
    }
    const result = payload.map((item)=>item ? item.slice() : null);
    while(result.length < count){
        result.push(null);
    }
    return result;
};
var SearchResult = class {
    constructor(response){
        this.ids = response.ids;
        const payloadCount = this.ids.length;
        this.documents = normalizePayloadArray(response.documents, payloadCount);
        this.embeddings = normalizePayloadArray(response.embeddings, payloadCount);
        const rawMetadatas = normalizePayloadArray(response.metadatas, payloadCount);
        this.metadatas = rawMetadatas.map((payload)=>{
            if (!payload) {
                return null;
            }
            return deserializeMetadatas(payload) ?? [];
        });
        this.scores = normalizePayloadArray(response.scores, payloadCount);
        this.select = response.select ?? [];
    }
    rows() {
        const results = [];
        for(let payloadIndex = 0; payloadIndex < this.ids.length; payloadIndex += 1){
            const ids = this.ids[payloadIndex];
            const docPayload = this.documents[payloadIndex] ?? [];
            const embedPayload = this.embeddings[payloadIndex] ?? [];
            const metaPayload = this.metadatas[payloadIndex] ?? [];
            const scorePayload = this.scores[payloadIndex] ?? [];
            const rows = ids.map((id, rowIndex)=>{
                const row = {
                    id
                };
                const document = docPayload[rowIndex];
                if (document !== void 0 && document !== null) {
                    row.document = document;
                }
                const embedding = embedPayload[rowIndex];
                if (embedding !== void 0 && embedding !== null) {
                    row.embedding = embedding;
                }
                const metadata = metaPayload[rowIndex];
                if (metadata !== void 0 && metadata !== null) {
                    row.metadata = metadata;
                }
                const score = scorePayload[rowIndex];
                if (score !== void 0 && score !== null) {
                    row.score = score;
                }
                return row;
            });
            results.push(rows);
        }
        return results;
    }
};
// src/schema.ts
var DOCUMENT_KEY = "#document";
var EMBEDDING_KEY = "#embedding";
var STRING_VALUE_NAME = "string";
var FLOAT_LIST_VALUE_NAME = "float_list";
var SPARSE_VECTOR_VALUE_NAME = "sparse_vector";
var INT_VALUE_NAME = "int";
var FLOAT_VALUE_NAME = "float";
var BOOL_VALUE_NAME = "bool";
var FTS_INDEX_NAME = "fts_index";
var STRING_INVERTED_INDEX_NAME = "string_inverted_index";
var VECTOR_INDEX_NAME = "vector_index";
var SPARSE_VECTOR_INDEX_NAME = "sparse_vector_index";
var INT_INVERTED_INDEX_NAME = "int_inverted_index";
var FLOAT_INVERTED_INDEX_NAME = "float_inverted_index";
var BOOL_INVERTED_INDEX_NAME = "bool_inverted_index";
var FtsIndexConfig = class {
    constructor(){
        this.type = "FtsIndexConfig";
    }
};
var StringInvertedIndexConfig = class {
    constructor(){
        this.type = "StringInvertedIndexConfig";
    }
};
var IntInvertedIndexConfig = class {
    constructor(){
        this.type = "IntInvertedIndexConfig";
    }
};
var FloatInvertedIndexConfig = class {
    constructor(){
        this.type = "FloatInvertedIndexConfig";
    }
};
var BoolInvertedIndexConfig = class {
    constructor(){
        this.type = "BoolInvertedIndexConfig";
    }
};
var VectorIndexConfig = class {
    constructor(options = {}){
        this.type = "VectorIndexConfig";
        this.space = options.space ?? null;
        this.embeddingFunction = options.embeddingFunction;
        this.sourceKey = options.sourceKey instanceof Key ? options.sourceKey.name : options.sourceKey ?? null;
        this.hnsw = options.hnsw ?? null;
        this.spann = options.spann ?? null;
    }
};
var SparseVectorIndexConfig = class {
    constructor(options = {}){
        this.type = "SparseVectorIndexConfig";
        this.embeddingFunction = options.embeddingFunction;
        this.sourceKey = options.sourceKey instanceof Key ? options.sourceKey.name : options.sourceKey ?? null;
        this.bm25 = options.bm25 ?? null;
    }
};
var FtsIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var StringInvertedIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var VectorIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var SparseVectorIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var IntInvertedIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var FloatInvertedIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var BoolInvertedIndexType = class {
    constructor(enabled, config){
        this.enabled = enabled;
        this.config = config;
    }
};
var StringValueType = class {
    constructor(ftsIndex = null, stringInvertedIndex = null){
        this.ftsIndex = ftsIndex;
        this.stringInvertedIndex = stringInvertedIndex;
    }
};
var FloatListValueType = class {
    constructor(vectorIndex = null){
        this.vectorIndex = vectorIndex;
    }
};
var SparseVectorValueType = class {
    constructor(sparseVectorIndex = null){
        this.sparseVectorIndex = sparseVectorIndex;
    }
};
var IntValueType = class {
    constructor(intInvertedIndex = null){
        this.intInvertedIndex = intInvertedIndex;
    }
};
var FloatValueType = class {
    constructor(floatInvertedIndex = null){
        this.floatInvertedIndex = floatInvertedIndex;
    }
};
var BoolValueType = class {
    constructor(boolInvertedIndex = null){
        this.boolInvertedIndex = boolInvertedIndex;
    }
};
var ValueTypes = class {
    constructor(){
        this.string = null;
        this.floatList = null;
        this.sparseVector = null;
        this.intValue = null;
        this.floatValue = null;
        this.boolean = null;
    }
};
var cloneObject = (value)=>{
    if (value === null || value === void 0) {
        return value;
    }
    if (typeof value !== "object") {
        return value;
    }
    return Array.isArray(value) ? value.map((item)=>cloneObject(item)) : Object.fromEntries(Object.entries(value).map(([k, v])=>[
            k,
            cloneObject(v)
        ]));
};
var resolveEmbeddingFunctionName = (fn)=>{
    if (!fn) return void 0;
    if (typeof fn.name === "function") {
        try {
            const value = fn.name();
            return typeof value === "string" ? value : void 0;
        } catch (_err) {
            return void 0;
        }
    }
    if (typeof fn.name === "string") {
        return fn.name;
    }
    return void 0;
};
var prepareEmbeddingFunctionConfig = (fn)=>{
    if (!fn) {
        return {
            type: "legacy"
        };
    }
    const name = resolveEmbeddingFunctionName(fn);
    const getConfig = typeof fn.getConfig === "function" ? fn.getConfig.bind(fn) : void 0;
    const buildFromConfig = fn.constructor?.buildFromConfig;
    if (!name || !getConfig || typeof buildFromConfig !== "function") {
        return {
            type: "legacy"
        };
    }
    const config = getConfig();
    if (typeof fn.validateConfig === "function") {
        fn.validateConfig(config);
    }
    return {
        type: "known",
        name,
        config
    };
};
var ensureValueTypes = (valueTypes)=>valueTypes ?? new ValueTypes();
var ensureStringValueType = (valueTypes)=>{
    if (!valueTypes.string) {
        valueTypes.string = new StringValueType();
    }
    return valueTypes.string;
};
var ensureFloatListValueType = (valueTypes)=>{
    if (!valueTypes.floatList) {
        valueTypes.floatList = new FloatListValueType();
    }
    return valueTypes.floatList;
};
var ensureSparseVectorValueType = (valueTypes)=>{
    if (!valueTypes.sparseVector) {
        valueTypes.sparseVector = new SparseVectorValueType();
    }
    return valueTypes.sparseVector;
};
var ensureIntValueType = (valueTypes)=>{
    if (!valueTypes.intValue) {
        valueTypes.intValue = new IntValueType();
    }
    return valueTypes.intValue;
};
var ensureFloatValueType = (valueTypes)=>{
    if (!valueTypes.floatValue) {
        valueTypes.floatValue = new FloatValueType();
    }
    return valueTypes.floatValue;
};
var ensureBoolValueType = (valueTypes)=>{
    if (!valueTypes.boolean) {
        valueTypes.boolean = new BoolValueType();
    }
    return valueTypes.boolean;
};
var Schema = class _Schema {
    constructor(){
        this.defaults = new ValueTypes();
        this.keys = {};
        this.initializeDefaults();
        this.initializeKeys();
    }
    createIndex(config, key) {
        const configProvided = config !== void 0 && config !== null;
        const keyProvided = key !== void 0 && key !== null;
        if (!configProvided && !keyProvided) {
            throw new Error("Cannot enable all index types globally. Must specify either config or key.");
        }
        if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {
            throw new Error(`Cannot create index on special key '${key}'. These keys are managed automatically by the system.`);
        }
        if (config instanceof VectorIndexConfig) {
            if (!keyProvided) {
                this.setVectorIndexConfig(config);
                return this;
            }
            throw new Error("Vector index cannot be enabled on specific keys. Use createIndex(config=VectorIndexConfig(...)) without specifying a key to configure the vector index globally.");
        }
        if (config instanceof FtsIndexConfig) {
            if (!keyProvided) {
                this.setFtsIndexConfig(config);
                return this;
            }
            throw new Error("FTS index cannot be enabled on specific keys. Use createIndex(config=FtsIndexConfig(...)) without specifying a key to configure the FTS index globally.");
        }
        if (config instanceof SparseVectorIndexConfig && !keyProvided) {
            throw new Error("Sparse vector index must be created on a specific key. Please specify a key using: createIndex(config=SparseVectorIndexConfig(...), key='your_key')");
        }
        if (!configProvided && keyProvided && key) {
            throw new Error(`Cannot enable all index types for key '${key}'. Please specify a specific index configuration.`);
        }
        if (configProvided && !keyProvided) {
            this.setIndexInDefaults(config, true);
        } else if (configProvided && keyProvided && key) {
            this.setIndexForKey(key, config, true);
        }
        return this;
    }
    deleteIndex(config, key) {
        const configProvided = config !== void 0 && config !== null;
        const keyProvided = key !== void 0 && key !== null;
        if (!configProvided && !keyProvided) {
            throw new Error("Cannot disable all indexes. Must specify either config or key.");
        }
        if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {
            throw new Error(`Cannot delete index on special key '${key}'. These keys are managed automatically by the system.`);
        }
        if (config instanceof VectorIndexConfig) {
            throw new Error("Deleting vector index is not currently supported.");
        }
        if (config instanceof FtsIndexConfig) {
            throw new Error("Deleting FTS index is not currently supported.");
        }
        if (config instanceof SparseVectorIndexConfig) {
            throw new Error("Deleting sparse vector index is not currently supported.");
        }
        if (keyProvided && !configProvided && key) {
            throw new Error(`Cannot disable all index types for key '${key}'. Please specify a specific index configuration.`);
        }
        if (keyProvided && configProvided && key) {
            this.setIndexForKey(key, config, false);
        } else if (!keyProvided && configProvided) {
            this.setIndexInDefaults(config, false);
        }
        return this;
    }
    serializeToJSON() {
        const defaults = this.serializeValueTypes(this.defaults);
        const keys = {};
        for (const [keyName, valueTypes] of Object.entries(this.keys)){
            keys[keyName] = this.serializeValueTypes(valueTypes);
        }
        return {
            defaults,
            keys
        };
    }
    static async deserializeFromJSON(json, client2) {
        if (json == null) {
            return void 0;
        }
        const data = json;
        const instance = Object.create(_Schema.prototype);
        instance.defaults = await _Schema.deserializeValueTypes(data.defaults ?? {}, client2);
        instance.keys = {};
        const keys = data.keys ?? {};
        for (const [keyName, value] of Object.entries(keys)){
            instance.keys[keyName] = await _Schema.deserializeValueTypes(value, client2);
        }
        return instance;
    }
    setVectorIndexConfig(config) {
        const defaultsFloatList = ensureFloatListValueType(this.defaults);
        const currentDefaultsVector = defaultsFloatList.vectorIndex ?? new VectorIndexType(false, new VectorIndexConfig());
        defaultsFloatList.vectorIndex = new VectorIndexType(currentDefaultsVector.enabled, new VectorIndexConfig({
            space: config.space ?? null,
            embeddingFunction: config.embeddingFunction,
            sourceKey: config.sourceKey ?? null,
            hnsw: config.hnsw ? cloneObject(config.hnsw) : null,
            spann: config.spann ? cloneObject(config.spann) : null
        }));
        const embeddingValueTypes = ensureValueTypes(this.keys[EMBEDDING_KEY]);
        this.keys[EMBEDDING_KEY] = embeddingValueTypes;
        const overrideFloatList = ensureFloatListValueType(embeddingValueTypes);
        const currentOverrideVector = overrideFloatList.vectorIndex ?? new VectorIndexType(true, new VectorIndexConfig({
            sourceKey: DOCUMENT_KEY
        }));
        const preservedSourceKey = currentOverrideVector.config.sourceKey ?? DOCUMENT_KEY;
        overrideFloatList.vectorIndex = new VectorIndexType(currentOverrideVector.enabled, new VectorIndexConfig({
            space: config.space ?? null,
            embeddingFunction: config.embeddingFunction,
            sourceKey: preservedSourceKey,
            hnsw: config.hnsw ? cloneObject(config.hnsw) : null,
            spann: config.spann ? cloneObject(config.spann) : null
        }));
    }
    setFtsIndexConfig(config) {
        const defaultsString = ensureStringValueType(this.defaults);
        const currentDefaultsFts = defaultsString.ftsIndex ?? new FtsIndexType(false, new FtsIndexConfig());
        defaultsString.ftsIndex = new FtsIndexType(currentDefaultsFts.enabled, config);
        const documentValueTypes = ensureValueTypes(this.keys[DOCUMENT_KEY]);
        this.keys[DOCUMENT_KEY] = documentValueTypes;
        const overrideString = ensureStringValueType(documentValueTypes);
        const currentOverrideFts = overrideString.ftsIndex ?? new FtsIndexType(true, new FtsIndexConfig());
        overrideString.ftsIndex = new FtsIndexType(currentOverrideFts.enabled, config);
    }
    setIndexInDefaults(config, enabled) {
        if (config instanceof FtsIndexConfig) {
            const valueType = ensureStringValueType(this.defaults);
            valueType.ftsIndex = new FtsIndexType(enabled, config);
        } else if (config instanceof StringInvertedIndexConfig) {
            const valueType = ensureStringValueType(this.defaults);
            valueType.stringInvertedIndex = new StringInvertedIndexType(enabled, config);
        } else if (config instanceof VectorIndexConfig) {
            const valueType = ensureFloatListValueType(this.defaults);
            valueType.vectorIndex = new VectorIndexType(enabled, config);
        } else if (config instanceof SparseVectorIndexConfig) {
            const valueType = ensureSparseVectorValueType(this.defaults);
            valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);
        } else if (config instanceof IntInvertedIndexConfig) {
            const valueType = ensureIntValueType(this.defaults);
            valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);
        } else if (config instanceof FloatInvertedIndexConfig) {
            const valueType = ensureFloatValueType(this.defaults);
            valueType.floatInvertedIndex = new FloatInvertedIndexType(enabled, config);
        } else if (config instanceof BoolInvertedIndexConfig) {
            const valueType = ensureBoolValueType(this.defaults);
            valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);
        }
    }
    setIndexForKey(key, config, enabled) {
        if (config instanceof SparseVectorIndexConfig && enabled) {
            this.validateSingleSparseVectorIndex(key);
            this.validateSparseVectorConfig(config);
        }
        const current = this.keys[key] = ensureValueTypes(this.keys[key]);
        if (config instanceof StringInvertedIndexConfig) {
            const valueType = ensureStringValueType(current);
            valueType.stringInvertedIndex = new StringInvertedIndexType(enabled, config);
        } else if (config instanceof FtsIndexConfig) {
            const valueType = ensureStringValueType(current);
            valueType.ftsIndex = new FtsIndexType(enabled, config);
        } else if (config instanceof SparseVectorIndexConfig) {
            const valueType = ensureSparseVectorValueType(current);
            valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);
        } else if (config instanceof VectorIndexConfig) {
            const valueType = ensureFloatListValueType(current);
            valueType.vectorIndex = new VectorIndexType(enabled, config);
        } else if (config instanceof IntInvertedIndexConfig) {
            const valueType = ensureIntValueType(current);
            valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);
        } else if (config instanceof FloatInvertedIndexConfig) {
            const valueType = ensureFloatValueType(current);
            valueType.floatInvertedIndex = new FloatInvertedIndexType(enabled, config);
        } else if (config instanceof BoolInvertedIndexConfig) {
            const valueType = ensureBoolValueType(current);
            valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);
        }
    }
    enableAllIndexesForKey(key) {
        if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {
            throw new Error(`Cannot enable all indexes for special key '${key}'. These keys are managed automatically by the system.`);
        }
        const current = this.keys[key] = ensureValueTypes(this.keys[key]);
        current.string = new StringValueType(new FtsIndexType(true, new FtsIndexConfig()), new StringInvertedIndexType(true, new StringInvertedIndexConfig()));
        current.floatList = new FloatListValueType(new VectorIndexType(true, new VectorIndexConfig()));
        current.sparseVector = new SparseVectorValueType(new SparseVectorIndexType(false, new SparseVectorIndexConfig()));
        current.intValue = new IntValueType(new IntInvertedIndexType(true, new IntInvertedIndexConfig()));
        current.floatValue = new FloatValueType(new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()));
        current.boolean = new BoolValueType(new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()));
    }
    disableAllIndexesForKey(key) {
        if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {
            throw new Error(`Cannot disable all indexes for special key '${key}'. These keys are managed automatically by the system.`);
        }
        const current = this.keys[key] = ensureValueTypes(this.keys[key]);
        current.string = new StringValueType(new FtsIndexType(false, new FtsIndexConfig()), new StringInvertedIndexType(false, new StringInvertedIndexConfig()));
        current.floatList = new FloatListValueType(new VectorIndexType(false, new VectorIndexConfig()));
        current.sparseVector = new SparseVectorValueType(new SparseVectorIndexType(false, new SparseVectorIndexConfig()));
        current.intValue = new IntValueType(new IntInvertedIndexType(false, new IntInvertedIndexConfig()));
        current.floatValue = new FloatValueType(new FloatInvertedIndexType(false, new FloatInvertedIndexConfig()));
        current.boolean = new BoolValueType(new BoolInvertedIndexType(false, new BoolInvertedIndexConfig()));
    }
    validateSingleSparseVectorIndex(targetKey) {
        for (const [existingKey, valueTypes] of Object.entries(this.keys)){
            if (existingKey === targetKey) continue;
            const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;
            if (sparseIndex?.enabled) {
                throw new Error(`Cannot enable sparse vector index on key '${targetKey}'. A sparse vector index is already enabled on key '${existingKey}'. Only one sparse vector index is allowed per collection.`);
            }
        }
    }
    validateSparseVectorConfig(config) {
        if (config.sourceKey !== null && config.sourceKey !== void 0 && !config.embeddingFunction) {
            throw new Error(`If sourceKey is provided then embeddingFunction must also be provided since there is no default embedding function. Config: ${JSON.stringify(config)}`);
        }
    }
    initializeDefaults() {
        this.defaults.string = new StringValueType(new FtsIndexType(false, new FtsIndexConfig()), new StringInvertedIndexType(true, new StringInvertedIndexConfig()));
        this.defaults.floatList = new FloatListValueType(new VectorIndexType(false, new VectorIndexConfig()));
        this.defaults.sparseVector = new SparseVectorValueType(new SparseVectorIndexType(false, new SparseVectorIndexConfig()));
        this.defaults.intValue = new IntValueType(new IntInvertedIndexType(true, new IntInvertedIndexConfig()));
        this.defaults.floatValue = new FloatValueType(new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()));
        this.defaults.boolean = new BoolValueType(new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()));
    }
    initializeKeys() {
        this.keys[DOCUMENT_KEY] = new ValueTypes();
        this.keys[DOCUMENT_KEY].string = new StringValueType(new FtsIndexType(true, new FtsIndexConfig()), new StringInvertedIndexType(false, new StringInvertedIndexConfig()));
        this.keys[EMBEDDING_KEY] = new ValueTypes();
        this.keys[EMBEDDING_KEY].floatList = new FloatListValueType(new VectorIndexType(true, new VectorIndexConfig({
            sourceKey: DOCUMENT_KEY
        })));
    }
    serializeValueTypes(valueTypes) {
        const result = {};
        if (valueTypes.string) {
            const serialized = this.serializeStringValueType(valueTypes.string);
            if (Object.keys(serialized).length > 0) {
                result[STRING_VALUE_NAME] = serialized;
            }
        }
        if (valueTypes.floatList) {
            const serialized = this.serializeFloatListValueType(valueTypes.floatList);
            if (Object.keys(serialized).length > 0) {
                result[FLOAT_LIST_VALUE_NAME] = serialized;
            }
        }
        if (valueTypes.sparseVector) {
            const serialized = this.serializeSparseVectorValueType(valueTypes.sparseVector);
            if (Object.keys(serialized).length > 0) {
                result[SPARSE_VECTOR_VALUE_NAME] = serialized;
            }
        }
        if (valueTypes.intValue) {
            const serialized = this.serializeIntValueType(valueTypes.intValue);
            if (Object.keys(serialized).length > 0) {
                result[INT_VALUE_NAME] = serialized;
            }
        }
        if (valueTypes.floatValue) {
            const serialized = this.serializeFloatValueType(valueTypes.floatValue);
            if (Object.keys(serialized).length > 0) {
                result[FLOAT_VALUE_NAME] = serialized;
            }
        }
        if (valueTypes.boolean) {
            const serialized = this.serializeBoolValueType(valueTypes.boolean);
            if (Object.keys(serialized).length > 0) {
                result[BOOL_VALUE_NAME] = serialized;
            }
        }
        return result;
    }
    serializeStringValueType(valueType) {
        const result = {};
        if (valueType.ftsIndex) {
            result[FTS_INDEX_NAME] = {
                enabled: valueType.ftsIndex.enabled,
                config: this.serializeConfig(valueType.ftsIndex.config)
            };
        }
        if (valueType.stringInvertedIndex) {
            result[STRING_INVERTED_INDEX_NAME] = {
                enabled: valueType.stringInvertedIndex.enabled,
                config: this.serializeConfig(valueType.stringInvertedIndex.config)
            };
        }
        return result;
    }
    serializeFloatListValueType(valueType) {
        const result = {};
        if (valueType.vectorIndex) {
            result[VECTOR_INDEX_NAME] = {
                enabled: valueType.vectorIndex.enabled,
                config: this.serializeConfig(valueType.vectorIndex.config)
            };
        }
        return result;
    }
    serializeSparseVectorValueType(valueType) {
        const result = {};
        if (valueType.sparseVectorIndex) {
            result[SPARSE_VECTOR_INDEX_NAME] = {
                enabled: valueType.sparseVectorIndex.enabled,
                config: this.serializeConfig(valueType.sparseVectorIndex.config)
            };
        }
        return result;
    }
    serializeIntValueType(valueType) {
        const result = {};
        if (valueType.intInvertedIndex) {
            result[INT_INVERTED_INDEX_NAME] = {
                enabled: valueType.intInvertedIndex.enabled,
                config: this.serializeConfig(valueType.intInvertedIndex.config)
            };
        }
        return result;
    }
    serializeFloatValueType(valueType) {
        const result = {};
        if (valueType.floatInvertedIndex) {
            result[FLOAT_INVERTED_INDEX_NAME] = {
                enabled: valueType.floatInvertedIndex.enabled,
                config: this.serializeConfig(valueType.floatInvertedIndex.config)
            };
        }
        return result;
    }
    serializeBoolValueType(valueType) {
        const result = {};
        if (valueType.boolInvertedIndex) {
            result[BOOL_INVERTED_INDEX_NAME] = {
                enabled: valueType.boolInvertedIndex.enabled,
                config: this.serializeConfig(valueType.boolInvertedIndex.config)
            };
        }
        return result;
    }
    serializeConfig(config) {
        if (config instanceof VectorIndexConfig) {
            return this.serializeVectorConfig(config);
        }
        if (config instanceof SparseVectorIndexConfig) {
            return this.serializeSparseVectorConfig(config);
        }
        return {};
    }
    serializeVectorConfig(config) {
        const serialized = {};
        const embeddingFunction = config.embeddingFunction;
        const efConfig = prepareEmbeddingFunctionConfig(embeddingFunction);
        serialized["embedding_function"] = efConfig;
        let resolvedSpace = config.space ?? null;
        if (!resolvedSpace && embeddingFunction?.defaultSpace) {
            resolvedSpace = embeddingFunction.defaultSpace();
        }
        if (resolvedSpace && embeddingFunction?.supportedSpaces && !embeddingFunction.supportedSpaces().includes(resolvedSpace)) {
            console.warn(`Space '${resolvedSpace}' is not supported by embedding function '${resolveEmbeddingFunctionName(embeddingFunction) ?? "unknown"}'. Supported spaces: ${embeddingFunction.supportedSpaces().join(", ")}`);
        }
        if (resolvedSpace) {
            serialized.space = resolvedSpace;
        }
        if (config.sourceKey) {
            serialized.source_key = config.sourceKey;
        }
        if (config.hnsw) {
            serialized.hnsw = cloneObject(config.hnsw);
        }
        if (config.spann) {
            serialized.spann = cloneObject(config.spann);
        }
        return serialized;
    }
    serializeSparseVectorConfig(config) {
        const serialized = {};
        const embeddingFunction = config.embeddingFunction;
        serialized["embedding_function"] = prepareEmbeddingFunctionConfig(embeddingFunction);
        if (config.sourceKey) {
            serialized.source_key = config.sourceKey;
        }
        if (typeof config.bm25 === "boolean") {
            serialized.bm25 = config.bm25;
        }
        return serialized;
    }
    static async deserializeValueTypes(json, client2) {
        const result = new ValueTypes();
        if (json[STRING_VALUE_NAME]) {
            result.string = _Schema.deserializeStringValueType(json[STRING_VALUE_NAME]);
        }
        if (json[FLOAT_LIST_VALUE_NAME]) {
            result.floatList = await _Schema.deserializeFloatListValueType(json[FLOAT_LIST_VALUE_NAME], client2);
        }
        if (json[SPARSE_VECTOR_VALUE_NAME]) {
            result.sparseVector = await _Schema.deserializeSparseVectorValueType(json[SPARSE_VECTOR_VALUE_NAME], client2);
        }
        if (json[INT_VALUE_NAME]) {
            result.intValue = _Schema.deserializeIntValueType(json[INT_VALUE_NAME]);
        }
        if (json[FLOAT_VALUE_NAME]) {
            result.floatValue = _Schema.deserializeFloatValueType(json[FLOAT_VALUE_NAME]);
        }
        if (json[BOOL_VALUE_NAME]) {
            result.boolean = _Schema.deserializeBoolValueType(json[BOOL_VALUE_NAME]);
        }
        return result;
    }
    static deserializeStringValueType(json) {
        let ftsIndex = null;
        let stringIndex = null;
        if (json[FTS_INDEX_NAME]) {
            const data = json[FTS_INDEX_NAME];
            ftsIndex = new FtsIndexType(Boolean(data.enabled), new FtsIndexConfig());
        }
        if (json[STRING_INVERTED_INDEX_NAME]) {
            const data = json[STRING_INVERTED_INDEX_NAME];
            stringIndex = new StringInvertedIndexType(Boolean(data.enabled), new StringInvertedIndexConfig());
        }
        return new StringValueType(ftsIndex, stringIndex);
    }
    static async deserializeFloatListValueType(json, client2) {
        let vectorIndex = null;
        if (json[VECTOR_INDEX_NAME]) {
            const data = json[VECTOR_INDEX_NAME];
            const enabled = Boolean(data.enabled);
            const config = await _Schema.deserializeVectorConfig(data.config ?? {}, client2);
            vectorIndex = new VectorIndexType(enabled, config);
        }
        return new FloatListValueType(vectorIndex);
    }
    static async deserializeSparseVectorValueType(json, client2) {
        let sparseIndex = null;
        if (json[SPARSE_VECTOR_INDEX_NAME]) {
            const data = json[SPARSE_VECTOR_INDEX_NAME];
            const enabled = Boolean(data.enabled);
            const config = await _Schema.deserializeSparseVectorConfig(data.config ?? {}, client2);
            sparseIndex = new SparseVectorIndexType(enabled, config);
        }
        return new SparseVectorValueType(sparseIndex);
    }
    static deserializeIntValueType(json) {
        let index = null;
        if (json[INT_INVERTED_INDEX_NAME]) {
            const data = json[INT_INVERTED_INDEX_NAME];
            index = new IntInvertedIndexType(Boolean(data.enabled), new IntInvertedIndexConfig());
        }
        return new IntValueType(index);
    }
    static deserializeFloatValueType(json) {
        let index = null;
        if (json[FLOAT_INVERTED_INDEX_NAME]) {
            const data = json[FLOAT_INVERTED_INDEX_NAME];
            index = new FloatInvertedIndexType(Boolean(data.enabled), new FloatInvertedIndexConfig());
        }
        return new FloatValueType(index);
    }
    static deserializeBoolValueType(json) {
        let index = null;
        if (json[BOOL_INVERTED_INDEX_NAME]) {
            const data = json[BOOL_INVERTED_INDEX_NAME];
            index = new BoolInvertedIndexType(Boolean(data.enabled), new BoolInvertedIndexConfig());
        }
        return new BoolValueType(index);
    }
    static async deserializeVectorConfig(json, client2) {
        const config = new VectorIndexConfig({
            space: json.space ?? null,
            sourceKey: json.source_key ?? null,
            hnsw: json.hnsw ? cloneObject(json.hnsw) : null,
            spann: json.spann ? cloneObject(json.spann) : null
        });
        config.embeddingFunction = await getEmbeddingFunction({
            collectionName: "schema deserialization",
            client: client2,
            efConfig: json.embedding_function
        });
        if (!config.space && config.embeddingFunction?.defaultSpace) {
            config.space = config.embeddingFunction.defaultSpace();
        }
        return config;
    }
    static async deserializeSparseVectorConfig(json, client2) {
        const config = new SparseVectorIndexConfig({
            sourceKey: json.source_key ?? null,
            bm25: typeof json.bm25 === "boolean" ? json.bm25 : null
        });
        const embeddingFunction = await getSparseEmbeddingFunction("schema deserialization", client2, json.embedding_function) ?? config.embeddingFunction ?? void 0;
        config.embeddingFunction = embeddingFunction ?? null;
        return config;
    }
    resolveEmbeddingFunction() {
        const embeddingOverride = this.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config.embeddingFunction;
        if (embeddingOverride !== void 0) {
            return embeddingOverride;
        }
        return this.defaults.floatList?.vectorIndex?.config.embeddingFunction;
    }
};
// src/collection.ts
var CollectionImpl = class _CollectionImpl {
    /**
   * Creates a new CollectionAPIImpl instance.
   * @param options - Configuration for the collection API
   */ constructor({ chromaClient, apiClient, id, tenant, database, name, metadata, configuration, embeddingFunction, schema }){
        this.chromaClient = chromaClient;
        this.apiClient = apiClient;
        this.id = id;
        this.tenant = tenant;
        this.database = database;
        this._name = name;
        this._metadata = metadata;
        this._configuration = configuration;
        this._embeddingFunction = embeddingFunction;
        this._schema = schema;
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
    }
    get configuration() {
        return this._configuration;
    }
    set configuration(configuration) {
        this._configuration = configuration;
    }
    get metadata() {
        return this._metadata;
    }
    set metadata(metadata) {
        this._metadata = metadata;
    }
    get embeddingFunction() {
        return this._embeddingFunction;
    }
    set embeddingFunction(embeddingFunction) {
        this._embeddingFunction = embeddingFunction;
    }
    get schema() {
        return this._schema;
    }
    set schema(schema) {
        this._schema = schema;
    }
    async path() {
        return {
            tenant: this.tenant,
            database: this.database,
            collection_id: this.id
        };
    }
    async embed(inputs, isQuery) {
        const embeddingFunction = this._embeddingFunction ?? this.getSchemaEmbeddingFunction();
        if (!embeddingFunction) {
            throw new ChromaValueError("Embedding function must be defined for operations requiring embeddings.");
        }
        if (isQuery && embeddingFunction.generateForQueries) {
            return await embeddingFunction.generateForQueries(inputs);
        }
        return await embeddingFunction.generate(inputs);
    }
    async sparseEmbed(sparseEmbeddingFunction, inputs, isQuery) {
        if (isQuery && sparseEmbeddingFunction.generateForQueries) {
            return await sparseEmbeddingFunction.generateForQueries(inputs);
        }
        return await sparseEmbeddingFunction.generate(inputs);
    }
    getSparseEmbeddingTargets() {
        const schema = this._schema;
        if (!schema) return {};
        const targets = {};
        for (const [key, valueTypes] of Object.entries(schema.keys)){
            const sparseVector = valueTypes.sparseVector;
            const sparseIndex = sparseVector?.sparseVectorIndex;
            if (!sparseIndex?.enabled) continue;
            const config = sparseIndex.config;
            if (!config.embeddingFunction || !config.sourceKey) continue;
            targets[key] = config;
        }
        return targets;
    }
    async applySparseEmbeddingsToMetadatas(metadatas, documents) {
        const sparseTargets = this.getSparseEmbeddingTargets();
        if (Object.keys(sparseTargets).length === 0) {
            return metadatas;
        }
        if (!metadatas) {
            if (!documents) {
                return void 0;
            }
            metadatas = Array(documents.length).fill(null).map(()=>({}));
        }
        const updatedMetadatas = metadatas.map((metadata)=>metadata !== null && metadata !== void 0 ? {
                ...metadata
            } : {});
        const documentsList = documents ? [
            ...documents
        ] : void 0;
        for (const [targetKey, config] of Object.entries(sparseTargets)){
            const sourceKey = config.sourceKey;
            const embeddingFunction = config.embeddingFunction;
            if (!sourceKey || !embeddingFunction) {
                continue;
            }
            const inputs = [];
            const positions = [];
            if (sourceKey === DOCUMENT_KEY) {
                if (!documentsList) {
                    continue;
                }
                updatedMetadatas.forEach((metadata, index)=>{
                    if (targetKey in metadata) {
                        return;
                    }
                    if (index < documentsList.length) {
                        const doc = documentsList[index];
                        if (typeof doc === "string") {
                            inputs.push(doc);
                            positions.push(index);
                        }
                    }
                });
                if (inputs.length === 0) {
                    continue;
                }
                const sparseEmbeddings2 = await this.sparseEmbed(embeddingFunction, inputs, false);
                if (sparseEmbeddings2.length !== positions.length) {
                    throw new ChromaValueError("Sparse embedding function returned unexpected number of embeddings.");
                }
                positions.forEach((position, idx)=>{
                    updatedMetadatas[position][targetKey] = sparseEmbeddings2[idx];
                });
                continue;
            }
            updatedMetadatas.forEach((metadata, index)=>{
                if (targetKey in metadata) {
                    return;
                }
                const sourceValue = metadata[sourceKey];
                if (typeof sourceValue !== "string") {
                    return;
                }
                inputs.push(sourceValue);
                positions.push(index);
            });
            if (inputs.length === 0) {
                continue;
            }
            const sparseEmbeddings = await this.sparseEmbed(embeddingFunction, inputs, false);
            if (sparseEmbeddings.length !== positions.length) {
                throw new ChromaValueError("Sparse embedding function returned unexpected number of embeddings.");
            }
            positions.forEach((position, idx)=>{
                updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];
            });
        }
        const resultMetadatas = updatedMetadatas.map((metadata)=>Object.keys(metadata).length === 0 ? null : metadata);
        return resultMetadatas;
    }
    async embedKnnLiteral(knn) {
        const queryValue = knn.query;
        if (typeof queryValue !== "string") {
            return {
                ...knn
            };
        }
        const keyValue = knn.key;
        const key = typeof keyValue === "string" ? keyValue : EMBEDDING_KEY;
        if (key === EMBEDDING_KEY) {
            const embeddings = await this.embed([
                queryValue
            ], true);
            if (!embeddings || embeddings.length !== 1) {
                throw new ChromaValueError("Embedding function returned unexpected number of embeddings.");
            }
            return {
                ...knn,
                query: embeddings[0]
            };
        }
        const schema = this._schema;
        if (!schema) {
            throw new ChromaValueError(`Cannot embed string query for key '${key}': schema is not available. Provide an embedded vector or configure an embedding function.`);
        }
        const valueTypes = schema.keys[key];
        if (!valueTypes) {
            throw new ChromaValueError(`Cannot embed string query for key '${key}': key not found in schema. Provide an embedded vector or configure an embedding function.`);
        }
        const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;
        if (sparseIndex?.enabled && sparseIndex.config.embeddingFunction) {
            const sparseEmbeddingFunction = sparseIndex.config.embeddingFunction;
            const sparseEmbeddings = await this.sparseEmbed(sparseEmbeddingFunction, [
                queryValue
            ], true);
            if (!sparseEmbeddings || sparseEmbeddings.length !== 1) {
                throw new ChromaValueError("Sparse embedding function returned unexpected number of embeddings.");
            }
            return {
                ...knn,
                query: sparseEmbeddings[0]
            };
        }
        const vectorIndex = valueTypes.floatList?.vectorIndex;
        if (vectorIndex?.enabled && vectorIndex.config.embeddingFunction) {
            const embeddingFunction = vectorIndex.config.embeddingFunction;
            const embeddings = embeddingFunction.generateForQueries ? await embeddingFunction.generateForQueries([
                queryValue
            ]) : await embeddingFunction.generate([
                queryValue
            ]);
            if (!embeddings || embeddings.length !== 1) {
                throw new ChromaValueError("Embedding function returned unexpected number of embeddings.");
            }
            return {
                ...knn,
                query: embeddings[0]
            };
        }
        throw new ChromaValueError(`Cannot embed string query for key '${key}': no embedding function configured. Provide an embedded vector or configure an embedding function.`);
    }
    async embedRankLiteral(rank) {
        if (rank === null || rank === void 0) {
            return rank;
        }
        if (Array.isArray(rank)) {
            return Promise.all(rank.map((item)=>this.embedRankLiteral(item)));
        }
        if (!isPlainObject(rank)) {
            return rank;
        }
        const entries = await Promise.all(Object.entries(rank).map(async ([key, value])=>{
            if (key === "$knn" && isPlainObject(value)) {
                return [
                    key,
                    await this.embedKnnLiteral(value)
                ];
            }
            return [
                key,
                await this.embedRankLiteral(value)
            ];
        }));
        return Object.fromEntries(entries);
    }
    async embedSearchPayload(payload) {
        if (!payload.rank) {
            return payload;
        }
        const embeddedRank = await this.embedRankLiteral(payload.rank);
        if (!isPlainObject(embeddedRank)) {
            return payload;
        }
        return {
            ...payload,
            rank: embeddedRank
        };
    }
    getSchemaEmbeddingFunction() {
        const schema = this._schema;
        if (!schema) return void 0;
        const schemaOverride = schema.keys[EMBEDDING_KEY];
        const overrideFunction = schemaOverride?.floatList?.vectorIndex?.config.embeddingFunction;
        if (overrideFunction) {
            return overrideFunction;
        }
        const defaultFunction = schema.defaults.floatList?.vectorIndex?.config.embeddingFunction;
        return defaultFunction ?? void 0;
    }
    async prepareRecords({ recordSet, update = false }) {
        const maxBatchSize = await this.chromaClient.getMaxBatchSize();
        validateRecordSetLengthConsistency(recordSet);
        validateIDs(recordSet.ids);
        validateBaseRecordSet({
            recordSet,
            update
        });
        validateMaxBatchSize(recordSet.ids.length, maxBatchSize);
        if (!recordSet.embeddings && recordSet.documents) {
            recordSet.embeddings = await this.embed(recordSet.documents, false);
        }
        const metadatasWithSparse = await this.applySparseEmbeddingsToMetadatas(recordSet.metadatas, recordSet.documents);
        const preparedRecordSet = {
            ...recordSet,
            metadatas: metadatasWithSparse
        };
        const base64Supported = await this.chromaClient.supportsBase64Encoding();
        if (base64Supported && recordSet.embeddings) {
            preparedRecordSet.embeddings = embeddingsToBase64Bytes(recordSet.embeddings);
        }
        return preparedRecordSet;
    }
    validateGet(include, ids, where, whereDocument) {
        validateInclude({
            include,
            exclude: [
                "distances"
            ]
        });
        if (ids) validateIDs(ids);
        if (where) validateWhere(where);
        if (whereDocument) validateWhereDocument(whereDocument);
    }
    async prepareQuery(recordSet, include, ids, where, whereDocument, nResults) {
        validateBaseRecordSet({
            recordSet,
            embeddingsField: "queryEmbeddings",
            documentsField: "queryTexts"
        });
        validateInclude({
            include
        });
        if (ids) validateIDs(ids);
        if (where) validateWhere(where);
        if (whereDocument) validateWhereDocument(whereDocument);
        if (nResults) validateNResults(nResults);
        let embeddings;
        if (!recordSet.embeddings) {
            embeddings = await this.embed(recordSet.documents, true);
        } else {
            embeddings = recordSet.embeddings;
        }
        return {
            ...recordSet,
            ids,
            embeddings
        };
    }
    validateDelete(ids, where, whereDocument) {
        if (ids) validateIDs(ids);
        if (where) validateWhere(where);
        if (whereDocument) validateWhereDocument(whereDocument);
    }
    async count() {
        const { data } = await DefaultService.collectionCount({
            client: this.apiClient,
            path: await this.path()
        });
        return data;
    }
    async add({ ids, embeddings, metadatas, documents, uris }) {
        const recordSet = {
            ids,
            embeddings,
            documents,
            metadatas,
            uris
        };
        const preparedRecordSet = await this.prepareRecords({
            recordSet
        });
        await DefaultService.collectionAdd({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids: preparedRecordSet.ids,
                embeddings: preparedRecordSet.embeddings,
                documents: preparedRecordSet.documents,
                metadatas: serializeMetadatas(preparedRecordSet.metadatas),
                uris: preparedRecordSet.uris
            }
        });
    }
    async get(args = {}) {
        const { ids, where, limit, offset, whereDocument, include = [
            "documents",
            "metadatas"
        ] } = args;
        this.validateGet(include, ids, where, whereDocument);
        const { data } = await DefaultService.collectionGet({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids,
                where,
                limit,
                offset,
                where_document: whereDocument,
                include
            }
        });
        const deserializedMetadatas = deserializeMetadatas(data.metadatas) ?? [];
        return new GetResult({
            documents: data.documents ?? [],
            embeddings: data.embeddings ?? [],
            ids: data.ids,
            include: data.include,
            metadatas: deserializedMetadatas,
            uris: data.uris ?? []
        });
    }
    async peek({ limit = 10 }) {
        return this.get({
            limit
        });
    }
    async query({ queryEmbeddings, queryTexts, queryURIs, ids, nResults = 10, where, whereDocument, include = [
        "metadatas",
        "documents",
        "distances"
    ] }) {
        const recordSet = {
            embeddings: queryEmbeddings,
            documents: queryTexts,
            uris: queryURIs
        };
        const queryRecordSet = await this.prepareQuery(recordSet, include, ids, where, whereDocument, nResults);
        const { data } = await DefaultService.collectionQuery({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids: queryRecordSet.ids,
                include,
                n_results: nResults,
                query_embeddings: queryRecordSet.embeddings,
                where,
                where_document: whereDocument
            }
        });
        const deserializedMetadatas = deserializeMetadataMatrix(data.metadatas) ?? [];
        return new QueryResult({
            distances: data.distances ?? [],
            documents: data.documents ?? [],
            embeddings: data.embeddings ?? [],
            ids: data.ids ?? [],
            include: data.include,
            metadatas: deserializedMetadatas,
            uris: data.uris ?? []
        });
    }
    async search(searches) {
        const items = Array.isArray(searches) ? searches : [
            searches
        ];
        if (items.length === 0) {
            throw new ChromaValueError("At least one search payload must be provided.");
        }
        const payloads = await Promise.all(items.map(async (search)=>{
            const payload = toSearch(search).toPayload();
            return this.embedSearchPayload(payload);
        }));
        const { data } = await DefaultService.collectionSearch({
            client: this.apiClient,
            path: await this.path(),
            body: {
                searches: payloads
            }
        });
        return new SearchResult(data);
    }
    async modify({ name, metadata, configuration }) {
        if (name) this.name = name;
        if (metadata) {
            validateMetadata(metadata);
            this.metadata = metadata;
        }
        const { updateConfiguration, updateEmbeddingFunction } = configuration ? await processUpdateCollectionConfig({
            collectionName: this.name,
            currentConfiguration: this.configuration,
            newConfiguration: configuration,
            currentEmbeddingFunction: this.embeddingFunction,
            client: this.chromaClient
        }) : {};
        if (updateEmbeddingFunction) {
            this.embeddingFunction = updateEmbeddingFunction;
        }
        if (updateConfiguration) {
            this.configuration = {
                hnsw: {
                    ...this.configuration.hnsw,
                    ...updateConfiguration.hnsw
                },
                spann: {
                    ...this.configuration.spann,
                    ...updateConfiguration.spann
                },
                embeddingFunction: updateConfiguration.embedding_function
            };
        }
        await DefaultService.updateCollection({
            client: this.apiClient,
            path: await this.path(),
            body: {
                new_name: name,
                new_metadata: serializeMetadata(metadata),
                new_configuration: updateConfiguration
            }
        });
    }
    async fork({ name }) {
        const { data } = await DefaultService.forkCollection({
            client: this.apiClient,
            path: await this.path(),
            body: {
                new_name: name
            }
        });
        return new _CollectionImpl({
            chromaClient: this.chromaClient,
            apiClient: this.apiClient,
            name: data.name,
            tenant: this.tenant,
            database: this.database,
            id: data.id,
            embeddingFunction: this._embeddingFunction,
            metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,
            configuration: data.configuration_json
        });
    }
    async update({ ids, embeddings, metadatas, documents, uris }) {
        const recordSet = {
            ids,
            embeddings,
            documents,
            metadatas,
            uris
        };
        const preparedRecordSet = await this.prepareRecords({
            recordSet,
            update: true
        });
        await DefaultService.collectionUpdate({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids: preparedRecordSet.ids,
                embeddings: preparedRecordSet.embeddings,
                metadatas: serializeMetadatas(preparedRecordSet.metadatas),
                uris: preparedRecordSet.uris,
                documents: preparedRecordSet.documents
            }
        });
    }
    async upsert({ ids, embeddings, metadatas, documents, uris }) {
        const recordSet = {
            ids,
            embeddings,
            documents,
            metadatas,
            uris
        };
        const preparedRecordSet = await this.prepareRecords({
            recordSet
        });
        await DefaultService.collectionUpsert({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids: preparedRecordSet.ids,
                embeddings: preparedRecordSet.embeddings,
                metadatas: serializeMetadatas(preparedRecordSet.metadatas),
                uris: preparedRecordSet.uris,
                documents: preparedRecordSet.documents
            }
        });
    }
    async delete({ ids, where, whereDocument }) {
        this.validateDelete(ids, where, whereDocument);
        await DefaultService.collectionDelete({
            client: this.apiClient,
            path: await this.path(),
            body: {
                ids,
                where,
                where_document: whereDocument
            }
        });
    }
};
// src/next.ts
function withChroma(userNextConfig = {}) {
    const originalWebpackFunction = userNextConfig.webpack;
    const newWebpackFunction = (config, options)=>{
        if (!Array.isArray(config.externals)) {
            config.externals = [];
        }
        const externalsToAdd = [
            "@huggingface/transformers",
            "chromadb"
        ];
        for (const ext of externalsToAdd){
            if (!config.externals.includes(ext)) {
                config.externals.push(ext);
            }
        }
        if (typeof originalWebpackFunction === "function") {
            return originalWebpackFunction(config, options);
        }
        return config;
    };
    return {
        ...userNextConfig,
        webpack: newWebpackFunction
    };
}
// src/chroma-fetch.ts
var offlineError = (error)=>{
    return Boolean((error?.name === "TypeError" || error?.name === "FetchError") && (error.message?.includes("fetch failed") || error.message?.includes("Failed to fetch") || error.message?.includes("ENOTFOUND")));
};
var getErrorMessage = async (response)=>{
    try {
        const body = await response.clone().json();
        return body.message || body.error || `${response.status}: ${response.statusText}`;
    } catch  {
        return `${response.status}: ${response.statusText}`;
    }
};
var chromaFetch = async (input, init)=>{
    let response;
    try {
        response = await fetch(input, init);
    } catch (err) {
        if (offlineError(err)) {
            throw new ChromaConnectionError("Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.");
        }
        throw new ChromaConnectionError("Failed to connect to Chroma");
    }
    if (response.ok) {
        return response;
    }
    switch(response.status){
        case 400:
            let status = "Bad Request";
            try {
                const responseBody = await response.json();
                status = responseBody.message || status;
            } catch  {}
            throw new ChromaClientError(`Bad request to ${input.url || "Chroma"} with status: ${status}`);
        case 401:
            throw new ChromaUnauthorizedError(`Unauthorized`);
        case 403:
            throw new ChromaForbiddenError(`You do not have permission to access the requested resource.`);
        case 404:
            throw new ChromaNotFoundError(`The requested resource could not be found`);
        case 409:
            throw new ChromaUniqueError("The resource already exists");
        case 422:
            try {
                const body = await response.json();
                if (body && body.message && (body.message.startsWith("Quota exceeded") || body.message.startsWith("Billing limit exceeded"))) {
                    throw new ChromaQuotaExceededError(body?.message);
                }
                throw new ChromaClientError(body?.message || "Unprocessable Entity");
            } catch (error) {
                if (error instanceof ChromaQuotaExceededError || error instanceof ChromaClientError) {
                    throw error;
                }
                throw new ChromaClientError(`Unprocessable Entity: ${response.statusText}`);
            }
        case 429:
            throw new ChromaRateLimitError("Rate limit exceeded");
    }
    const errorMessage = await getErrorMessage(response);
    throw new ChromaServerError(errorMessage);
};
// src/admin-client.ts
var AdminClient = class {
    /**
   * Creates a new AdminClient instance.
   * @param args - Optional configuration for the admin client
   */ constructor(args){
        const { host, port, ssl, headers, fetchOptions } = args || defaultAdminClientArgs;
        const baseUrl = `${ssl ? "https" : "http"}://${host}:${port}`;
        const configOptions = {
            ...fetchOptions,
            method: normalizeMethod(fetchOptions?.method),
            baseUrl,
            headers
        };
        this.apiClient = J(w(configOptions));
        this.apiClient.setConfig({
            fetch: chromaFetch
        });
    }
    /**
   * Creates a new database within a tenant.
   * @param options - Database creation options
   * @param options.name - Name of the database to create
   * @param options.tenant - Tenant that will own the database
   */ async createDatabase({ name, tenant }) {
        await DefaultService.createDatabase({
            client: this.apiClient,
            path: {
                tenant
            },
            body: {
                name
            }
        });
    }
    /**
   * Retrieves information about a specific database.
   * @param options - Database retrieval options
   * @param options.name - Name of the database to retrieve
   * @param options.tenant - Tenant that owns the database
   * @returns Promise resolving to database information
   */ async getDatabase({ name, tenant }) {
        const { data } = await DefaultService.getDatabase({
            client: this.apiClient,
            path: {
                tenant,
                database: name
            }
        });
        return data;
    }
    /**
   * Deletes a database and all its data.
   * @param options - Database deletion options
   * @param options.name - Name of the database to delete
   * @param options.tenant - Tenant that owns the database
   * @warning This operation is irreversible and will delete all data
   */ async deleteDatabase({ name, tenant }) {
        await DefaultService.deleteDatabase({
            client: this.apiClient,
            path: {
                tenant,
                database: name
            }
        });
    }
    /**
   * Lists all databases within a tenant.
   * @param args - Listing parameters including tenant and pagination
   * @returns Promise resolving to an array of database information
   */ async listDatabases(args) {
        const { limit = 100, offset = 0, tenant } = args;
        const { data } = await DefaultService.listDatabases({
            client: this.apiClient,
            path: {
                tenant
            },
            query: {
                limit,
                offset
            }
        });
        return data;
    }
    /**
   * Creates a new tenant.
   * @param options - Tenant creation options
   * @param options.name - Name of the tenant to create
   */ async createTenant({ name }) {
        await DefaultService.createTenant({
            client: this.apiClient,
            body: {
                name
            }
        });
    }
    /**
   * Retrieves information about a specific tenant.
   * @param options - Tenant retrieval options
   * @param options.name - Name of the tenant to retrieve
   * @returns Promise resolving to the tenant name
   */ async getTenant({ name }) {
        const { data } = await DefaultService.getTenant({
            client: this.apiClient,
            path: {
                tenant_name: name
            }
        });
        return data.name;
    }
};
// src/chroma-client.ts
var process = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"), 1);
var resolveSchemaEmbeddingFunction = (schema)=>{
    if (!schema) {
        return void 0;
    }
    const embeddingOverride = schema.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config.embeddingFunction ?? void 0;
    if (embeddingOverride) {
        return embeddingOverride;
    }
    return schema.defaults.floatList?.vectorIndex?.config.embeddingFunction ?? void 0;
};
var ChromaClient = class {
    /**
   * Creates a new ChromaClient instance.
   * @param args - Configuration options for the client
   */ constructor(args = {}){
        let { host = defaultChromaClientArgs.host, port = defaultChromaClientArgs.port, ssl = defaultChromaClientArgs.ssl, tenant = defaultChromaClientArgs.tenant, database = defaultChromaClientArgs.database, headers = defaultChromaClientArgs.headers, fetchOptions = defaultChromaClientArgs.fetchOptions } = args;
        if (args.path) {
            console.warn("The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead");
            const parsedPath = parseConnectionPath(args.path);
            ssl = parsedPath.ssl;
            host = parsedPath.host;
            port = parsedPath.port;
        }
        if (args.auth) {
            console.warn("The 'auth' argument is deprecated. Please use 'headers' instead");
            if (!headers) {
                headers = {};
            }
            if (!headers["x-chroma-token"] && args.auth.tokenHeaderType === "X_CHROMA_TOKEN" && args.auth.credentials) {
                headers["x-chroma-token"] = args.auth.credentials;
            }
        }
        const baseUrl = `${ssl ? "https" : "http"}://${host}:${port}`;
        this._tenant = tenant || process.env.CHROMA_TENANT;
        this._database = database || process.env.CHROMA_DATABASE;
        this._headers = headers;
        const configOptions = {
            ...fetchOptions,
            method: normalizeMethod(fetchOptions?.method),
            baseUrl,
            headers
        };
        this.apiClient = J(w(configOptions));
        this.apiClient.setConfig({
            fetch: chromaFetch
        });
    }
    /**
   * Gets the current tenant name.
   * @returns The tenant name or undefined if not set
   */ get tenant() {
        return this._tenant;
    }
    set tenant(tenant) {
        this._tenant = tenant;
    }
    /**
   * Gets the current database name.
   * @returns The database name or undefined if not set
   */ get database() {
        return this._database;
    }
    set database(database) {
        this._database = database;
    }
    /**
   * Gets the preflight checks
   * @returns The preflight checks or undefined if not set
   */ get preflightChecks() {
        return this._preflightChecks;
    }
    set preflightChecks(preflightChecks) {
        this._preflightChecks = preflightChecks;
    }
    get headers() {
        return this._headers;
    }
    /** @ignore */ async _path() {
        if (!this._tenant || !this._database) {
            const { tenant, databases } = await this.getUserIdentity();
            const uniqueDBs = [
                ...new Set(databases)
            ];
            this._tenant = tenant;
            if (uniqueDBs.length === 0) {
                throw new ChromaUnauthorizedError(`Your API key does not have access to any DBs for tenant ${this.tenant}`);
            }
            if (uniqueDBs.length > 1 || uniqueDBs[0] === "*") {
                throw new ChromaValueError("Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor");
            }
            this._database = uniqueDBs[0];
        }
        return {
            tenant: this._tenant,
            database: this._database
        };
    }
    /**
   * Gets the user identity information including tenant and accessible databases.
   * @returns Promise resolving to user identity data
   */ async getUserIdentity() {
        const { data } = await DefaultService.getUserIdentity({
            client: this.apiClient
        });
        return data;
    }
    /**
   * Sends a heartbeat request to check server connectivity.
   * @returns Promise resolving to the server's nanosecond heartbeat timestamp
   */ async heartbeat() {
        const { data } = await DefaultService.heartbeat({
            client: this.apiClient
        });
        return data["nanosecond heartbeat"];
    }
    /**
   * Lists all collections in the current database.
   * @param args - Optional pagination parameters
   * @param args.limit - Maximum number of collections to return (default: 100)
   * @param args.offset - Number of collections to skip (default: 0)
   * @returns Promise resolving to an array of Collection instances
   */ async listCollections(args) {
        const { limit = 100, offset = 0 } = args || {};
        const { data } = await DefaultService.listCollections({
            client: this.apiClient,
            path: await this._path(),
            query: {
                limit,
                offset
            }
        });
        return Promise.all(data.map(async (collection)=>{
            const schema = await Schema.deserializeFromJSON(collection.schema ?? null, this);
            const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);
            const resolvedEmbeddingFunction = await getEmbeddingFunction({
                collectionName: collection.name,
                client: this,
                efConfig: collection.configuration_json.embedding_function ?? void 0
            }) ?? schemaEmbeddingFunction;
            return new CollectionImpl({
                chromaClient: this,
                apiClient: this.apiClient,
                tenant: collection.tenant,
                database: collection.database,
                name: collection.name,
                id: collection.id,
                embeddingFunction: resolvedEmbeddingFunction,
                configuration: collection.configuration_json,
                metadata: deserializeMetadata(collection.metadata ?? void 0) ?? void 0,
                schema
            });
        }));
    }
    /**
   * Gets the total number of collections in the current database.
   * @returns Promise resolving to the collection count
   */ async countCollections() {
        const { data } = await DefaultService.countCollections({
            client: this.apiClient,
            path: await this._path()
        });
        return data;
    }
    /**
   * Creates a new collection with the specified configuration.
   * @param options - Collection creation options
   * @param options.name - The name of the collection
   * @param options.configuration - Optional collection configuration
   * @param options.metadata - Optional metadata for the collection
   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed
   * @returns Promise resolving to the created Collection instance
   * @throws Error if a collection with the same name already exists
   */ async createCollection({ name, configuration, metadata, embeddingFunction, schema }) {
        const collectionConfig = await processCreateCollectionConfig({
            configuration,
            embeddingFunction,
            metadata,
            schema
        });
        const { data } = await DefaultService.createCollection({
            client: this.apiClient,
            path: await this._path(),
            body: {
                name,
                configuration: collectionConfig,
                metadata: serializeMetadata(metadata),
                get_or_create: false,
                schema: schema ? schema.serializeToJSON() : void 0
            }
        });
        const serverSchema = await Schema.deserializeFromJSON(data.schema ?? null, this);
        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(serverSchema);
        const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({
            collectionName: data.name,
            client: this,
            efConfig: data.configuration_json.embedding_function ?? void 0
        }) ?? schemaEmbeddingFunction;
        return new CollectionImpl({
            chromaClient: this,
            apiClient: this.apiClient,
            name,
            tenant: data.tenant,
            database: data.database,
            configuration: data.configuration_json,
            metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,
            embeddingFunction: resolvedEmbeddingFunction,
            id: data.id,
            schema: serverSchema
        });
    }
    /**
   * Retrieves an existing collection by name.
   * @param options - Collection retrieval options
   * @param options.name - The name of the collection to retrieve
   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.
   * @returns Promise resolving to the Collection instance
   * @throws Error if the collection does not exist
   */ async getCollection({ name, embeddingFunction }) {
        const { data } = await DefaultService.getCollection({
            client: this.apiClient,
            path: {
                ...await this._path(),
                collection_id: name
            }
        });
        const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);
        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);
        const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({
            collectionName: data.name,
            client: this,
            efConfig: data.configuration_json.embedding_function ?? void 0
        }) ?? schemaEmbeddingFunction;
        return new CollectionImpl({
            chromaClient: this,
            apiClient: this.apiClient,
            name,
            tenant: data.tenant,
            database: data.database,
            configuration: data.configuration_json,
            metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,
            embeddingFunction: resolvedEmbeddingFunction,
            id: data.id,
            schema
        });
    }
    /**
   * Retrieves an existing collection by its Chroma Resource Name (CRN).
   * @param crn - The Chroma Resource Name of the collection to retrieve
   * @returns Promise resolving to the Collection instance
   * @throws Error if the collection does not exist
   */ async getCollectionByCrn(crn) {
        const { data } = await DefaultService.getCollectionByCrn({
            client: this.apiClient,
            path: {
                crn
            }
        });
        const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);
        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);
        const resolvedEmbeddingFunction = await getEmbeddingFunction({
            collectionName: data.name,
            efConfig: data.configuration_json.embedding_function ?? void 0,
            client: this
        }) ?? schemaEmbeddingFunction;
        return new CollectionImpl({
            chromaClient: this,
            apiClient: this.apiClient,
            name: data.name,
            tenant: data.tenant,
            database: data.database,
            configuration: data.configuration_json,
            metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,
            embeddingFunction: resolvedEmbeddingFunction,
            id: data.id,
            schema
        });
    }
    /**
   * Retrieves multiple collections by name.
   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)
   * @returns Promise resolving to an array of Collection instances
   */ async getCollections(items) {
        if (items.length === 0) return [];
        let requestedCollections = items;
        if (typeof items[0] === "string") {
            requestedCollections = items.map((item)=>{
                return {
                    name: item,
                    embeddingFunction: void 0
                };
            });
        }
        let collections = requestedCollections;
        return Promise.all(collections.map(async (collection)=>{
            return this.getCollection({
                ...collection
            });
        }));
    }
    /**
   * Gets an existing collection or creates it if it doesn't exist.
   * @param options - Collection options
   * @param options.name - The name of the collection
   * @param options.configuration - Optional collection configuration (used only if creating)
   * @param options.metadata - Optional metadata for the collection (used only if creating)
   * @param options.embeddingFunction - Optional embedding function to use
   * @returns Promise resolving to the Collection instance
   */ async getOrCreateCollection({ name, configuration, metadata, embeddingFunction, schema }) {
        const collectionConfig = await processCreateCollectionConfig({
            configuration,
            embeddingFunction,
            metadata,
            schema
        });
        const { data } = await DefaultService.createCollection({
            client: this.apiClient,
            path: await this._path(),
            body: {
                name,
                configuration: collectionConfig,
                metadata: serializeMetadata(metadata),
                get_or_create: true,
                schema: schema ? schema.serializeToJSON() : void 0
            }
        });
        const serverSchema = await Schema.deserializeFromJSON(data.schema ?? null, this);
        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(serverSchema);
        const resolvedEmbeddingFunction = embeddingFunction ?? await getEmbeddingFunction({
            collectionName: name,
            efConfig: data.configuration_json.embedding_function ?? void 0,
            client: this
        }) ?? schemaEmbeddingFunction;
        return new CollectionImpl({
            chromaClient: this,
            apiClient: this.apiClient,
            name,
            tenant: data.tenant,
            database: data.database,
            configuration: data.configuration_json,
            metadata: deserializeMetadata(data.metadata ?? void 0) ?? void 0,
            embeddingFunction: resolvedEmbeddingFunction,
            id: data.id,
            schema: serverSchema
        });
    }
    /**
   * Deletes a collection and all its data.
   * @param options - Deletion options
   * @param options.name - The name of the collection to delete
   */ async deleteCollection({ name }) {
        await DefaultService.deleteCollection({
            client: this.apiClient,
            path: {
                ...await this._path(),
                collection_id: name
            }
        });
    }
    /**
   * Resets the entire database, deleting all collections and data.
   * @returns Promise that resolves when the reset is complete
   * @warning This operation is irreversible and will delete all data
   */ async reset() {
        await DefaultService.reset({
            client: this.apiClient
        });
    }
    /**
   * Gets the version of the Chroma server.
   * @returns Promise resolving to the server version string
   */ async version() {
        const { data } = await DefaultService.version({
            client: this.apiClient
        });
        return data;
    }
    /**
   * Gets the preflight checks
   * @returns Promise resolving to the preflight checks
   */ async getPreflightChecks() {
        if (!this.preflightChecks) {
            const { data } = await DefaultService.preFlightChecks({
                client: this.apiClient
            });
            this.preflightChecks = data;
            return this.preflightChecks;
        }
        return this.preflightChecks;
    }
    /**
   * Gets the max batch size
   * @returns Promise resolving to the max batch size
   */ async getMaxBatchSize() {
        const preflightChecks = await this.getPreflightChecks();
        return preflightChecks.max_batch_size ?? -1;
    }
    /**
   * Gets whether base64_encoding is supported by the connected server
   * @returns Promise resolving to whether base64_encoding is supported
   */ async supportsBase64Encoding() {
        const preflightChecks = await this.getPreflightChecks();
        return preflightChecks.supports_base64_encoding ?? false;
    }
};
// src/cloud-client.ts
var process2 = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"), 1);
var CloudClient = class extends ChromaClient {
    /**
   * Creates a new CloudClient instance for Chroma Cloud.
   * @param args - Cloud client configuration options
   */ constructor(args = {}){
        const apiKey = args.apiKey || process2.env.CHROMA_API_KEY;
        if (!apiKey) {
            throw new ChromaValueError("Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable");
        }
        const tenant = args.tenant || process2.env.CHROMA_TENANT;
        const database = args.database || process2.env.CHROMA_DATABASE;
        super({
            host: "api.trychroma.com",
            port: 8e3,
            ssl: true,
            tenant,
            database,
            headers: {
                "x-chroma-token": apiKey
            },
            fetchOptions: args.fetchOptions
        });
        this.tenant = tenant;
        this.database = database;
    }
};
var AdminCloudClient = class extends AdminClient {
    /**
   * Creates a new AdminCloudClient instance for cloud admin operations.
   * @param args - Admin cloud client configuration options
   */ constructor(args = {}){
        const apiKey = args.apiKey || process2.env.CHROMA_API_KEY;
        if (!apiKey) {
            throw new ChromaValueError("Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable");
        }
        super({
            host: "api.trychroma.com",
            port: 8e3,
            ssl: true,
            headers: {
                "x-chroma-token": apiKey
            },
            fetchOptions: args.fetchOptions
        });
    }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    Abs,
    AdminClient,
    AdminCloudClient,
    BoolInvertedIndexConfig,
    BoolInvertedIndexType,
    BoolValueType,
    ChromaClient,
    ChromaClientError,
    ChromaConnectionError,
    ChromaError,
    ChromaForbiddenError,
    ChromaNotFoundError,
    ChromaQuotaExceededError,
    ChromaRateLimitError,
    ChromaServerError,
    ChromaUnauthorizedError,
    ChromaUniqueError,
    ChromaValueError,
    CloudClient,
    DOCUMENT_KEY,
    Div,
    EMBEDDING_KEY,
    Exp,
    FloatInvertedIndexConfig,
    FloatInvertedIndexType,
    FloatListValueType,
    FloatValueType,
    FtsIndexConfig,
    FtsIndexType,
    GetResult,
    IncludeEnum,
    IntInvertedIndexConfig,
    IntInvertedIndexType,
    IntValueType,
    InvalidArgumentError,
    InvalidCollectionError,
    K,
    Key,
    Knn,
    Limit,
    Log,
    Max,
    Min,
    Mul,
    QueryResult,
    RankExpression,
    Rrf,
    Schema,
    Search,
    SearchResult,
    Select,
    SparseVectorIndexConfig,
    SparseVectorIndexType,
    SparseVectorValueType,
    StringInvertedIndexConfig,
    StringInvertedIndexType,
    StringValueType,
    Sub,
    Sum,
    Val,
    ValueTypes,
    VectorIndexConfig,
    VectorIndexType,
    WhereExpression,
    baseRecordSetFields,
    createErrorByType,
    getDefaultEFConfig,
    getEmbeddingFunction,
    getSparseEmbeddingFunction,
    knownEmbeddingFunctions,
    knownSparseEmbeddingFunctions,
    processCreateCollectionConfig,
    processUpdateCollectionConfig,
    recordSetFields,
    registerEmbeddingFunction,
    registerSparseEmbeddingFunction,
    serializeEmbeddingFunction,
    toSearch,
    withChroma
}); //# sourceMappingURL=chromadb.cjs.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/formats.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RFC3986 = exports.RFC1738 = exports.formatters = exports.default_format = void 0;
exports.default_format = 'RFC3986';
exports.formatters = {
    RFC1738: (v)=>String(v).replace(/%20/g, '+'),
    RFC3986: (v)=>String(v)
};
exports.RFC1738 = 'RFC1738';
exports.RFC3986 = 'RFC3986'; //# sourceMappingURL=formats.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.maybe_map = exports.combine = exports.is_buffer = exports.is_regexp = exports.compact = exports.encode = exports.decode = exports.assign_single_source = exports.merge = void 0;
const formats_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/formats.js [app-route] (ecmascript)");
const has = Object.prototype.hasOwnProperty;
const is_array = Array.isArray;
const hex_table = (()=>{
    const array = [];
    for(let i = 0; i < 256; ++i){
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
})();
function compact_queue(queue) {
    while(queue.length > 1){
        const item = queue.pop();
        if (!item) continue;
        const obj = item.obj[item.prop];
        if (is_array(obj)) {
            const compacted = [];
            for(let j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }
            // @ts-ignore
            item.obj[item.prop] = compacted;
        }
    }
}
function array_to_object(source, options) {
    const obj = options && options.plainObjects ? Object.create(null) : {};
    for(let i = 0; i < source.length; ++i){
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }
    return obj;
}
function merge(target, source, options = {}) {
    if (!source) {
        return target;
    }
    if (typeof source !== 'object') {
        if (is_array(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== 'object') {
        return [
            target
        ].concat(source);
    }
    let mergeTarget = target;
    if (is_array(target) && !is_array(source)) {
        // @ts-ignore
        mergeTarget = array_to_object(target, options);
    }
    if (is_array(target) && is_array(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                const targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        const value = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
}
exports.merge = merge;
function assign_single_source(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
}
exports.assign_single_source = assign_single_source;
function decode(str, _, charset) {
    const strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
}
exports.decode = decode;
const limit = 1024;
const encode = (str, _defaultEncoder, charset, _kind, format)=>{
    // This code was originally written by Brian White for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }
    let string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }
    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }
    let out = '';
    for(let j = 0; j < string.length; j += limit){
        const segment = string.length >= limit ? string.slice(j, j + limit) : string;
        const arr = [];
        for(let i = 0; i < segment.length; ++i){
            let c = segment.charCodeAt(i);
            if (c === 0x2d || // -
            c === 0x2e || // .
            c === 0x5f || // _
            c === 0x7e || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c >= 0x61 && c <= 0x7a || format === formats_1.RFC1738 && (c === 0x28 || c === 0x29) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }
            if (c < 0x80) {
                arr[arr.length] = hex_table[c];
                continue;
            }
            if (c < 0x800) {
                arr[arr.length] = hex_table[0xc0 | c >> 6] + hex_table[0x80 | c & 0x3f];
                continue;
            }
            if (c < 0xd800 || c >= 0xe000) {
                arr[arr.length] = hex_table[0xe0 | c >> 12] + hex_table[0x80 | c >> 6 & 0x3f] + hex_table[0x80 | c & 0x3f];
                continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3ff) << 10 | segment.charCodeAt(i) & 0x3ff);
            arr[arr.length] = hex_table[0xf0 | c >> 18] + hex_table[0x80 | c >> 12 & 0x3f] + hex_table[0x80 | c >> 6 & 0x3f] + hex_table[0x80 | c & 0x3f];
        }
        out += arr.join('');
    }
    return out;
};
exports.encode = encode;
function compact(value) {
    const queue = [
        {
            obj: {
                o: value
            },
            prop: 'o'
        }
    ];
    const refs = [];
    for(let i = 0; i < queue.length; ++i){
        const item = queue[i];
        // @ts-ignore
        const obj = item.obj[item.prop];
        const keys = Object.keys(obj);
        for(let j = 0; j < keys.length; ++j){
            const key = keys[j];
            const val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compact_queue(queue);
    return value;
}
exports.compact = compact;
function is_regexp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
}
exports.is_regexp = is_regexp;
function is_buffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
exports.is_buffer = is_buffer;
function combine(a, b) {
    return [].concat(a, b);
}
exports.combine = combine;
function maybe_map(val, fn) {
    if (is_array(val)) {
        const mapped = [];
        for(let i = 0; i < val.length; i += 1){
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
}
exports.maybe_map = maybe_map; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/stringify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringify = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/utils.js [app-route] (ecmascript)");
const formats_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/formats.js [app-route] (ecmascript)");
const has = Object.prototype.hasOwnProperty;
const array_prefix_generators = {
    brackets (prefix) {
        return String(prefix) + '[]';
    },
    comma: 'comma',
    indices (prefix, key) {
        return String(prefix) + '[' + key + ']';
    },
    repeat (prefix) {
        return String(prefix);
    }
};
const is_array = Array.isArray;
const push = Array.prototype.push;
const push_to_array = function(arr, value_or_array) {
    push.apply(arr, is_array(value_or_array) ? value_or_array : [
        value_or_array
    ]);
};
const to_ISO = Date.prototype.toISOString;
const defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils_1.encode,
    encodeValuesOnly: false,
    format: formats_1.default_format,
    formatter: formats_1.formatters[formats_1.default_format],
    /** @deprecated */ indices: false,
    serializeDate (date) {
        return to_ISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};
function is_non_nullish_primitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
}
const sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    let obj = object;
    let tmp_sc = sideChannel;
    let step = 0;
    let find_flag = false;
    while((tmp_sc = tmp_sc.get(sentinel)) !== void undefined && !find_flag){
        // Where object last appeared in the ref tree
        const pos = tmp_sc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                find_flag = true; // Break while
            }
        }
        if (typeof tmp_sc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate?.(obj);
    } else if (generateArrayPrefix === 'comma' && is_array(obj)) {
        obj = (0, utils_1.maybe_map)(obj, function(value) {
            if (value instanceof Date) {
                return serializeDate?.(value);
            }
            return value;
        });
    }
    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? // @ts-expect-error
            encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }
        obj = '';
    }
    if (is_non_nullish_primitive(obj) || (0, utils_1.is_buffer)(obj)) {
        if (encoder) {
            const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [
                formatter?.(key_value) + '=' + // @ts-expect-error
                formatter?.(encoder(obj, defaults.encoder, charset, 'value', format))
            ];
        }
        return [
            formatter?.(prefix) + '=' + formatter?.(String(obj))
        ];
    }
    const values = [];
    if (typeof obj === 'undefined') {
        return values;
    }
    let obj_keys;
    if (generateArrayPrefix === 'comma' && is_array(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            // @ts-expect-error values only
            obj = (0, utils_1.maybe_map)(obj, encoder);
        }
        obj_keys = [
            {
                value: obj.length > 0 ? obj.join(',') || null : void undefined
            }
        ];
    } else if (is_array(filter)) {
        obj_keys = filter;
    } else {
        const keys = Object.keys(obj);
        obj_keys = sort ? keys.sort(sort) : keys;
    }
    const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);
    const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + '[]' : encoded_prefix;
    if (allowEmptyArrays && is_array(obj) && obj.length === 0) {
        return adjusted_prefix + '[]';
    }
    for(let j = 0; j < obj_keys.length; ++j){
        const key = obj_keys[j];
        const value = // @ts-ignore
        typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];
        if (skipNulls && value === null) {
            continue;
        }
        // @ts-ignore
        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        const key_prefix = is_array(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? '.' + encoded_key : '[' + encoded_key + ']');
        sideChannel.set(object, step);
        const valueSideChannel = new WeakMap();
        valueSideChannel.set(sentinel, sideChannel);
        push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, // @ts-ignore
        generateArrayPrefix === 'comma' && encodeValuesOnly && is_array(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
}
function normalize_stringify_options(opts = defaults) {
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }
    const charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    let format = formats_1.default_format;
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats_1.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    const formatter = formats_1.formatters[format];
    let filter = defaults.filter;
    if (typeof opts.filter === 'function' || is_array(opts.filter)) {
        filter = opts.filter;
    }
    let arrayFormat;
    if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    const allowDots = typeof opts.allowDots === 'undefined' ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        // @ts-ignore
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        // @ts-ignore
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
}
function stringify(object, opts = {}) {
    let obj = object;
    const options = normalize_stringify_options(opts);
    let obj_keys;
    let filter;
    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (is_array(options.filter)) {
        filter = options.filter;
        obj_keys = filter;
    }
    const keys = [];
    if (typeof obj !== 'object' || obj === null) {
        return '';
    }
    const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
    const commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!obj_keys) {
        obj_keys = Object.keys(obj);
    }
    if (options.sort) {
        obj_keys.sort(options.sort);
    }
    const sideChannel = new WeakMap();
    for(let i = 0; i < obj_keys.length; ++i){
        const key = obj_keys[i];
        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        push_to_array(keys, inner_stringify(obj[key], key, // @ts-expect-error
        generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    const joined = keys.join(options.delimiter);
    let prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }
    return joined.length > 0 ? prefix + joined : '';
}
exports.stringify = stringify; //# sourceMappingURL=stringify.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formats = exports.stringify = void 0;
const formats_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/formats.js [app-route] (ecmascript)");
const formats = {
    formatters: formats_1.formatters,
    RFC1738: formats_1.RFC1738,
    RFC3986: formats_1.RFC3986,
    default: formats_1.default_format
};
exports.formats = formats;
var stringify_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/stringify.js [app-route] (ecmascript)");
Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
        return stringify_1.stringify;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VERSION = void 0;
exports.VERSION = '4.104.0'; // x-release-please-version
 //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/registry.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setShims = exports.isFsReadStream = exports.fileFromPath = exports.getDefaultAgent = exports.getMultipartRequestOptions = exports.ReadableStream = exports.File = exports.Blob = exports.FormData = exports.Headers = exports.Response = exports.Request = exports.fetch = exports.kind = exports.auto = void 0;
exports.auto = false;
exports.kind = undefined;
exports.fetch = undefined;
exports.Request = undefined;
exports.Response = undefined;
exports.Headers = undefined;
exports.FormData = undefined;
exports.Blob = undefined;
exports.File = undefined;
exports.ReadableStream = undefined;
exports.getMultipartRequestOptions = undefined;
exports.getDefaultAgent = undefined;
exports.fileFromPath = undefined;
exports.isFsReadStream = undefined;
function setShims(shims, options = {
    auto: false
}) {
    if (exports.auto) {
        throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
    }
    if (exports.kind) {
        throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${exports.kind}'\``);
    }
    exports.auto = options.auto;
    exports.kind = shims.kind;
    exports.fetch = shims.fetch;
    exports.Request = shims.Request;
    exports.Response = shims.Response;
    exports.Headers = shims.Headers;
    exports.FormData = shims.FormData;
    exports.Blob = shims.Blob;
    exports.File = shims.File;
    exports.ReadableStream = shims.ReadableStream;
    exports.getMultipartRequestOptions = shims.getMultipartRequestOptions;
    exports.getDefaultAgent = shims.getDefaultAgent;
    exports.fileFromPath = shims.fileFromPath;
    exports.isFsReadStream = shims.isFsReadStream;
}
exports.setShims = setShims; //# sourceMappingURL=registry.js.map
}),
"[project]/node_modules/web-streams-polyfill/dist/ponyfill.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * @license
 * web-streams-polyfill v4.0.0-beta.3
 * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */ !function(e, t) {
    ("TURBOPACK compile-time truthy", 1) ? t(exports) : "TURBOPACK unreachable";
}(/*TURBOPACK member replacement*/ __turbopack_context__.e, function(e) {
    "use strict";
    const t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : (e)=>`Symbol(${e})`;
    function r() {}
    function o(e) {
        return "object" == typeof e && null !== e || "function" == typeof e;
    }
    const n = r;
    function a(e, t) {
        try {
            Object.defineProperty(e, "name", {
                value: t,
                configurable: !0
            });
        } catch (e) {}
    }
    const i = Promise, l = Promise.prototype.then, s = Promise.resolve.bind(i), u = Promise.reject.bind(i);
    function c(e) {
        return new i(e);
    }
    function d(e) {
        return s(e);
    }
    function f(e) {
        return u(e);
    }
    function b(e, t, r) {
        return l.call(e, t, r);
    }
    function h(e, t, r) {
        b(b(e, t, r), void 0, n);
    }
    function _(e, t) {
        h(e, t);
    }
    function p(e, t) {
        h(e, void 0, t);
    }
    function m(e, t, r) {
        return b(e, t, r);
    }
    function y(e) {
        b(e, void 0, n);
    }
    let g = (e)=>{
        if ("function" == typeof queueMicrotask) g = queueMicrotask;
        else {
            const e = d(void 0);
            g = (t)=>b(e, t);
        }
        return g(e);
    };
    function S(e, t, r) {
        if ("function" != typeof e) throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(e, t, r);
    }
    function w(e, t, r) {
        try {
            return d(S(e, t, r));
        } catch (e) {
            return f(e);
        }
    }
    class v {
        constructor(){
            this._cursor = 0, this._size = 0, this._front = {
                _elements: [],
                _next: void 0
            }, this._back = this._front, this._cursor = 0, this._size = 0;
        }
        get length() {
            return this._size;
        }
        push(e) {
            const t = this._back;
            let r = t;
            16383 === t._elements.length && (r = {
                _elements: [],
                _next: void 0
            }), t._elements.push(e), r !== t && (this._back = r, t._next = r), ++this._size;
        }
        shift() {
            const e = this._front;
            let t = e;
            const r = this._cursor;
            let o = r + 1;
            const n = e._elements, a = n[r];
            return 16384 === o && (t = e._next, o = 0), --this._size, this._cursor = o, e !== t && (this._front = t), n[r] = void 0, a;
        }
        forEach(e) {
            let t = this._cursor, r = this._front, o = r._elements;
            for(; !(t === o.length && void 0 === r._next || t === o.length && (r = r._next, o = r._elements, t = 0, 0 === o.length));)e(o[t]), ++t;
        }
        peek() {
            const e = this._front, t = this._cursor;
            return e._elements[t];
        }
    }
    const R = t("[[AbortSteps]]"), T = t("[[ErrorSteps]]"), q = t("[[CancelSteps]]"), C = t("[[PullSteps]]"), P = t("[[ReleaseSteps]]");
    function E(e, t) {
        e._ownerReadableStream = t, t._reader = e, "readable" === t._state ? B(e) : "closed" === t._state ? function(e) {
            B(e), z(e);
        }(e) : A(e, t._storedError);
    }
    function W(e, t) {
        return Xt(e._ownerReadableStream, t);
    }
    function O(e) {
        const t = e._ownerReadableStream;
        "readable" === t._state ? j(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e, t) {
            A(e, t);
        }(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t._readableStreamController[P](), t._reader = void 0, e._ownerReadableStream = void 0;
    }
    function k(e) {
        return new TypeError("Cannot " + e + " a stream using a released reader");
    }
    function B(e) {
        e._closedPromise = c((t, r)=>{
            e._closedPromise_resolve = t, e._closedPromise_reject = r;
        });
    }
    function A(e, t) {
        B(e), j(e, t);
    }
    function j(e, t) {
        void 0 !== e._closedPromise_reject && (y(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);
    }
    function z(e) {
        void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);
    }
    const L = Number.isFinite || function(e) {
        return "number" == typeof e && isFinite(e);
    }, F = Math.trunc || function(e) {
        return e < 0 ? Math.ceil(e) : Math.floor(e);
    };
    function D(e, t) {
        if (void 0 !== e && "object" != typeof (r = e) && "function" != typeof r) throw new TypeError(`${t} is not an object.`);
        var r;
    }
    function I(e, t) {
        if ("function" != typeof e) throw new TypeError(`${t} is not a function.`);
    }
    function $(e, t) {
        if (!function(e) {
            return "object" == typeof e && null !== e || "function" == typeof e;
        }(e)) throw new TypeError(`${t} is not an object.`);
    }
    function M(e, t, r) {
        if (void 0 === e) throw new TypeError(`Parameter ${t} is required in '${r}'.`);
    }
    function Y(e, t, r) {
        if (void 0 === e) throw new TypeError(`${t} is required in '${r}'.`);
    }
    function Q(e) {
        return Number(e);
    }
    function N(e) {
        return 0 === e ? 0 : e;
    }
    function x(e, t) {
        const r = Number.MAX_SAFE_INTEGER;
        let o = Number(e);
        if (o = N(o), !L(o)) throw new TypeError(`${t} is not a finite number`);
        if (o = function(e) {
            return N(F(e));
        }(o), o < 0 || o > r) throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);
        return L(o) && 0 !== o ? o : 0;
    }
    function H(e) {
        if (!o(e)) return !1;
        if ("function" != typeof e.getReader) return !1;
        try {
            return "boolean" == typeof e.locked;
        } catch (e) {
            return !1;
        }
    }
    function V(e) {
        if (!o(e)) return !1;
        if ("function" != typeof e.getWriter) return !1;
        try {
            return "boolean" == typeof e.locked;
        } catch (e) {
            return !1;
        }
    }
    function U(e, t) {
        if (!Ut(e)) throw new TypeError(`${t} is not a ReadableStream.`);
    }
    function G(e, t) {
        e._reader._readRequests.push(t);
    }
    function X(e, t, r) {
        const o = e._reader._readRequests.shift();
        r ? o._closeSteps() : o._chunkSteps(t);
    }
    function J(e) {
        return e._reader._readRequests.length;
    }
    function K(e) {
        const t = e._reader;
        return void 0 !== t && !!Z(t);
    }
    class ReadableStreamDefaultReader {
        constructor(e){
            if (M(e, 1, "ReadableStreamDefaultReader"), U(e, "First parameter"), Gt(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            E(this, e), this._readRequests = new v;
        }
        get closed() {
            return Z(this) ? this._closedPromise : f(te("closed"));
        }
        cancel(e) {
            return Z(this) ? void 0 === this._ownerReadableStream ? f(k("cancel")) : W(this, e) : f(te("cancel"));
        }
        read() {
            if (!Z(this)) return f(te("read"));
            if (void 0 === this._ownerReadableStream) return f(k("read from"));
            let e, t;
            const r = c((r, o)=>{
                e = r, t = o;
            });
            return function(e, t) {
                const r = e._ownerReadableStream;
                r._disturbed = !0, "closed" === r._state ? t._closeSteps() : "errored" === r._state ? t._errorSteps(r._storedError) : r._readableStreamController[C](t);
            }(this, {
                _chunkSteps: (t)=>e({
                        value: t,
                        done: !1
                    }),
                _closeSteps: ()=>e({
                        value: void 0,
                        done: !0
                    }),
                _errorSteps: (e)=>t(e)
            }), r;
        }
        releaseLock() {
            if (!Z(this)) throw te("releaseLock");
            void 0 !== this._ownerReadableStream && function(e) {
                O(e);
                const t = new TypeError("Reader was released");
                ee(e, t);
            }(this);
        }
    }
    function Z(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_readRequests") && e instanceof ReadableStreamDefaultReader;
    }
    function ee(e, t) {
        const r = e._readRequests;
        e._readRequests = new v, r.forEach((e)=>{
            e._errorSteps(t);
        });
    }
    function te(e) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`);
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: {
            enumerable: !0
        },
        read: {
            enumerable: !0
        },
        releaseLock: {
            enumerable: !0
        },
        closed: {
            enumerable: !0
        }
    }), a(ReadableStreamDefaultReader.prototype.cancel, "cancel"), a(ReadableStreamDefaultReader.prototype.read, "read"), a(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, t.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
    });
    class re {
        constructor(e, t){
            this._ongoingPromise = void 0, this._isFinished = !1, this._reader = e, this._preventCancel = t;
        }
        next() {
            const e = ()=>this._nextSteps();
            return this._ongoingPromise = this._ongoingPromise ? m(this._ongoingPromise, e, e) : e(), this._ongoingPromise;
        }
        return(e) {
            const t = ()=>this._returnSteps(e);
            return this._ongoingPromise ? m(this._ongoingPromise, t, t) : t();
        }
        _nextSteps() {
            if (this._isFinished) return Promise.resolve({
                value: void 0,
                done: !0
            });
            const e = this._reader;
            return void 0 === e ? f(k("iterate")) : b(e.read(), (e)=>{
                var t;
                return this._ongoingPromise = void 0, e.done && (this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0), e;
            }, (e)=>{
                var t;
                throw this._ongoingPromise = void 0, this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0, e;
            });
        }
        _returnSteps(e) {
            if (this._isFinished) return Promise.resolve({
                value: e,
                done: !0
            });
            this._isFinished = !0;
            const t = this._reader;
            if (void 0 === t) return f(k("finish iterating"));
            if (this._reader = void 0, !this._preventCancel) {
                const r = t.cancel(e);
                return t.releaseLock(), m(r, ()=>({
                        value: e,
                        done: !0
                    }));
            }
            return t.releaseLock(), d({
                value: e,
                done: !0
            });
        }
    }
    const oe = {
        next () {
            return ne(this) ? this._asyncIteratorImpl.next() : f(ae("next"));
        },
        return (e) {
            return ne(this) ? this._asyncIteratorImpl.return(e) : f(ae("return"));
        }
    };
    function ne(e) {
        if (!o(e)) return !1;
        if (!Object.prototype.hasOwnProperty.call(e, "_asyncIteratorImpl")) return !1;
        try {
            return e._asyncIteratorImpl instanceof re;
        } catch (e) {
            return !1;
        }
    }
    function ae(e) {
        return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`);
    }
    "symbol" == typeof t.asyncIterator && Object.defineProperty(oe, t.asyncIterator, {
        value () {
            return this;
        },
        writable: !0,
        configurable: !0
    });
    const ie = Number.isNaN || function(e) {
        return e != e;
    };
    function le(e, t, r, o, n) {
        new Uint8Array(e).set(new Uint8Array(r, o, n), t);
    }
    function se(e) {
        const t = function(e, t, r) {
            if (e.slice) return e.slice(t, r);
            const o = r - t, n = new ArrayBuffer(o);
            return le(n, 0, e, t, o), n;
        }(e.buffer, e.byteOffset, e.byteOffset + e.byteLength);
        return new Uint8Array(t);
    }
    function ue(e) {
        const t = e._queue.shift();
        return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value;
    }
    function ce(e, t, r) {
        if ("number" != typeof (o = r) || ie(o) || o < 0 || r === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        var o;
        e._queue.push({
            value: t,
            size: r
        }), e._queueTotalSize += r;
    }
    function de(e) {
        e._queue = new v, e._queueTotalSize = 0;
    }
    class ReadableStreamBYOBRequest {
        constructor(){
            throw new TypeError("Illegal constructor");
        }
        get view() {
            if (!be(this)) throw Ae("view");
            return this._view;
        }
        respond(e) {
            if (!be(this)) throw Ae("respond");
            if (M(e, 1, "respond"), e = x(e, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
            this._view.buffer, function(e, t) {
                const r = e._pendingPullIntos.peek();
                if ("closed" === e._controlledReadableByteStream._state) {
                    if (0 !== t) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
                } else {
                    if (0 === t) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
                    if (r.bytesFilled + t > r.byteLength) throw new RangeError("bytesWritten out of range");
                }
                r.buffer = r.buffer, Ce(e, t);
            }(this._associatedReadableByteStreamController, e);
        }
        respondWithNewView(e) {
            if (!be(this)) throw Ae("respondWithNewView");
            if (M(e, 1, "respondWithNewView"), !ArrayBuffer.isView(e)) throw new TypeError("You can only respond with array buffer views");
            if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
            e.buffer, function(e, t) {
                const r = e._pendingPullIntos.peek();
                if ("closed" === e._controlledReadableByteStream._state) {
                    if (0 !== t.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
                } else if (0 === t.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
                if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
                if (r.bufferByteLength !== t.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
                if (r.bytesFilled + t.byteLength > r.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
                const o = t.byteLength;
                r.buffer = t.buffer, Ce(e, o);
            }(this._associatedReadableByteStreamController, e);
        }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: {
            enumerable: !0
        },
        respondWithNewView: {
            enumerable: !0
        },
        view: {
            enumerable: !0
        }
    }), a(ReadableStreamBYOBRequest.prototype.respond, "respond"), a(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, t.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
    });
    class ReadableByteStreamController {
        constructor(){
            throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
            if (!fe(this)) throw je("byobRequest");
            return function(e) {
                if (null === e._byobRequest && e._pendingPullIntos.length > 0) {
                    const t = e._pendingPullIntos.peek(), r = new Uint8Array(t.buffer, t.byteOffset + t.bytesFilled, t.byteLength - t.bytesFilled), o = Object.create(ReadableStreamBYOBRequest.prototype);
                    !function(e, t, r) {
                        e._associatedReadableByteStreamController = t, e._view = r;
                    }(o, e, r), e._byobRequest = o;
                }
                return e._byobRequest;
            }(this);
        }
        get desiredSize() {
            if (!fe(this)) throw je("desiredSize");
            return ke(this);
        }
        close() {
            if (!fe(this)) throw je("close");
            if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
            const e = this._controlledReadableByteStream._state;
            if ("readable" !== e) throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);
            !function(e) {
                const t = e._controlledReadableByteStream;
                if (e._closeRequested || "readable" !== t._state) return;
                if (e._queueTotalSize > 0) return void (e._closeRequested = !0);
                if (e._pendingPullIntos.length > 0) {
                    if (e._pendingPullIntos.peek().bytesFilled > 0) {
                        const t = new TypeError("Insufficient bytes to fill elements in the given buffer");
                        throw We(e, t), t;
                    }
                }
                Ee(e), Jt(t);
            }(this);
        }
        enqueue(e) {
            if (!fe(this)) throw je("enqueue");
            if (M(e, 1, "enqueue"), !ArrayBuffer.isView(e)) throw new TypeError("chunk must be an array buffer view");
            if (0 === e.byteLength) throw new TypeError("chunk must have non-zero byteLength");
            if (0 === e.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested) throw new TypeError("stream is closed or draining");
            const t = this._controlledReadableByteStream._state;
            if ("readable" !== t) throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);
            !function(e, t) {
                const r = e._controlledReadableByteStream;
                if (e._closeRequested || "readable" !== r._state) return;
                const o = t.buffer, n = t.byteOffset, a = t.byteLength, i = o;
                if (e._pendingPullIntos.length > 0) {
                    const t = e._pendingPullIntos.peek();
                    t.buffer, Te(e), t.buffer = t.buffer, "none" === t.readerType && Se(e, t);
                }
                if (K(r)) if (function(e) {
                    const t = e._controlledReadableByteStream._reader;
                    for(; t._readRequests.length > 0;){
                        if (0 === e._queueTotalSize) return;
                        Oe(e, t._readRequests.shift());
                    }
                }(e), 0 === J(r)) ye(e, i, n, a);
                else {
                    e._pendingPullIntos.length > 0 && Pe(e);
                    X(r, new Uint8Array(i, n, a), !1);
                }
                else Fe(r) ? (ye(e, i, n, a), qe(e)) : ye(e, i, n, a);
                he(e);
            }(this, e);
        }
        error(e) {
            if (!fe(this)) throw je("error");
            We(this, e);
        }
        [q](e) {
            _e(this), de(this);
            const t = this._cancelAlgorithm(e);
            return Ee(this), t;
        }
        [C](e) {
            const t = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) return void Oe(this, e);
            const r = this._autoAllocateChunkSize;
            if (void 0 !== r) {
                let t;
                try {
                    t = new ArrayBuffer(r);
                } catch (t) {
                    return void e._errorSteps(t);
                }
                const o = {
                    buffer: t,
                    bufferByteLength: r,
                    byteOffset: 0,
                    byteLength: r,
                    bytesFilled: 0,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: "default"
                };
                this._pendingPullIntos.push(o);
            }
            G(t, e), he(this);
        }
        [P]() {
            if (this._pendingPullIntos.length > 0) {
                const e = this._pendingPullIntos.peek();
                e.readerType = "none", this._pendingPullIntos = new v, this._pendingPullIntos.push(e);
            }
        }
    }
    function fe(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream") && e instanceof ReadableByteStreamController;
    }
    function be(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_associatedReadableByteStreamController") && e instanceof ReadableStreamBYOBRequest;
    }
    function he(e) {
        const t = function(e) {
            const t = e._controlledReadableByteStream;
            if ("readable" !== t._state) return !1;
            if (e._closeRequested) return !1;
            if (!e._started) return !1;
            if (K(t) && J(t) > 0) return !0;
            if (Fe(t) && Le(t) > 0) return !0;
            if (ke(e) > 0) return !0;
            return !1;
        }(e);
        if (!t) return;
        if (e._pulling) return void (e._pullAgain = !0);
        e._pulling = !0;
        h(e._pullAlgorithm(), ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, he(e)), null), (t)=>(We(e, t), null));
    }
    function _e(e) {
        Te(e), e._pendingPullIntos = new v;
    }
    function pe(e, t) {
        let r = !1;
        "closed" === e._state && (r = !0);
        const o = me(t);
        "default" === t.readerType ? X(e, o, r) : function(e, t, r) {
            const o = e._reader._readIntoRequests.shift();
            r ? o._closeSteps(t) : o._chunkSteps(t);
        }(e, o, r);
    }
    function me(e) {
        const t = e.bytesFilled, r = e.elementSize;
        return new e.viewConstructor(e.buffer, e.byteOffset, t / r);
    }
    function ye(e, t, r, o) {
        e._queue.push({
            buffer: t,
            byteOffset: r,
            byteLength: o
        }), e._queueTotalSize += o;
    }
    function ge(e, t, r, o) {
        let n;
        try {
            n = t.slice(r, r + o);
        } catch (t) {
            throw We(e, t), t;
        }
        ye(e, n, 0, o);
    }
    function Se(e, t) {
        t.bytesFilled > 0 && ge(e, t.buffer, t.byteOffset, t.bytesFilled), Pe(e);
    }
    function we(e, t) {
        const r = t.elementSize, o = t.bytesFilled - t.bytesFilled % r, n = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled), a = t.bytesFilled + n, i = a - a % r;
        let l = n, s = !1;
        i > o && (l = i - t.bytesFilled, s = !0);
        const u = e._queue;
        for(; l > 0;){
            const r = u.peek(), o = Math.min(l, r.byteLength), n = t.byteOffset + t.bytesFilled;
            le(t.buffer, n, r.buffer, r.byteOffset, o), r.byteLength === o ? u.shift() : (r.byteOffset += o, r.byteLength -= o), e._queueTotalSize -= o, ve(e, o, t), l -= o;
        }
        return s;
    }
    function ve(e, t, r) {
        r.bytesFilled += t;
    }
    function Re(e) {
        0 === e._queueTotalSize && e._closeRequested ? (Ee(e), Jt(e._controlledReadableByteStream)) : he(e);
    }
    function Te(e) {
        null !== e._byobRequest && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = null, e._byobRequest = null);
    }
    function qe(e) {
        for(; e._pendingPullIntos.length > 0;){
            if (0 === e._queueTotalSize) return;
            const t = e._pendingPullIntos.peek();
            we(e, t) && (Pe(e), pe(e._controlledReadableByteStream, t));
        }
    }
    function Ce(e, t) {
        const r = e._pendingPullIntos.peek();
        Te(e);
        "closed" === e._controlledReadableByteStream._state ? function(e, t) {
            "none" === t.readerType && Pe(e);
            const r = e._controlledReadableByteStream;
            if (Fe(r)) for(; Le(r) > 0;)pe(r, Pe(e));
        }(e, r) : function(e, t, r) {
            if (ve(0, t, r), "none" === r.readerType) return Se(e, r), void qe(e);
            if (r.bytesFilled < r.elementSize) return;
            Pe(e);
            const o = r.bytesFilled % r.elementSize;
            if (o > 0) {
                const t = r.byteOffset + r.bytesFilled;
                ge(e, r.buffer, t - o, o);
            }
            r.bytesFilled -= o, pe(e._controlledReadableByteStream, r), qe(e);
        }(e, t, r), he(e);
    }
    function Pe(e) {
        return e._pendingPullIntos.shift();
    }
    function Ee(e) {
        e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0;
    }
    function We(e, t) {
        const r = e._controlledReadableByteStream;
        "readable" === r._state && (_e(e), de(e), Ee(e), Kt(r, t));
    }
    function Oe(e, t) {
        const r = e._queue.shift();
        e._queueTotalSize -= r.byteLength, Re(e);
        const o = new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
        t._chunkSteps(o);
    }
    function ke(e) {
        const t = e._controlledReadableByteStream._state;
        return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize;
    }
    function Be(e, t, r) {
        const o = Object.create(ReadableByteStreamController.prototype);
        let n, a, i;
        n = void 0 !== t.start ? ()=>t.start(o) : ()=>{}, a = void 0 !== t.pull ? ()=>t.pull(o) : ()=>d(void 0), i = void 0 !== t.cancel ? (e)=>t.cancel(e) : ()=>d(void 0);
        const l = t.autoAllocateChunkSize;
        if (0 === l) throw new TypeError("autoAllocateChunkSize must be greater than 0");
        !function(e, t, r, o, n, a, i) {
            t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, t._byobRequest = null, t._queue = t._queueTotalSize = void 0, de(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, t._autoAllocateChunkSize = i, t._pendingPullIntos = new v, e._readableStreamController = t, h(d(r()), ()=>(t._started = !0, he(t), null), (e)=>(We(t, e), null));
        }(e, o, n, a, i, r, l);
    }
    function Ae(e) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`);
    }
    function je(e) {
        return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`);
    }
    function ze(e, t) {
        e._reader._readIntoRequests.push(t);
    }
    function Le(e) {
        return e._reader._readIntoRequests.length;
    }
    function Fe(e) {
        const t = e._reader;
        return void 0 !== t && !!De(t);
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: {
            enumerable: !0
        },
        enqueue: {
            enumerable: !0
        },
        error: {
            enumerable: !0
        },
        byobRequest: {
            enumerable: !0
        },
        desiredSize: {
            enumerable: !0
        }
    }), a(ReadableByteStreamController.prototype.close, "close"), a(ReadableByteStreamController.prototype.enqueue, "enqueue"), a(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, t.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
    });
    class ReadableStreamBYOBReader {
        constructor(e){
            if (M(e, 1, "ReadableStreamBYOBReader"), U(e, "First parameter"), Gt(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!fe(e._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            E(this, e), this._readIntoRequests = new v;
        }
        get closed() {
            return De(this) ? this._closedPromise : f($e("closed"));
        }
        cancel(e) {
            return De(this) ? void 0 === this._ownerReadableStream ? f(k("cancel")) : W(this, e) : f($e("cancel"));
        }
        read(e) {
            if (!De(this)) return f($e("read"));
            if (!ArrayBuffer.isView(e)) return f(new TypeError("view must be an array buffer view"));
            if (0 === e.byteLength) return f(new TypeError("view must have non-zero byteLength"));
            if (0 === e.buffer.byteLength) return f(new TypeError("view's buffer must have non-zero byteLength"));
            if (e.buffer, void 0 === this._ownerReadableStream) return f(k("read from"));
            let t, r;
            const o = c((e, o)=>{
                t = e, r = o;
            });
            return function(e, t, r) {
                const o = e._ownerReadableStream;
                o._disturbed = !0, "errored" === o._state ? r._errorSteps(o._storedError) : function(e, t, r) {
                    const o = e._controlledReadableByteStream;
                    let n = 1;
                    t.constructor !== DataView && (n = t.constructor.BYTES_PER_ELEMENT);
                    const a = t.constructor, i = t.buffer, l = {
                        buffer: i,
                        bufferByteLength: i.byteLength,
                        byteOffset: t.byteOffset,
                        byteLength: t.byteLength,
                        bytesFilled: 0,
                        elementSize: n,
                        viewConstructor: a,
                        readerType: "byob"
                    };
                    if (e._pendingPullIntos.length > 0) return e._pendingPullIntos.push(l), void ze(o, r);
                    if ("closed" !== o._state) {
                        if (e._queueTotalSize > 0) {
                            if (we(e, l)) {
                                const t = me(l);
                                return Re(e), void r._chunkSteps(t);
                            }
                            if (e._closeRequested) {
                                const t = new TypeError("Insufficient bytes to fill elements in the given buffer");
                                return We(e, t), void r._errorSteps(t);
                            }
                        }
                        e._pendingPullIntos.push(l), ze(o, r), he(e);
                    } else {
                        const e = new a(l.buffer, l.byteOffset, 0);
                        r._closeSteps(e);
                    }
                }(o._readableStreamController, t, r);
            }(this, e, {
                _chunkSteps: (e)=>t({
                        value: e,
                        done: !1
                    }),
                _closeSteps: (e)=>t({
                        value: e,
                        done: !0
                    }),
                _errorSteps: (e)=>r(e)
            }), o;
        }
        releaseLock() {
            if (!De(this)) throw $e("releaseLock");
            void 0 !== this._ownerReadableStream && function(e) {
                O(e);
                const t = new TypeError("Reader was released");
                Ie(e, t);
            }(this);
        }
    }
    function De(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") && e instanceof ReadableStreamBYOBReader;
    }
    function Ie(e, t) {
        const r = e._readIntoRequests;
        e._readIntoRequests = new v, r.forEach((e)=>{
            e._errorSteps(t);
        });
    }
    function $e(e) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`);
    }
    function Me(e, t) {
        const { highWaterMark: r } = e;
        if (void 0 === r) return t;
        if (ie(r) || r < 0) throw new RangeError("Invalid highWaterMark");
        return r;
    }
    function Ye(e) {
        const { size: t } = e;
        return t || (()=>1);
    }
    function Qe(e, t) {
        D(e, t);
        const r = null == e ? void 0 : e.highWaterMark, o = null == e ? void 0 : e.size;
        return {
            highWaterMark: void 0 === r ? void 0 : Q(r),
            size: void 0 === o ? void 0 : Ne(o, `${t} has member 'size' that`)
        };
    }
    function Ne(e, t) {
        return I(e, t), (t)=>Q(e(t));
    }
    function xe(e, t, r) {
        return I(e, r), (r)=>w(e, t, [
                r
            ]);
    }
    function He(e, t, r) {
        return I(e, r), ()=>w(e, t, []);
    }
    function Ve(e, t, r) {
        return I(e, r), (r)=>S(e, t, [
                r
            ]);
    }
    function Ue(e, t, r) {
        return I(e, r), (r, o)=>w(e, t, [
                r,
                o
            ]);
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: {
            enumerable: !0
        },
        read: {
            enumerable: !0
        },
        releaseLock: {
            enumerable: !0
        },
        closed: {
            enumerable: !0
        }
    }), a(ReadableStreamBYOBReader.prototype.cancel, "cancel"), a(ReadableStreamBYOBReader.prototype.read, "read"), a(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, t.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
    });
    const Ge = "function" == typeof AbortController;
    class WritableStream {
        constructor(e = {}, t = {}){
            void 0 === e ? e = null : $(e, "First parameter");
            const r = Qe(t, "Second parameter"), o = function(e, t) {
                D(e, t);
                const r = null == e ? void 0 : e.abort, o = null == e ? void 0 : e.close, n = null == e ? void 0 : e.start, a = null == e ? void 0 : e.type, i = null == e ? void 0 : e.write;
                return {
                    abort: void 0 === r ? void 0 : xe(r, e, `${t} has member 'abort' that`),
                    close: void 0 === o ? void 0 : He(o, e, `${t} has member 'close' that`),
                    start: void 0 === n ? void 0 : Ve(n, e, `${t} has member 'start' that`),
                    write: void 0 === i ? void 0 : Ue(i, e, `${t} has member 'write' that`),
                    type: a
                };
            }(e, "First parameter");
            var n;
            (n = this)._state = "writable", n._storedError = void 0, n._writer = void 0, n._writableStreamController = void 0, n._writeRequests = new v, n._inFlightWriteRequest = void 0, n._closeRequest = void 0, n._inFlightCloseRequest = void 0, n._pendingAbortRequest = void 0, n._backpressure = !1;
            if (void 0 !== o.type) throw new RangeError("Invalid type is specified");
            const a = Ye(r);
            !function(e, t, r, o) {
                const n = Object.create(WritableStreamDefaultController.prototype);
                let a, i, l, s;
                a = void 0 !== t.start ? ()=>t.start(n) : ()=>{};
                i = void 0 !== t.write ? (e)=>t.write(e, n) : ()=>d(void 0);
                l = void 0 !== t.close ? ()=>t.close() : ()=>d(void 0);
                s = void 0 !== t.abort ? (e)=>t.abort(e) : ()=>d(void 0);
                !function(e, t, r, o, n, a, i, l) {
                    t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, de(t), t._abortReason = void 0, t._abortController = function() {
                        if (Ge) return new AbortController;
                    }(), t._started = !1, t._strategySizeAlgorithm = l, t._strategyHWM = i, t._writeAlgorithm = o, t._closeAlgorithm = n, t._abortAlgorithm = a;
                    const s = ht(t);
                    at(e, s);
                    const u = r();
                    h(d(u), ()=>(t._started = !0, ft(t), null), (r)=>(t._started = !0, et(e, r), null));
                }(e, n, a, i, l, s, r, o);
            }(this, o, Me(r, 1), a);
        }
        get locked() {
            if (!Xe(this)) throw pt("locked");
            return Je(this);
        }
        abort(e) {
            return Xe(this) ? Je(this) ? f(new TypeError("Cannot abort a stream that already has a writer")) : Ke(this, e) : f(pt("abort"));
        }
        close() {
            return Xe(this) ? Je(this) ? f(new TypeError("Cannot close a stream that already has a writer")) : ot(this) ? f(new TypeError("Cannot close an already-closing stream")) : Ze(this) : f(pt("close"));
        }
        getWriter() {
            if (!Xe(this)) throw pt("getWriter");
            return new WritableStreamDefaultWriter(this);
        }
    }
    function Xe(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_writableStreamController") && e instanceof WritableStream;
    }
    function Je(e) {
        return void 0 !== e._writer;
    }
    function Ke(e, t) {
        var r;
        if ("closed" === e._state || "errored" === e._state) return d(void 0);
        e._writableStreamController._abortReason = t, null === (r = e._writableStreamController._abortController) || void 0 === r || r.abort(t);
        const o = e._state;
        if ("closed" === o || "errored" === o) return d(void 0);
        if (void 0 !== e._pendingAbortRequest) return e._pendingAbortRequest._promise;
        let n = !1;
        "erroring" === o && (n = !0, t = void 0);
        const a = c((r, o)=>{
            e._pendingAbortRequest = {
                _promise: void 0,
                _resolve: r,
                _reject: o,
                _reason: t,
                _wasAlreadyErroring: n
            };
        });
        return e._pendingAbortRequest._promise = a, n || tt(e, t), a;
    }
    function Ze(e) {
        const t = e._state;
        if ("closed" === t || "errored" === t) return f(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));
        const r = c((t, r)=>{
            const o = {
                _resolve: t,
                _reject: r
            };
            e._closeRequest = o;
        }), o = e._writer;
        var n;
        return void 0 !== o && e._backpressure && "writable" === t && Et(o), ce(n = e._writableStreamController, st, 0), ft(n), r;
    }
    function et(e, t) {
        "writable" !== e._state ? rt(e) : tt(e, t);
    }
    function tt(e, t) {
        const r = e._writableStreamController;
        e._state = "erroring", e._storedError = t;
        const o = e._writer;
        void 0 !== o && lt(o, t), !function(e) {
            if (void 0 === e._inFlightWriteRequest && void 0 === e._inFlightCloseRequest) return !1;
            return !0;
        }(e) && r._started && rt(e);
    }
    function rt(e) {
        e._state = "errored", e._writableStreamController[T]();
        const t = e._storedError;
        if (e._writeRequests.forEach((e)=>{
            e._reject(t);
        }), e._writeRequests = new v, void 0 === e._pendingAbortRequest) return void nt(e);
        const r = e._pendingAbortRequest;
        if (e._pendingAbortRequest = void 0, r._wasAlreadyErroring) return r._reject(t), void nt(e);
        h(e._writableStreamController[R](r._reason), ()=>(r._resolve(), nt(e), null), (t)=>(r._reject(t), nt(e), null));
    }
    function ot(e) {
        return void 0 !== e._closeRequest || void 0 !== e._inFlightCloseRequest;
    }
    function nt(e) {
        void 0 !== e._closeRequest && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0);
        const t = e._writer;
        void 0 !== t && vt(t, e._storedError);
    }
    function at(e, t) {
        const r = e._writer;
        void 0 !== r && t !== e._backpressure && (t ? function(e) {
            Tt(e);
        }(r) : Et(r)), e._backpressure = t;
    }
    Object.defineProperties(WritableStream.prototype, {
        abort: {
            enumerable: !0
        },
        close: {
            enumerable: !0
        },
        getWriter: {
            enumerable: !0
        },
        locked: {
            enumerable: !0
        }
    }), a(WritableStream.prototype.abort, "abort"), a(WritableStream.prototype.close, "close"), a(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof t.toStringTag && Object.defineProperty(WritableStream.prototype, t.toStringTag, {
        value: "WritableStream",
        configurable: !0
    });
    class WritableStreamDefaultWriter {
        constructor(e){
            if (M(e, 1, "WritableStreamDefaultWriter"), function(e, t) {
                if (!Xe(e)) throw new TypeError(`${t} is not a WritableStream.`);
            }(e, "First parameter"), Je(e)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = e, e._writer = this;
            const t = e._state;
            if ("writable" === t) !ot(e) && e._backpressure ? Tt(this) : Ct(this), St(this);
            else if ("erroring" === t) qt(this, e._storedError), St(this);
            else if ("closed" === t) Ct(this), St(r = this), Rt(r);
            else {
                const t = e._storedError;
                qt(this, t), wt(this, t);
            }
            var r;
        }
        get closed() {
            return it(this) ? this._closedPromise : f(yt("closed"));
        }
        get desiredSize() {
            if (!it(this)) throw yt("desiredSize");
            if (void 0 === this._ownerWritableStream) throw gt("desiredSize");
            return function(e) {
                const t = e._ownerWritableStream, r = t._state;
                if ("errored" === r || "erroring" === r) return null;
                if ("closed" === r) return 0;
                return dt(t._writableStreamController);
            }(this);
        }
        get ready() {
            return it(this) ? this._readyPromise : f(yt("ready"));
        }
        abort(e) {
            return it(this) ? void 0 === this._ownerWritableStream ? f(gt("abort")) : function(e, t) {
                return Ke(e._ownerWritableStream, t);
            }(this, e) : f(yt("abort"));
        }
        close() {
            if (!it(this)) return f(yt("close"));
            const e = this._ownerWritableStream;
            return void 0 === e ? f(gt("close")) : ot(e) ? f(new TypeError("Cannot close an already-closing stream")) : Ze(this._ownerWritableStream);
        }
        releaseLock() {
            if (!it(this)) throw yt("releaseLock");
            void 0 !== this._ownerWritableStream && function(e) {
                const t = e._ownerWritableStream, r = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
                lt(e, r), function(e, t) {
                    "pending" === e._closedPromiseState ? vt(e, t) : function(e, t) {
                        wt(e, t);
                    }(e, t);
                }(e, r), t._writer = void 0, e._ownerWritableStream = void 0;
            }(this);
        }
        write(e) {
            return it(this) ? void 0 === this._ownerWritableStream ? f(gt("write to")) : function(e, t) {
                const r = e._ownerWritableStream, o = r._writableStreamController, n = function(e, t) {
                    try {
                        return e._strategySizeAlgorithm(t);
                    } catch (t) {
                        return bt(e, t), 1;
                    }
                }(o, t);
                if (r !== e._ownerWritableStream) return f(gt("write to"));
                const a = r._state;
                if ("errored" === a) return f(r._storedError);
                if (ot(r) || "closed" === a) return f(new TypeError("The stream is closing or closed and cannot be written to"));
                if ("erroring" === a) return f(r._storedError);
                const i = function(e) {
                    return c((t, r)=>{
                        const o = {
                            _resolve: t,
                            _reject: r
                        };
                        e._writeRequests.push(o);
                    });
                }(r);
                return function(e, t, r) {
                    try {
                        ce(e, t, r);
                    } catch (t) {
                        return void bt(e, t);
                    }
                    const o = e._controlledWritableStream;
                    if (!ot(o) && "writable" === o._state) {
                        at(o, ht(e));
                    }
                    ft(e);
                }(o, t, n), i;
            }(this, e) : f(yt("write"));
        }
    }
    function it(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_ownerWritableStream") && e instanceof WritableStreamDefaultWriter;
    }
    function lt(e, t) {
        "pending" === e._readyPromiseState ? Pt(e, t) : function(e, t) {
            qt(e, t);
        }(e, t);
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: {
            enumerable: !0
        },
        close: {
            enumerable: !0
        },
        releaseLock: {
            enumerable: !0
        },
        write: {
            enumerable: !0
        },
        closed: {
            enumerable: !0
        },
        desiredSize: {
            enumerable: !0
        },
        ready: {
            enumerable: !0
        }
    }), a(WritableStreamDefaultWriter.prototype.abort, "abort"), a(WritableStreamDefaultWriter.prototype.close, "close"), a(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), a(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof t.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, t.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
    });
    const st = {};
    class WritableStreamDefaultController {
        constructor(){
            throw new TypeError("Illegal constructor");
        }
        get abortReason() {
            if (!ut(this)) throw mt("abortReason");
            return this._abortReason;
        }
        get signal() {
            if (!ut(this)) throw mt("signal");
            if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            return this._abortController.signal;
        }
        error(e) {
            if (!ut(this)) throw mt("error");
            "writable" === this._controlledWritableStream._state && _t(this, e);
        }
        [R](e) {
            const t = this._abortAlgorithm(e);
            return ct(this), t;
        }
        [T]() {
            de(this);
        }
    }
    function ut(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledWritableStream") && e instanceof WritableStreamDefaultController;
    }
    function ct(e) {
        e._writeAlgorithm = void 0, e._closeAlgorithm = void 0, e._abortAlgorithm = void 0, e._strategySizeAlgorithm = void 0;
    }
    function dt(e) {
        return e._strategyHWM - e._queueTotalSize;
    }
    function ft(e) {
        const t = e._controlledWritableStream;
        if (!e._started) return;
        if (void 0 !== t._inFlightWriteRequest) return;
        if ("erroring" === t._state) return void rt(t);
        if (0 === e._queue.length) return;
        const r = e._queue.peek().value;
        r === st ? function(e) {
            const t = e._controlledWritableStream;
            (function(e) {
                e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0;
            })(t), ue(e);
            const r = e._closeAlgorithm();
            ct(e), h(r, ()=>((function(e) {
                    e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, "erroring" === e._state && (e._storedError = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = "closed";
                    const t = e._writer;
                    void 0 !== t && Rt(t);
                })(t), null), (e)=>((function(e, t) {
                    e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), et(e, t);
                })(t, e), null));
        }(e) : function(e, t) {
            const r = e._controlledWritableStream;
            !function(e) {
                e._inFlightWriteRequest = e._writeRequests.shift();
            }(r);
            h(e._writeAlgorithm(t), ()=>{
                !function(e) {
                    e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0;
                }(r);
                const t = r._state;
                if (ue(e), !ot(r) && "writable" === t) {
                    const t = ht(e);
                    at(r, t);
                }
                return ft(e), null;
            }, (t)=>("writable" === r._state && ct(e), function(e, t) {
                    e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, et(e, t);
                }(r, t), null));
        }(e, r);
    }
    function bt(e, t) {
        "writable" === e._controlledWritableStream._state && _t(e, t);
    }
    function ht(e) {
        return dt(e) <= 0;
    }
    function _t(e, t) {
        const r = e._controlledWritableStream;
        ct(e), tt(r, t);
    }
    function pt(e) {
        return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`);
    }
    function mt(e) {
        return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`);
    }
    function yt(e) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`);
    }
    function gt(e) {
        return new TypeError("Cannot " + e + " a stream using a released writer");
    }
    function St(e) {
        e._closedPromise = c((t, r)=>{
            e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = "pending";
        });
    }
    function wt(e, t) {
        St(e), vt(e, t);
    }
    function vt(e, t) {
        void 0 !== e._closedPromise_reject && (y(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "rejected");
    }
    function Rt(e) {
        void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "resolved");
    }
    function Tt(e) {
        e._readyPromise = c((t, r)=>{
            e._readyPromise_resolve = t, e._readyPromise_reject = r;
        }), e._readyPromiseState = "pending";
    }
    function qt(e, t) {
        Tt(e), Pt(e, t);
    }
    function Ct(e) {
        Tt(e), Et(e);
    }
    function Pt(e, t) {
        void 0 !== e._readyPromise_reject && (y(e._readyPromise), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "rejected");
    }
    function Et(e) {
        void 0 !== e._readyPromise_resolve && (e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "fulfilled");
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: {
            enumerable: !0
        },
        signal: {
            enumerable: !0
        },
        error: {
            enumerable: !0
        }
    }), "symbol" == typeof t.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, t.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
    });
    const Wt = "undefined" != typeof DOMException ? DOMException : void 0;
    const Ot = function(e) {
        if ("function" != typeof e && "object" != typeof e) return !1;
        try {
            return new e, !0;
        } catch (e) {
            return !1;
        }
    }(Wt) ? Wt : function() {
        const e = function(e, t) {
            this.message = e || "", this.name = t || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return e.prototype = Object.create(Error.prototype), Object.defineProperty(e.prototype, "constructor", {
            value: e,
            writable: !0,
            configurable: !0
        }), e;
    }();
    function kt(e, t, r, o, n, a) {
        const i = e.getReader(), l = t.getWriter();
        Ut(e) && (e._disturbed = !0);
        let s, u, p, S = !1, w = !1, v = "readable", R = "writable", T = !1, q = !1;
        const C = c((e)=>{
            p = e;
        });
        let P = Promise.resolve(void 0);
        return c((E, W)=>{
            let O;
            function k() {
                if (S) return;
                const e = c((e, t)=>{
                    !function r(o) {
                        o ? e() : b(function() {
                            if (S) return d(!0);
                            return b(l.ready, ()=>b(i.read(), (e)=>!!e.done || (P = l.write(e.value), y(P), !1)));
                        }(), r, t);
                    }(!1);
                });
                y(e);
            }
            function B() {
                return v = "closed", r ? L() : z(()=>(Xe(t) && (T = ot(t), R = t._state), T || "closed" === R ? d(void 0) : "erroring" === R || "errored" === R ? f(u) : (T = !0, l.close())), !1, void 0), null;
            }
            function A(e) {
                return S || (v = "errored", s = e, o ? L(!0, e) : z(()=>l.abort(e), !0, e)), null;
            }
            function j(e) {
                return w || (R = "errored", u = e, n ? L(!0, e) : z(()=>i.cancel(e), !0, e)), null;
            }
            if (void 0 !== a && (O = ()=>{
                const e = void 0 !== a.reason ? a.reason : new Ot("Aborted", "AbortError"), t = [];
                o || t.push(()=>"writable" === R ? l.abort(e) : d(void 0)), n || t.push(()=>"readable" === v ? i.cancel(e) : d(void 0)), z(()=>Promise.all(t.map((e)=>e())), !0, e);
            }, a.aborted ? O() : a.addEventListener("abort", O)), Ut(e) && (v = e._state, s = e._storedError), Xe(t) && (R = t._state, u = t._storedError, T = ot(t)), Ut(e) && Xe(t) && (q = !0, p()), "errored" === v) A(s);
            else if ("erroring" === R || "errored" === R) j(u);
            else if ("closed" === v) B();
            else if (T || "closed" === R) {
                const e = new TypeError("the destination writable stream closed before all data could be piped to it");
                n ? L(!0, e) : z(()=>i.cancel(e), !0, e);
            }
            function z(e, t, r) {
                function o() {
                    return "writable" !== R || T ? n() : _(function() {
                        let e;
                        return d(function t() {
                            if (e !== P) return e = P, m(P, t, t);
                        }());
                    }(), n), null;
                }
                function n() {
                    return e ? h(e(), ()=>F(t, r), (e)=>F(!0, e)) : F(t, r), null;
                }
                S || (S = !0, q ? o() : _(C, o));
            }
            function L(e, t) {
                z(void 0, e, t);
            }
            function F(e, t) {
                return w = !0, l.releaseLock(), i.releaseLock(), void 0 !== a && a.removeEventListener("abort", O), e ? W(t) : E(void 0), null;
            }
            S || (h(i.closed, B, A), h(l.closed, function() {
                return w || (R = "closed"), null;
            }, j)), q ? k() : g(()=>{
                q = !0, p(), k();
            });
        });
    }
    function Bt(e, t) {
        return function(e) {
            try {
                return e.getReader({
                    mode: "byob"
                }).releaseLock(), !0;
            } catch (e) {
                return !1;
            }
        }(e) ? function(e) {
            let t, r, o, n, a, i = e.getReader(), l = !1, s = !1, u = !1, f = !1, b = !1, _ = !1;
            const m = c((e)=>{
                a = e;
            });
            function y(e) {
                p(e.closed, (t)=>(e !== i || (o.error(t), n.error(t), b && _ || a(void 0)), null));
            }
            function g() {
                l && (i.releaseLock(), i = e.getReader(), y(i), l = !1), h(i.read(), (e)=>{
                    var t, r;
                    if (u = !1, f = !1, e.done) return b || o.close(), _ || n.close(), null === (t = o.byobRequest) || void 0 === t || t.respond(0), null === (r = n.byobRequest) || void 0 === r || r.respond(0), b && _ || a(void 0), null;
                    const l = e.value, c = l;
                    let d = l;
                    if (!b && !_) try {
                        d = se(l);
                    } catch (e) {
                        return o.error(e), n.error(e), a(i.cancel(e)), null;
                    }
                    return b || o.enqueue(c), _ || n.enqueue(d), s = !1, u ? w() : f && v(), null;
                }, ()=>(s = !1, null));
            }
            function S(t, r) {
                l || (i.releaseLock(), i = e.getReader({
                    mode: "byob"
                }), y(i), l = !0);
                const c = r ? n : o, d = r ? o : n;
                h(i.read(t), (e)=>{
                    var t;
                    u = !1, f = !1;
                    const o = r ? _ : b, n = r ? b : _;
                    if (e.done) {
                        o || c.close(), n || d.close();
                        const r = e.value;
                        return void 0 !== r && (o || c.byobRequest.respondWithNewView(r), n || null === (t = d.byobRequest) || void 0 === t || t.respond(0)), o && n || a(void 0), null;
                    }
                    const l = e.value;
                    if (n) o || c.byobRequest.respondWithNewView(l);
                    else {
                        let e;
                        try {
                            e = se(l);
                        } catch (e) {
                            return c.error(e), d.error(e), a(i.cancel(e)), null;
                        }
                        o || c.byobRequest.respondWithNewView(l), d.enqueue(e);
                    }
                    return s = !1, u ? w() : f && v(), null;
                }, ()=>(s = !1, null));
            }
            function w() {
                if (s) return u = !0, d(void 0);
                s = !0;
                const e = o.byobRequest;
                return null === e ? g() : S(e.view, !1), d(void 0);
            }
            function v() {
                if (s) return f = !0, d(void 0);
                s = !0;
                const e = n.byobRequest;
                return null === e ? g() : S(e.view, !0), d(void 0);
            }
            function R(e) {
                if (b = !0, t = e, _) {
                    const e = [
                        t,
                        r
                    ], o = i.cancel(e);
                    a(o);
                }
                return m;
            }
            function T(e) {
                if (_ = !0, r = e, b) {
                    const e = [
                        t,
                        r
                    ], o = i.cancel(e);
                    a(o);
                }
                return m;
            }
            const q = new ReadableStream({
                type: "bytes",
                start (e) {
                    o = e;
                },
                pull: w,
                cancel: R
            }), C = new ReadableStream({
                type: "bytes",
                start (e) {
                    n = e;
                },
                pull: v,
                cancel: T
            });
            return y(i), [
                q,
                C
            ];
        }(e) : function(e, t) {
            const r = e.getReader();
            let o, n, a, i, l, s = !1, u = !1, f = !1, b = !1;
            const _ = c((e)=>{
                l = e;
            });
            function m() {
                return s ? (u = !0, d(void 0)) : (s = !0, h(r.read(), (e)=>{
                    if (u = !1, e.done) return f || a.close(), b || i.close(), f && b || l(void 0), null;
                    const t = e.value, r = t, o = t;
                    return f || a.enqueue(r), b || i.enqueue(o), s = !1, u && m(), null;
                }, ()=>(s = !1, null)), d(void 0));
            }
            function y(e) {
                if (f = !0, o = e, b) {
                    const e = [
                        o,
                        n
                    ], t = r.cancel(e);
                    l(t);
                }
                return _;
            }
            function g(e) {
                if (b = !0, n = e, f) {
                    const e = [
                        o,
                        n
                    ], t = r.cancel(e);
                    l(t);
                }
                return _;
            }
            const S = new ReadableStream({
                start (e) {
                    a = e;
                },
                pull: m,
                cancel: y
            }), w = new ReadableStream({
                start (e) {
                    i = e;
                },
                pull: m,
                cancel: g
            });
            return p(r.closed, (e)=>(a.error(e), i.error(e), f && b || l(void 0), null)), [
                S,
                w
            ];
        }(e);
    }
    class ReadableStreamDefaultController {
        constructor(){
            throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
            if (!At(this)) throw $t("desiredSize");
            return Ft(this);
        }
        close() {
            if (!At(this)) throw $t("close");
            if (!Dt(this)) throw new TypeError("The stream is not in a state that permits close");
            !function(e) {
                if (!Dt(e)) return;
                const t = e._controlledReadableStream;
                e._closeRequested = !0, 0 === e._queue.length && (zt(e), Jt(t));
            }(this);
        }
        enqueue(e) {
            if (!At(this)) throw $t("enqueue");
            if (!Dt(this)) throw new TypeError("The stream is not in a state that permits enqueue");
            return function(e, t) {
                if (!Dt(e)) return;
                const r = e._controlledReadableStream;
                if (Gt(r) && J(r) > 0) X(r, t, !1);
                else {
                    let r;
                    try {
                        r = e._strategySizeAlgorithm(t);
                    } catch (t) {
                        throw Lt(e, t), t;
                    }
                    try {
                        ce(e, t, r);
                    } catch (t) {
                        throw Lt(e, t), t;
                    }
                }
                jt(e);
            }(this, e);
        }
        error(e) {
            if (!At(this)) throw $t("error");
            Lt(this, e);
        }
        [q](e) {
            de(this);
            const t = this._cancelAlgorithm(e);
            return zt(this), t;
        }
        [C](e) {
            const t = this._controlledReadableStream;
            if (this._queue.length > 0) {
                const r = ue(this);
                this._closeRequested && 0 === this._queue.length ? (zt(this), Jt(t)) : jt(this), e._chunkSteps(r);
            } else G(t, e), jt(this);
        }
        [P]() {}
    }
    function At(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableStream") && e instanceof ReadableStreamDefaultController;
    }
    function jt(e) {
        const t = function(e) {
            const t = e._controlledReadableStream;
            if (!Dt(e)) return !1;
            if (!e._started) return !1;
            if (Gt(t) && J(t) > 0) return !0;
            if (Ft(e) > 0) return !0;
            return !1;
        }(e);
        if (!t) return;
        if (e._pulling) return void (e._pullAgain = !0);
        e._pulling = !0;
        h(e._pullAlgorithm(), ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, jt(e)), null), (t)=>(Lt(e, t), null));
    }
    function zt(e) {
        e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0, e._strategySizeAlgorithm = void 0;
    }
    function Lt(e, t) {
        const r = e._controlledReadableStream;
        "readable" === r._state && (de(e), zt(e), Kt(r, t));
    }
    function Ft(e) {
        const t = e._controlledReadableStream._state;
        return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize;
    }
    function Dt(e) {
        return !e._closeRequested && "readable" === e._controlledReadableStream._state;
    }
    function It(e, t, r, o) {
        const n = Object.create(ReadableStreamDefaultController.prototype);
        let a, i, l;
        a = void 0 !== t.start ? ()=>t.start(n) : ()=>{}, i = void 0 !== t.pull ? ()=>t.pull(n) : ()=>d(void 0), l = void 0 !== t.cancel ? (e)=>t.cancel(e) : ()=>d(void 0), function(e, t, r, o, n, a, i) {
            t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, de(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = i, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, e._readableStreamController = t, h(d(r()), ()=>(t._started = !0, jt(t), null), (e)=>(Lt(t, e), null));
        }(e, n, a, i, l, r, o);
    }
    function $t(e) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`);
    }
    function Mt(e, t, r) {
        return I(e, r), (r)=>w(e, t, [
                r
            ]);
    }
    function Yt(e, t, r) {
        return I(e, r), (r)=>w(e, t, [
                r
            ]);
    }
    function Qt(e, t, r) {
        return I(e, r), (r)=>S(e, t, [
                r
            ]);
    }
    function Nt(e, t) {
        if ("bytes" !== (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);
        return e;
    }
    function xt(e, t) {
        if ("byob" !== (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);
        return e;
    }
    function Ht(e, t) {
        D(e, t);
        const r = null == e ? void 0 : e.preventAbort, o = null == e ? void 0 : e.preventCancel, n = null == e ? void 0 : e.preventClose, a = null == e ? void 0 : e.signal;
        return void 0 !== a && function(e, t) {
            if (!function(e) {
                if ("object" != typeof e || null === e) return !1;
                try {
                    return "boolean" == typeof e.aborted;
                } catch (e) {
                    return !1;
                }
            }(e)) throw new TypeError(`${t} is not an AbortSignal.`);
        }(a, `${t} has member 'signal' that`), {
            preventAbort: Boolean(r),
            preventCancel: Boolean(o),
            preventClose: Boolean(n),
            signal: a
        };
    }
    function Vt(e, t) {
        D(e, t);
        const r = null == e ? void 0 : e.readable;
        Y(r, "readable", "ReadableWritablePair"), function(e, t) {
            if (!H(e)) throw new TypeError(`${t} is not a ReadableStream.`);
        }(r, `${t} has member 'readable' that`);
        const o = null == e ? void 0 : e.writable;
        return Y(o, "writable", "ReadableWritablePair"), function(e, t) {
            if (!V(e)) throw new TypeError(`${t} is not a WritableStream.`);
        }(o, `${t} has member 'writable' that`), {
            readable: r,
            writable: o
        };
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: {
            enumerable: !0
        },
        enqueue: {
            enumerable: !0
        },
        error: {
            enumerable: !0
        },
        desiredSize: {
            enumerable: !0
        }
    }), a(ReadableStreamDefaultController.prototype.close, "close"), a(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), a(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, t.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
    });
    class ReadableStream {
        constructor(e = {}, t = {}){
            void 0 === e ? e = null : $(e, "First parameter");
            const r = Qe(t, "Second parameter"), o = function(e, t) {
                D(e, t);
                const r = e, o = null == r ? void 0 : r.autoAllocateChunkSize, n = null == r ? void 0 : r.cancel, a = null == r ? void 0 : r.pull, i = null == r ? void 0 : r.start, l = null == r ? void 0 : r.type;
                return {
                    autoAllocateChunkSize: void 0 === o ? void 0 : x(o, `${t} has member 'autoAllocateChunkSize' that`),
                    cancel: void 0 === n ? void 0 : Mt(n, r, `${t} has member 'cancel' that`),
                    pull: void 0 === a ? void 0 : Yt(a, r, `${t} has member 'pull' that`),
                    start: void 0 === i ? void 0 : Qt(i, r, `${t} has member 'start' that`),
                    type: void 0 === l ? void 0 : Nt(l, `${t} has member 'type' that`)
                };
            }(e, "First parameter");
            var n;
            if ((n = this)._state = "readable", n._reader = void 0, n._storedError = void 0, n._disturbed = !1, "bytes" === o.type) {
                if (void 0 !== r.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
                Be(this, o, Me(r, 0));
            } else {
                const e = Ye(r);
                It(this, o, Me(r, 1), e);
            }
        }
        get locked() {
            if (!Ut(this)) throw Zt("locked");
            return Gt(this);
        }
        cancel(e) {
            return Ut(this) ? Gt(this) ? f(new TypeError("Cannot cancel a stream that already has a reader")) : Xt(this, e) : f(Zt("cancel"));
        }
        getReader(e) {
            if (!Ut(this)) throw Zt("getReader");
            return void 0 === function(e, t) {
                D(e, t);
                const r = null == e ? void 0 : e.mode;
                return {
                    mode: void 0 === r ? void 0 : xt(r, `${t} has member 'mode' that`)
                };
            }(e, "First parameter").mode ? new ReadableStreamDefaultReader(this) : function(e) {
                return new ReadableStreamBYOBReader(e);
            }(this);
        }
        pipeThrough(e, t = {}) {
            if (!H(this)) throw Zt("pipeThrough");
            M(e, 1, "pipeThrough");
            const r = Vt(e, "First parameter"), o = Ht(t, "Second parameter");
            if (this.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (r.writable.locked) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            return y(kt(this, r.writable, o.preventClose, o.preventAbort, o.preventCancel, o.signal)), r.readable;
        }
        pipeTo(e, t = {}) {
            if (!H(this)) return f(Zt("pipeTo"));
            if (void 0 === e) return f("Parameter 1 is required in 'pipeTo'.");
            if (!V(e)) return f(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            let r;
            try {
                r = Ht(t, "Second parameter");
            } catch (e) {
                return f(e);
            }
            return this.locked ? f(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : e.locked ? f(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : kt(this, e, r.preventClose, r.preventAbort, r.preventCancel, r.signal);
        }
        tee() {
            if (!H(this)) throw Zt("tee");
            if (this.locked) throw new TypeError("Cannot tee a stream that already has a reader");
            return Bt(this);
        }
        values(e) {
            if (!H(this)) throw Zt("values");
            return function(e, t) {
                const r = e.getReader(), o = new re(r, t), n = Object.create(oe);
                return n._asyncIteratorImpl = o, n;
            }(this, function(e, t) {
                D(e, t);
                const r = null == e ? void 0 : e.preventCancel;
                return {
                    preventCancel: Boolean(r)
                };
            }(e, "First parameter").preventCancel);
        }
    }
    function Ut(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_readableStreamController") && e instanceof ReadableStream;
    }
    function Gt(e) {
        return void 0 !== e._reader;
    }
    function Xt(e, t) {
        if (e._disturbed = !0, "closed" === e._state) return d(void 0);
        if ("errored" === e._state) return f(e._storedError);
        Jt(e);
        const o = e._reader;
        if (void 0 !== o && De(o)) {
            const e = o._readIntoRequests;
            o._readIntoRequests = new v, e.forEach((e)=>{
                e._closeSteps(void 0);
            });
        }
        return m(e._readableStreamController[q](t), r);
    }
    function Jt(e) {
        e._state = "closed";
        const t = e._reader;
        if (void 0 !== t && (z(t), Z(t))) {
            const e = t._readRequests;
            t._readRequests = new v, e.forEach((e)=>{
                e._closeSteps();
            });
        }
    }
    function Kt(e, t) {
        e._state = "errored", e._storedError = t;
        const r = e._reader;
        void 0 !== r && (j(r, t), Z(r) ? ee(r, t) : Ie(r, t));
    }
    function Zt(e) {
        return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`);
    }
    function er(e, t) {
        D(e, t);
        const r = null == e ? void 0 : e.highWaterMark;
        return Y(r, "highWaterMark", "QueuingStrategyInit"), {
            highWaterMark: Q(r)
        };
    }
    Object.defineProperties(ReadableStream.prototype, {
        cancel: {
            enumerable: !0
        },
        getReader: {
            enumerable: !0
        },
        pipeThrough: {
            enumerable: !0
        },
        pipeTo: {
            enumerable: !0
        },
        tee: {
            enumerable: !0
        },
        values: {
            enumerable: !0
        },
        locked: {
            enumerable: !0
        }
    }), a(ReadableStream.prototype.cancel, "cancel"), a(ReadableStream.prototype.getReader, "getReader"), a(ReadableStream.prototype.pipeThrough, "pipeThrough"), a(ReadableStream.prototype.pipeTo, "pipeTo"), a(ReadableStream.prototype.tee, "tee"), a(ReadableStream.prototype.values, "values"), "symbol" == typeof t.toStringTag && Object.defineProperty(ReadableStream.prototype, t.toStringTag, {
        value: "ReadableStream",
        configurable: !0
    }), "symbol" == typeof t.asyncIterator && Object.defineProperty(ReadableStream.prototype, t.asyncIterator, {
        value: ReadableStream.prototype.values,
        writable: !0,
        configurable: !0
    });
    const tr = (e)=>e.byteLength;
    a(tr, "size");
    class ByteLengthQueuingStrategy {
        constructor(e){
            M(e, 1, "ByteLengthQueuingStrategy"), e = er(e, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e.highWaterMark;
        }
        get highWaterMark() {
            if (!or(this)) throw rr("highWaterMark");
            return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
            if (!or(this)) throw rr("size");
            return tr;
        }
    }
    function rr(e) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`);
    }
    function or(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_byteLengthQueuingStrategyHighWaterMark") && e instanceof ByteLengthQueuingStrategy;
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: {
            enumerable: !0
        },
        size: {
            enumerable: !0
        }
    }), "symbol" == typeof t.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, t.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
    });
    const nr = ()=>1;
    a(nr, "size");
    class CountQueuingStrategy {
        constructor(e){
            M(e, 1, "CountQueuingStrategy"), e = er(e, "First parameter"), this._countQueuingStrategyHighWaterMark = e.highWaterMark;
        }
        get highWaterMark() {
            if (!ir(this)) throw ar("highWaterMark");
            return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
            if (!ir(this)) throw ar("size");
            return nr;
        }
    }
    function ar(e) {
        return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`);
    }
    function ir(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_countQueuingStrategyHighWaterMark") && e instanceof CountQueuingStrategy;
    }
    function lr(e, t, r) {
        return I(e, r), (r)=>w(e, t, [
                r
            ]);
    }
    function sr(e, t, r) {
        return I(e, r), (r)=>S(e, t, [
                r
            ]);
    }
    function ur(e, t, r) {
        return I(e, r), (r, o)=>w(e, t, [
                r,
                o
            ]);
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: {
            enumerable: !0
        },
        size: {
            enumerable: !0
        }
    }), "symbol" == typeof t.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, t.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
    });
    class TransformStream {
        constructor(e = {}, t = {}, r = {}){
            void 0 === e && (e = null);
            const o = Qe(t, "Second parameter"), n = Qe(r, "Third parameter"), a = function(e, t) {
                D(e, t);
                const r = null == e ? void 0 : e.flush, o = null == e ? void 0 : e.readableType, n = null == e ? void 0 : e.start, a = null == e ? void 0 : e.transform, i = null == e ? void 0 : e.writableType;
                return {
                    flush: void 0 === r ? void 0 : lr(r, e, `${t} has member 'flush' that`),
                    readableType: o,
                    start: void 0 === n ? void 0 : sr(n, e, `${t} has member 'start' that`),
                    transform: void 0 === a ? void 0 : ur(a, e, `${t} has member 'transform' that`),
                    writableType: i
                };
            }(e, "First parameter");
            if (void 0 !== a.readableType) throw new RangeError("Invalid readableType specified");
            if (void 0 !== a.writableType) throw new RangeError("Invalid writableType specified");
            const i = Me(n, 0), l = Ye(n), s = Me(o, 1), u = Ye(o);
            let b;
            !function(e, t, r, o, n, a) {
                function i() {
                    return t;
                }
                function l(t) {
                    return function(e, t) {
                        const r = e._transformStreamController;
                        if (e._backpressure) {
                            return m(e._backpressureChangePromise, ()=>{
                                if ("erroring" === (Xe(e._writable) ? e._writable._state : e._writableState)) throw Xe(e._writable) ? e._writable._storedError : e._writableStoredError;
                                return mr(r, t);
                            });
                        }
                        return mr(r, t);
                    }(e, t);
                }
                function s(t) {
                    return function(e, t) {
                        return dr(e, t), d(void 0);
                    }(e, t);
                }
                function u() {
                    return function(e) {
                        const t = e._transformStreamController, r = t._flushAlgorithm();
                        return _r(t), m(r, ()=>{
                            if ("errored" === e._readableState) throw e._readableStoredError;
                            Sr(e) && wr(e);
                        }, (t)=>{
                            throw dr(e, t), e._readableStoredError;
                        });
                    }(e);
                }
                function c() {
                    return function(e) {
                        return br(e, !1), e._backpressureChangePromise;
                    }(e);
                }
                function f(t) {
                    return fr(e, t), d(void 0);
                }
                e._writableState = "writable", e._writableStoredError = void 0, e._writableHasInFlightOperation = !1, e._writableStarted = !1, e._writable = function(e, t, r, o, n, a, i) {
                    return new WritableStream({
                        start (r) {
                            e._writableController = r;
                            try {
                                const t = r.signal;
                                void 0 !== t && t.addEventListener("abort", ()=>{
                                    "writable" === e._writableState && (e._writableState = "erroring", t.reason && (e._writableStoredError = t.reason));
                                });
                            } catch (e) {}
                            return m(t(), ()=>(e._writableStarted = !0, Pr(e), null), (t)=>{
                                throw e._writableStarted = !0, Tr(e, t), t;
                            });
                        },
                        write: (t)=>((function(e) {
                                e._writableHasInFlightOperation = !0;
                            })(e), m(r(t), ()=>((function(e) {
                                    e._writableHasInFlightOperation = !1;
                                })(e), Pr(e), null), (t)=>{
                                throw function(e, t) {
                                    e._writableHasInFlightOperation = !1, Tr(e, t);
                                }(e, t), t;
                            })),
                        close: ()=>((function(e) {
                                e._writableHasInFlightOperation = !0;
                            })(e), m(o(), ()=>((function(e) {
                                    e._writableHasInFlightOperation = !1;
                                    "erroring" === e._writableState && (e._writableStoredError = void 0);
                                    e._writableState = "closed";
                                })(e), null), (t)=>{
                                throw function(e, t) {
                                    e._writableHasInFlightOperation = !1, e._writableState, Tr(e, t);
                                }(e, t), t;
                            })),
                        abort: (t)=>(e._writableState = "errored", e._writableStoredError = t, n(t))
                    }, {
                        highWaterMark: a,
                        size: i
                    });
                }(e, i, l, u, s, r, o), e._readableState = "readable", e._readableStoredError = void 0, e._readableCloseRequested = !1, e._readablePulling = !1, e._readable = function(e, t, r, o, n, a) {
                    return new ReadableStream({
                        start: (r)=>(e._readableController = r, t().catch((t)=>{
                                vr(e, t);
                            })),
                        pull: ()=>(e._readablePulling = !0, r().catch((t)=>{
                                vr(e, t);
                            })),
                        cancel: (t)=>(e._readableState = "closed", o(t))
                    }, {
                        highWaterMark: n,
                        size: a
                    });
                }(e, i, c, f, n, a), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, br(e, !0), e._transformStreamController = void 0;
            }(this, c((e)=>{
                b = e;
            }), s, u, i, l), function(e, t) {
                const r = Object.create(TransformStreamDefaultController.prototype);
                let o, n;
                o = void 0 !== t.transform ? (e)=>t.transform(e, r) : (e)=>{
                    try {
                        return pr(r, e), d(void 0);
                    } catch (e) {
                        return f(e);
                    }
                };
                n = void 0 !== t.flush ? ()=>t.flush(r) : ()=>d(void 0);
                !function(e, t, r, o) {
                    t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = o;
                }(e, r, o, n);
            }(this, a), void 0 !== a.start ? b(a.start(this._transformStreamController)) : b(void 0);
        }
        get readable() {
            if (!cr(this)) throw gr("readable");
            return this._readable;
        }
        get writable() {
            if (!cr(this)) throw gr("writable");
            return this._writable;
        }
    }
    function cr(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_transformStreamController") && e instanceof TransformStream;
    }
    function dr(e, t) {
        vr(e, t), fr(e, t);
    }
    function fr(e, t) {
        _r(e._transformStreamController), function(e, t) {
            e._writableController.error(t);
            "writable" === e._writableState && qr(e, t);
        }(e, t), e._backpressure && br(e, !1);
    }
    function br(e, t) {
        void 0 !== e._backpressureChangePromise && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = c((t)=>{
            e._backpressureChangePromise_resolve = t;
        }), e._backpressure = t;
    }
    Object.defineProperties(TransformStream.prototype, {
        readable: {
            enumerable: !0
        },
        writable: {
            enumerable: !0
        }
    }), "symbol" == typeof t.toStringTag && Object.defineProperty(TransformStream.prototype, t.toStringTag, {
        value: "TransformStream",
        configurable: !0
    });
    class TransformStreamDefaultController {
        constructor(){
            throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
            if (!hr(this)) throw yr("desiredSize");
            return Rr(this._controlledTransformStream);
        }
        enqueue(e) {
            if (!hr(this)) throw yr("enqueue");
            pr(this, e);
        }
        error(e) {
            if (!hr(this)) throw yr("error");
            var t;
            t = e, dr(this._controlledTransformStream, t);
        }
        terminate() {
            if (!hr(this)) throw yr("terminate");
            !function(e) {
                const t = e._controlledTransformStream;
                Sr(t) && wr(t);
                const r = new TypeError("TransformStream terminated");
                fr(t, r);
            }(this);
        }
    }
    function hr(e) {
        return !!o(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledTransformStream") && e instanceof TransformStreamDefaultController;
    }
    function _r(e) {
        e._transformAlgorithm = void 0, e._flushAlgorithm = void 0;
    }
    function pr(e, t) {
        const r = e._controlledTransformStream;
        if (!Sr(r)) throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
            !function(e, t) {
                e._readablePulling = !1;
                try {
                    e._readableController.enqueue(t);
                } catch (t) {
                    throw vr(e, t), t;
                }
            }(r, t);
        } catch (e) {
            throw fr(r, e), r._readableStoredError;
        }
        const o = function(e) {
            return !function(e) {
                if (!Sr(e)) return !1;
                if (e._readablePulling) return !0;
                if (Rr(e) > 0) return !0;
                return !1;
            }(e);
        }(r);
        o !== r._backpressure && br(r, !0);
    }
    function mr(e, t) {
        return m(e._transformAlgorithm(t), void 0, (t)=>{
            throw dr(e._controlledTransformStream, t), t;
        });
    }
    function yr(e) {
        return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`);
    }
    function gr(e) {
        return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`);
    }
    function Sr(e) {
        return !e._readableCloseRequested && "readable" === e._readableState;
    }
    function wr(e) {
        e._readableState = "closed", e._readableCloseRequested = !0, e._readableController.close();
    }
    function vr(e, t) {
        "readable" === e._readableState && (e._readableState = "errored", e._readableStoredError = t), e._readableController.error(t);
    }
    function Rr(e) {
        return e._readableController.desiredSize;
    }
    function Tr(e, t) {
        "writable" !== e._writableState ? Cr(e) : qr(e, t);
    }
    function qr(e, t) {
        e._writableState = "erroring", e._writableStoredError = t, !function(e) {
            return e._writableHasInFlightOperation;
        }(e) && e._writableStarted && Cr(e);
    }
    function Cr(e) {
        e._writableState = "errored";
    }
    function Pr(e) {
        "erroring" === e._writableState && Cr(e);
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: {
            enumerable: !0
        },
        error: {
            enumerable: !0
        },
        terminate: {
            enumerable: !0
        },
        desiredSize: {
            enumerable: !0
        }
    }), a(TransformStreamDefaultController.prototype.enqueue, "enqueue"), a(TransformStreamDefaultController.prototype.error, "error"), a(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof t.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, t.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
    }), e.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, e.CountQueuingStrategy = CountQueuingStrategy, e.ReadableByteStreamController = ReadableByteStreamController, e.ReadableStream = ReadableStream, e.ReadableStreamBYOBReader = ReadableStreamBYOBReader, e.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, e.ReadableStreamDefaultController = ReadableStreamDefaultController, e.ReadableStreamDefaultReader = ReadableStreamDefaultReader, e.TransformStream = TransformStream, e.TransformStreamDefaultController = TransformStreamDefaultController, e.WritableStream = WritableStream, e.WritableStreamDefaultController = WritableStreamDefaultController, e.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(e, "__esModule", {
        value: !0
    });
});
}),
"[project]/node_modules/formdata-node/lib/cjs/isFunction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFunction = void 0;
const isFunction = (value)=>typeof value === "function";
exports.isFunction = isFunction;
}),
"[project]/node_modules/formdata-node/lib/cjs/blobHelpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sliceBlob = exports.consumeBlobParts = void 0;
const isFunction_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isFunction.js [app-route] (ecmascript)");
const CHUNK_SIZE = 65536;
async function* clonePart(part) {
    const end = part.byteOffset + part.byteLength;
    let position = part.byteOffset;
    while(position !== end){
        const size = Math.min(end - position, CHUNK_SIZE);
        const chunk = part.buffer.slice(position, position + size);
        position += chunk.byteLength;
        yield new Uint8Array(chunk);
    }
}
async function* consumeNodeBlob(blob) {
    let position = 0;
    while(position !== blob.size){
        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
    }
}
async function* consumeBlobParts(parts, clone = false) {
    for (const part of parts){
        if (ArrayBuffer.isView(part)) {
            if (clone) {
                yield* clonePart(part);
            } else {
                yield part;
            }
        } else if ((0, isFunction_1.isFunction)(part.stream)) {
            yield* part.stream();
        } else {
            yield* consumeNodeBlob(part);
        }
    }
}
exports.consumeBlobParts = consumeBlobParts;
function* sliceBlob(blobParts, blobSize, start = 0, end) {
    end !== null && end !== void 0 ? end : end = blobSize;
    let relativeStart = start < 0 ? Math.max(blobSize + start, 0) : Math.min(start, blobSize);
    let relativeEnd = end < 0 ? Math.max(blobSize + end, 0) : Math.min(end, blobSize);
    const span = Math.max(relativeEnd - relativeStart, 0);
    let added = 0;
    for (const part of blobParts){
        if (added >= span) {
            break;
        }
        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && partSize <= relativeStart) {
            relativeStart -= partSize;
            relativeEnd -= partSize;
        } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
                chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
                added += chunk.byteLength;
            } else {
                chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
                added += chunk.size;
            }
            relativeEnd -= partSize;
            relativeStart = 0;
            yield chunk;
        }
    }
}
exports.sliceBlob = sliceBlob;
}),
"[project]/node_modules/formdata-node/lib/cjs/Blob.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*! Based on fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> & David Frank */ var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _Blob_parts, _Blob_type, _Blob_size;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Blob = void 0;
const web_streams_polyfill_1 = __turbopack_context__.r("[project]/node_modules/web-streams-polyfill/dist/ponyfill.js [app-route] (ecmascript)");
const isFunction_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isFunction.js [app-route] (ecmascript)");
const blobHelpers_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/blobHelpers.js [app-route] (ecmascript)");
class Blob {
    constructor(blobParts = [], options = {}){
        _Blob_parts.set(this, []);
        _Blob_type.set(this, "");
        _Blob_size.set(this, 0);
        options !== null && options !== void 0 ? options : options = {};
        if (typeof blobParts !== "object" || blobParts === null) {
            throw new TypeError("Failed to construct 'Blob': " + "The provided value cannot be converted to a sequence.");
        }
        if (!(0, isFunction_1.isFunction)(blobParts[Symbol.iterator])) {
            throw new TypeError("Failed to construct 'Blob': " + "The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && !(0, isFunction_1.isFunction)(options)) {
            throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        const encoder = new TextEncoder();
        for (const raw of blobParts){
            let part;
            if (ArrayBuffer.isView(raw)) {
                part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));
            } else if (raw instanceof ArrayBuffer) {
                part = new Uint8Array(raw.slice(0));
            } else if (raw instanceof Blob) {
                part = raw;
            } else {
                part = encoder.encode(String(raw));
            }
            __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
            __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
        }
        const type = options.type === undefined ? "" : String(options.type);
        __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
    }
    static [(_Blob_parts = new WeakMap(), _Blob_type = new WeakMap(), _Blob_size = new WeakMap(), Symbol.hasInstance)](value) {
        return Boolean(value && typeof value === "object" && (0, isFunction_1.isFunction)(value.constructor) && ((0, isFunction_1.isFunction)(value.stream) || (0, isFunction_1.isFunction)(value.arrayBuffer)) && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
    }
    get type() {
        return __classPrivateFieldGet(this, _Blob_type, "f");
    }
    get size() {
        return __classPrivateFieldGet(this, _Blob_size, "f");
    }
    slice(start, end, contentType) {
        return new Blob((0, blobHelpers_1.sliceBlob)(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
            type: contentType
        });
    }
    async text() {
        const decoder = new TextDecoder();
        let result = "";
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))){
            result += decoder.decode(chunk, {
                stream: true
            });
        }
        result += decoder.decode();
        return result;
    }
    async arrayBuffer() {
        const view = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))){
            view.set(chunk, offset);
            offset += chunk.length;
        }
        return view.buffer;
    }
    stream() {
        const iterator = (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
        return new web_streams_polyfill_1.ReadableStream({
            async pull (controller) {
                const { value, done } = await iterator.next();
                if (done) {
                    return queueMicrotask(()=>controller.close());
                }
                controller.enqueue(value);
            },
            async cancel () {
                await iterator.return();
            }
        });
    }
    get [Symbol.toStringTag]() {
        return "Blob";
    }
}
exports.Blob = Blob;
Object.defineProperties(Blob.prototype, {
    type: {
        enumerable: true
    },
    size: {
        enumerable: true
    },
    slice: {
        enumerable: true
    },
    stream: {
        enumerable: true
    },
    text: {
        enumerable: true
    },
    arrayBuffer: {
        enumerable: true
    }
});
}),
"[project]/node_modules/formdata-node/lib/cjs/File.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _File_name, _File_lastModified;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.File = void 0;
const Blob_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/Blob.js [app-route] (ecmascript)");
class File extends Blob_1.Blob {
    constructor(fileBits, name, options = {}){
        super(fileBits, options);
        _File_name.set(this, void 0);
        _File_lastModified.set(this, 0);
        if (arguments.length < 2) {
            throw new TypeError("Failed to construct 'File': 2 arguments required, " + `but only ${arguments.length} present.`);
        }
        __classPrivateFieldSet(this, _File_name, String(name), "f");
        const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
            __classPrivateFieldSet(this, _File_lastModified, lastModified, "f");
        }
    }
    static [(_File_name = new WeakMap(), _File_lastModified = new WeakMap(), Symbol.hasInstance)](value) {
        return value instanceof Blob_1.Blob && value[Symbol.toStringTag] === "File" && typeof value.name === "string";
    }
    get name() {
        return __classPrivateFieldGet(this, _File_name, "f");
    }
    get lastModified() {
        return __classPrivateFieldGet(this, _File_lastModified, "f");
    }
    get webkitRelativePath() {
        return "";
    }
    get [Symbol.toStringTag]() {
        return "File";
    }
}
exports.File = File;
}),
"[project]/node_modules/formdata-node/lib/cjs/isFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFile = void 0;
const File_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/File.js [app-route] (ecmascript)");
const isFile = (value)=>value instanceof File_1.File;
exports.isFile = isFile;
}),
"[project]/node_modules/formdata-node/lib/cjs/isBlob.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBlob = void 0;
const Blob_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/Blob.js [app-route] (ecmascript)");
const isBlob = (value)=>value instanceof Blob_1.Blob;
exports.isBlob = isBlob;
}),
"[project]/node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deprecateConstructorEntries = void 0;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
exports.deprecateConstructorEntries = (0, util_1.deprecate)(()=>{}, "Constructor \"entries\" argument is not spec-compliant " + "and will be removed in next major release.");
}),
"[project]/node_modules/formdata-node/lib/cjs/FormData.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormData_instances, _FormData_entries, _FormData_setEntry;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FormData = void 0;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const File_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/File.js [app-route] (ecmascript)");
const isFile_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isFile.js [app-route] (ecmascript)");
const isBlob_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isBlob.js [app-route] (ecmascript)");
const isFunction_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isFunction.js [app-route] (ecmascript)");
const deprecateConstructorEntries_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js [app-route] (ecmascript)");
class FormData {
    constructor(entries){
        _FormData_instances.add(this);
        _FormData_entries.set(this, new Map());
        if (entries) {
            (0, deprecateConstructorEntries_1.deprecateConstructorEntries)();
            entries.forEach(({ name, value, fileName })=>this.append(name, value, fileName));
        }
    }
    static [(_FormData_entries = new WeakMap(), _FormData_instances = new WeakSet(), Symbol.hasInstance)](value) {
        return Boolean(value && (0, isFunction_1.isFunction)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, isFunction_1.isFunction)(value.append) && (0, isFunction_1.isFunction)(value.set) && (0, isFunction_1.isFunction)(value.get) && (0, isFunction_1.isFunction)(value.getAll) && (0, isFunction_1.isFunction)(value.has) && (0, isFunction_1.isFunction)(value.delete) && (0, isFunction_1.isFunction)(value.entries) && (0, isFunction_1.isFunction)(value.values) && (0, isFunction_1.isFunction)(value.keys) && (0, isFunction_1.isFunction)(value[Symbol.iterator]) && (0, isFunction_1.isFunction)(value.forEach));
    }
    append(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
            name,
            fileName,
            append: true,
            rawValue: value,
            argsLength: arguments.length
        });
    }
    set(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
            name,
            fileName,
            append: false,
            rawValue: value,
            argsLength: arguments.length
        });
    }
    get(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
            return null;
        }
        return field[0];
    }
    getAll(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
            return [];
        }
        return field.slice();
    }
    has(name) {
        return __classPrivateFieldGet(this, _FormData_entries, "f").has(String(name));
    }
    delete(name) {
        __classPrivateFieldGet(this, _FormData_entries, "f").delete(String(name));
    }
    *keys() {
        for (const key of __classPrivateFieldGet(this, _FormData_entries, "f").keys()){
            yield key;
        }
    }
    *entries() {
        for (const name of this.keys()){
            const values = this.getAll(name);
            for (const value of values){
                yield [
                    name,
                    value
                ];
            }
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    [(_FormData_setEntry = function _FormData_setEntry({ name, rawValue, append, fileName, argsLength }) {
        const methodName = append ? "append" : "set";
        if (argsLength < 2) {
            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': ` + `2 arguments required, but only ${argsLength} present.`);
        }
        name = String(name);
        let value;
        if ((0, isFile_1.isFile)(rawValue)) {
            value = fileName === undefined ? rawValue : new File_1.File([
                rawValue
            ], fileName, {
                type: rawValue.type,
                lastModified: rawValue.lastModified
            });
        } else if ((0, isBlob_1.isBlob)(rawValue)) {
            value = new File_1.File([
                rawValue
            ], fileName === undefined ? "blob" : fileName, {
                type: rawValue.type
            });
        } else if (fileName) {
            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': ` + "parameter 2 is not of type 'Blob'.");
        } else {
            value = String(rawValue);
        }
        const values = __classPrivateFieldGet(this, _FormData_entries, "f").get(name);
        if (!values) {
            return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [
                value
            ]);
        }
        if (!append) {
            return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [
                value
            ]);
        }
        values.push(value);
    }, Symbol.iterator)]() {
        return this.entries();
    }
    forEach(callback, thisArg) {
        for (const [name, value] of this){
            callback.call(thisArg, value, name, this);
        }
    }
    get [Symbol.toStringTag]() {
        return "FormData";
    }
    [util_1.inspect.custom]() {
        return this[Symbol.toStringTag];
    }
}
exports.FormData = FormData;
}),
"[project]/node_modules/formdata-node/lib/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/FormData.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/Blob.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/File.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
    let size = 16;
    let res = "";
    while(size--){
        res += alphabet[Math.random() * alphabet.length << 0];
    }
    return res;
}
exports.default = createBoundary;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const getType = (value)=>Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject(value) {
    if (getType(value) !== "object") {
        return false;
    }
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) {
        return true;
    }
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
}
exports.default = isPlainObject;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const normalizeValue = (value)=>String(value).replace(/\r|\n/g, (match, i, str)=>{
        if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
            return "\r\n";
        }
        return match;
    });
exports.default = normalizeValue;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/escapeName.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const escapeName = (name)=>String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
exports.default = escapeName;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/isFunction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const isFunction = (value)=>typeof value === "function";
exports.default = isFunction;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFileLike = void 0;
const isFunction_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFunction.js [app-route] (ecmascript)"));
const isFileLike = (value)=>Boolean(value && typeof value === "object" && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "File" && (0, isFunction_1.default)(value.stream) && value.name != null && value.size != null && value.lastModified != null);
exports.isFileLike = isFileLike;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/util/isFormData.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFormDataLike = exports.isFormData = void 0;
const isFunction_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFunction.js [app-route] (ecmascript)"));
const isFormData = (value)=>Boolean(value && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, isFunction_1.default)(value.append) && (0, isFunction_1.default)(value.getAll) && (0, isFunction_1.default)(value.entries) && (0, isFunction_1.default)(value[Symbol.iterator]));
exports.isFormData = isFormData;
exports.isFormDataLike = exports.isFormData;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Encoder = exports.FormDataEncoder = void 0;
const createBoundary_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js [app-route] (ecmascript)"));
const isPlainObject_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js [app-route] (ecmascript)"));
const normalizeValue_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js [app-route] (ecmascript)"));
const escapeName_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/escapeName.js [app-route] (ecmascript)"));
const isFileLike_1 = __turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js [app-route] (ecmascript)");
const isFormData_1 = __turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFormData.js [app-route] (ecmascript)");
const defaultOptions = {
    enableAdditionalHeaders: false
};
class FormDataEncoder {
    constructor(form, boundaryOrOptions, options){
        _FormDataEncoder_instances.add(this);
        _FormDataEncoder_CRLF.set(this, "\r\n");
        _FormDataEncoder_CRLF_BYTES.set(this, void 0);
        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _FormDataEncoder_DASHES.set(this, "-".repeat(2));
        _FormDataEncoder_encoder.set(this, new TextEncoder());
        _FormDataEncoder_footer.set(this, void 0);
        _FormDataEncoder_form.set(this, void 0);
        _FormDataEncoder_options.set(this, void 0);
        if (!(0, isFormData_1.isFormData)(form)) {
            throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if ((0, isPlainObject_1.default)(boundaryOrOptions)) {
            options = boundaryOrOptions;
        } else {
            boundary = boundaryOrOptions;
        }
        if (!boundary) {
            boundary = (0, createBoundary_1.default)();
        }
        if (typeof boundary !== "string") {
            throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options && !(0, isPlainObject_1.default)(options)) {
            throw new TypeError("Expected options argument to be an object.");
        }
        __classPrivateFieldSet(this, _FormDataEncoder_form, form, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_options, {
            ...defaultOptions,
            ...options
        }, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        this.contentLength = String(this.getContentLength());
        this.headers = Object.freeze({
            "Content-Type": this.contentType,
            "Content-Length": this.contentLength
        });
        Object.defineProperties(this, {
            boundary: {
                writable: false,
                configurable: false
            },
            contentType: {
                writable: false,
                configurable: false
            },
            contentLength: {
                writable: false,
                configurable: false
            },
            headers: {
                writable: false,
                configurable: false
            }
        });
    }
    getContentLength() {
        let length = 0;
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")){
            const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
            length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
            length += (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;
            length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength;
    }
    *values() {
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f").entries()){
            const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
            yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
            yield value;
            yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
    }
    async *encode() {
        for (const part of this.values()){
            if ((0, isFileLike_1.isFileLike)(part)) {
                yield* part.stream();
            } else {
                yield part;
            }
        }
    }
    [(_FormDataEncoder_CRLF = new WeakMap(), _FormDataEncoder_CRLF_BYTES = new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), _FormDataEncoder_DASHES = new WeakMap(), _FormDataEncoder_encoder = new WeakMap(), _FormDataEncoder_footer = new WeakMap(), _FormDataEncoder_form = new WeakMap(), _FormDataEncoder_options = new WeakMap(), _FormDataEncoder_instances = new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0, escapeName_1.default)(name)}"`;
        if ((0, isFileLike_1.isFileLike)(value)) {
            header += `; filename="${(0, escapeName_1.default)(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
            header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
            header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${(0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength}`;
        }
        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
    }, Symbol.iterator)]() {
        return this.values();
    }
    [Symbol.asyncIterator]() {
        return this.encode();
    }
}
exports.FormDataEncoder = FormDataEncoder;
exports.Encoder = FormDataEncoder;
}),
"[project]/node_modules/form-data-encoder/lib/cjs/FileLike.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/form-data-encoder/lib/cjs/FormDataLike.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/form-data-encoder/lib/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/FileLike.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/FormDataLike.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/util/isFormData.js [app-route] (ecmascript)"), exports);
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/MultipartBody.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MultipartBody = void 0;
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */ class MultipartBody {
    constructor(body){
        this.body = body;
    }
    get [Symbol.toStringTag]() {
        return 'MultipartBody';
    }
}
exports.MultipartBody = MultipartBody; //# sourceMappingURL=MultipartBody.js.map
}),
"[project]/node_modules/node-domexception/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ if (!globalThis.DOMException) {
    try {
        const { MessageChannel } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)"), port = new MessageChannel().port1, ab = new ArrayBuffer();
        port.postMessage(ab, [
            ab,
            ab
        ]);
    } catch (err) {
        err.constructor.name === 'DOMException' && (globalThis.DOMException = err.constructor);
    }
}
module.exports = globalThis.DOMException;
}),
"[project]/node_modules/formdata-node/lib/cjs/isPlainObject.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const getType = (value)=>Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject(value) {
    if (getType(value) !== "object") {
        return false;
    }
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) {
        return true;
    }
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
}
exports.default = isPlainObject;
}),
"[project]/node_modules/formdata-node/lib/cjs/fileFromPath.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _FileFromPath_path, _FileFromPath_start;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fileFromPath = exports.fileFromPathSync = void 0;
const fs_1 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const path_1 = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const node_domexception_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/node-domexception/index.js [app-route] (ecmascript)"));
const File_1 = __turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/File.js [app-route] (ecmascript)");
const isPlainObject_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isPlainObject.js [app-route] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/isFile.js [app-route] (ecmascript)"), exports);
const MESSAGE = "The requested file could not be read, " + "typically due to permission problems that have occurred after a reference " + "to a file was acquired.";
class FileFromPath {
    constructor(input){
        _FileFromPath_path.set(this, void 0);
        _FileFromPath_start.set(this, void 0);
        __classPrivateFieldSet(this, _FileFromPath_path, input.path, "f");
        __classPrivateFieldSet(this, _FileFromPath_start, input.start || 0, "f");
        this.name = (0, path_1.basename)(__classPrivateFieldGet(this, _FileFromPath_path, "f"));
        this.size = input.size;
        this.lastModified = input.lastModified;
    }
    slice(start, end) {
        return new FileFromPath({
            path: __classPrivateFieldGet(this, _FileFromPath_path, "f"),
            lastModified: this.lastModified,
            size: end - start,
            start
        });
    }
    async *stream() {
        const { mtimeMs } = await fs_1.promises.stat(__classPrivateFieldGet(this, _FileFromPath_path, "f"));
        if (mtimeMs > this.lastModified) {
            throw new node_domexception_1.default(MESSAGE, "NotReadableError");
        }
        if (this.size) {
            yield* (0, fs_1.createReadStream)(__classPrivateFieldGet(this, _FileFromPath_path, "f"), {
                start: __classPrivateFieldGet(this, _FileFromPath_start, "f"),
                end: __classPrivateFieldGet(this, _FileFromPath_start, "f") + this.size - 1
            });
        }
    }
    get [(_FileFromPath_path = new WeakMap(), _FileFromPath_start = new WeakMap(), Symbol.toStringTag)]() {
        return "File";
    }
}
function createFileFromPath(path, { mtimeMs, size }, filenameOrOptions, options = {}) {
    let filename;
    if ((0, isPlainObject_1.default)(filenameOrOptions)) {
        [options, filename] = [
            filenameOrOptions,
            undefined
        ];
    } else {
        filename = filenameOrOptions;
    }
    const file = new FileFromPath({
        path,
        size,
        lastModified: mtimeMs
    });
    if (!filename) {
        filename = file.name;
    }
    return new File_1.File([
        file
    ], filename, {
        ...options,
        lastModified: file.lastModified
    });
}
function fileFromPathSync(path, filenameOrOptions, options = {}) {
    const stats = (0, fs_1.statSync)(path);
    return createFileFromPath(path, stats, filenameOrOptions, options);
}
exports.fileFromPathSync = fileFromPathSync;
async function fileFromPath(path, filenameOrOptions, options) {
    const stats = await fs_1.promises.stat(path);
    return createFileFromPath(path, stats, filenameOrOptions, options);
}
exports.fileFromPath = fileFromPath;
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/node-runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRuntime = void 0;
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */ const nf = __importStar(__turbopack_context__.r("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)"));
const fd = __importStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/index.js [app-route] (ecmascript)"));
const agentkeepalive_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/agentkeepalive/index.js [app-route] (ecmascript)"));
const abort_controller_1 = __turbopack_context__.r("[project]/node_modules/abort-controller/dist/abort-controller.js [app-route] (ecmascript)");
const node_fs_1 = __turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)");
const form_data_encoder_1 = __turbopack_context__.r("[project]/node_modules/form-data-encoder/lib/cjs/index.js [app-route] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const MultipartBody_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/MultipartBody.js [app-route] (ecmascript)");
const web_1 = __turbopack_context__.r("[externals]/node:stream/web [external] (node:stream/web, cjs)");
let fileFromPathWarned = false;
async function fileFromPath(path, ...args) {
    // this import fails in environments that don't handle export maps correctly, like old versions of Jest
    const { fileFromPath: _fileFromPath } = await Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/formdata-node/lib/cjs/fileFromPath.js [app-route] (ecmascript)")));
    if (!fileFromPathWarned) {
        console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path)}) instead`);
        fileFromPathWarned = true;
    }
    // @ts-ignore
    return await _fileFromPath(path, ...args);
}
const defaultHttpAgent = new agentkeepalive_1.default({
    keepAlive: true,
    timeout: 5 * 60 * 1000
});
const defaultHttpsAgent = new agentkeepalive_1.default.HttpsAgent({
    keepAlive: true,
    timeout: 5 * 60 * 1000
});
async function getMultipartRequestOptions(form, opts) {
    const encoder = new form_data_encoder_1.FormDataEncoder(form);
    const readable = node_stream_1.Readable.from(encoder);
    const body = new MultipartBody_1.MultipartBody(readable);
    const headers = {
        ...opts.headers,
        ...encoder.headers,
        'Content-Length': encoder.contentLength
    };
    return {
        ...opts,
        body: body,
        headers
    };
}
function getRuntime() {
    // Polyfill global object if needed.
    if (typeof AbortController === 'undefined') {
        // @ts-expect-error (the types are subtly different, but compatible in practice)
        globalThis.AbortController = abort_controller_1.AbortController;
    }
    return {
        kind: 'node',
        fetch: nf.default,
        Request: nf.Request,
        Response: nf.Response,
        Headers: nf.Headers,
        FormData: fd.FormData,
        Blob: fd.Blob,
        File: fd.File,
        ReadableStream: web_1.ReadableStream,
        getMultipartRequestOptions,
        getDefaultAgent: (url)=>url.startsWith('https') ? defaultHttpsAgent : defaultHttpAgent,
        fileFromPath,
        isFsReadStream: (value)=>value instanceof node_fs_1.ReadStream
    };
}
exports.getRuntime = getRuntime; //# sourceMappingURL=node-runtime.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/auto/runtime-node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */ __exportStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/node-runtime.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=runtime-node.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */ const shims = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/registry.js [app-route] (ecmascript)");
const auto = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/auto/runtime-node.js [app-route] (ecmascript)");
exports.init = ()=>{
    if (!shims.kind) shims.setShims(auto.getRuntime(), {
        auto: true
    });
};
for (const property of Object.keys(shims)){
    Object.defineProperty(exports, property, {
        get () {
            return shims[property];
        }
    });
}
exports.init();
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContentFilterFinishReasonError = exports.LengthFinishReasonError = exports.InternalServerError = exports.RateLimitError = exports.UnprocessableEntityError = exports.ConflictError = exports.NotFoundError = exports.PermissionDeniedError = exports.AuthenticationError = exports.BadRequestError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIUserAbortError = exports.APIError = exports.OpenAIError = void 0;
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
class OpenAIError extends Error {
}
exports.OpenAIError = OpenAIError;
class APIError extends OpenAIError {
    constructor(status, error, message, headers){
        super(`${APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.request_id = headers?.['x-request-id'];
        this.error = error;
        const data = error;
        this.code = data?.['code'];
        this.param = data?.['param'];
        this.type = data?.['type'];
    }
    static makeMessage(status, error, message) {
        const msg = error?.message ? typeof error.message === 'string' ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
            return `${status} ${msg}`;
        }
        if (status) {
            return `${status} status code (no body)`;
        }
        if (msg) {
            return msg;
        }
        return '(no status code or body)';
    }
    static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
            return new APIConnectionError({
                message,
                cause: (0, core_1.castToError)(errorResponse)
            });
        }
        const error = errorResponse?.['error'];
        if (status === 400) {
            return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
            return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
            return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
            return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
            return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
            return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
            return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
            return new InternalServerError(status, error, message, headers);
        }
        return new APIError(status, error, message, headers);
    }
}
exports.APIError = APIError;
class APIUserAbortError extends APIError {
    constructor({ message } = {}){
        super(undefined, undefined, message || 'Request was aborted.', undefined);
    }
}
exports.APIUserAbortError = APIUserAbortError;
class APIConnectionError extends APIError {
    constructor({ message, cause }){
        super(undefined, undefined, message || 'Connection error.', undefined);
        // in some environments the 'cause' property is already declared
        // @ts-ignore
        if (cause) this.cause = cause;
    }
}
exports.APIConnectionError = APIConnectionError;
class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message } = {}){
        super({
            message: message ?? 'Request timed out.'
        });
    }
}
exports.APIConnectionTimeoutError = APIConnectionTimeoutError;
class BadRequestError extends APIError {
}
exports.BadRequestError = BadRequestError;
class AuthenticationError extends APIError {
}
exports.AuthenticationError = AuthenticationError;
class PermissionDeniedError extends APIError {
}
exports.PermissionDeniedError = PermissionDeniedError;
class NotFoundError extends APIError {
}
exports.NotFoundError = NotFoundError;
class ConflictError extends APIError {
}
exports.ConflictError = ConflictError;
class UnprocessableEntityError extends APIError {
}
exports.UnprocessableEntityError = UnprocessableEntityError;
class RateLimitError extends APIError {
}
exports.RateLimitError = RateLimitError;
class InternalServerError extends APIError {
}
exports.InternalServerError = InternalServerError;
class LengthFinishReasonError extends OpenAIError {
    constructor(){
        super(`Could not parse response content as the length limit was reached`);
    }
}
exports.LengthFinishReasonError = LengthFinishReasonError;
class ContentFilterFinishReasonError extends OpenAIError {
    constructor(){
        super(`Could not parse response content as the request was rejected by the content filter`);
    }
}
exports.ContentFilterFinishReasonError = ContentFilterFinishReasonError; //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/decoders/line.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findDoubleNewlineIndex = exports.LineDecoder = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
/**
 * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally
 * reading lines from text.
 *
 * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
 */ class LineDecoder {
    constructor(){
        _LineDecoder_carriageReturnIndex.set(this, void 0);
        this.buffer = new Uint8Array();
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    decode(chunk) {
        if (chunk == null) {
            return [];
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? new TextEncoder().encode(chunk) : chunk;
        let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
        newData.set(this.buffer);
        newData.set(binaryChunk, this.buffer.length);
        this.buffer = newData;
        const lines = [];
        let patternIndex;
        while((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null){
            if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
                // skip until we either get a corresponding `\n`, a new `\r` or nothing
                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
                continue;
            }
            // we got double \r or \rtext\n
            if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
                lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
                this.buffer = this.buffer.slice(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"));
                __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
                continue;
            }
            const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
            const line = this.decodeText(this.buffer.slice(0, endIndex));
            lines.push(line);
            this.buffer = this.buffer.slice(patternIndex.index);
            __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        }
        return lines;
    }
    decodeText(bytes) {
        if (bytes == null) return '';
        if (typeof bytes === 'string') return bytes;
        // Node:
        if (typeof Buffer !== 'undefined') {
            if (bytes instanceof Buffer) {
                return bytes.toString();
            }
            if (bytes instanceof Uint8Array) {
                return Buffer.from(bytes).toString();
            }
            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
        }
        // Browser
        if (typeof TextDecoder !== 'undefined') {
            if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
                this.textDecoder ?? (this.textDecoder = new TextDecoder('utf8'));
                return this.textDecoder.decode(bytes);
            }
            throw new error_1.OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
        }
        throw new error_1.OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
    }
    flush() {
        if (!this.buffer.length) {
            return [];
        }
        return this.decode('\n');
    }
}
exports.LineDecoder = LineDecoder;
_LineDecoder_carriageReturnIndex = new WeakMap();
// prettier-ignore
LineDecoder.NEWLINE_CHARS = new Set([
    '\n',
    '\r'
]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
/**
 * This function searches the buffer for the end patterns, (\r or \n)
 * and returns an object with the index preceding the matched newline and the
 * index after the newline char. `null` is returned if no new line is found.
 *
 * ```ts
 * findNewLineIndex('abc\ndef') -> { preceding: 2, index: 3 }
 * ```
 */ function findNewlineIndex(buffer, startIndex) {
    const newline = 0x0a; // \n
    const carriage = 0x0d; // \r
    for(let i = startIndex ?? 0; i < buffer.length; i++){
        if (buffer[i] === newline) {
            return {
                preceding: i,
                index: i + 1,
                carriage: false
            };
        }
        if (buffer[i] === carriage) {
            return {
                preceding: i,
                index: i + 1,
                carriage: true
            };
        }
    }
    return null;
}
function findDoubleNewlineIndex(buffer) {
    // This function searches the buffer for the end patterns (\r\r, \n\n, \r\n\r\n)
    // and returns the index right after the first occurrence of any pattern,
    // or -1 if none of the patterns are found.
    const newline = 0x0a; // \n
    const carriage = 0x0d; // \r
    for(let i = 0; i < buffer.length - 1; i++){
        if (buffer[i] === newline && buffer[i + 1] === newline) {
            // \n\n
            return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === carriage) {
            // \r\r
            return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
            // \r\n\r\n
            return i + 4;
        }
    }
    return -1;
}
exports.findDoubleNewlineIndex = findDoubleNewlineIndex; //# sourceMappingURL=line.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/stream-utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReadableStreamToAsyncIterable = void 0;
/**
 * Most browsers don't yet have async iterable support for ReadableStream,
 * and Node has a very different way of reading bytes from its "ReadableStream".
 *
 * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */ function ReadableStreamToAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator]) return stream;
    const reader = stream.getReader();
    return {
        async next () {
            try {
                const result = await reader.read();
                if (result?.done) reader.releaseLock(); // release lock when stream becomes closed
                return result;
            } catch (e) {
                reader.releaseLock(); // release lock when stream becomes errored
                throw e;
            }
        },
        async return () {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            await cancelPromise;
            return {
                done: true,
                value: undefined
            };
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
exports.ReadableStreamToAsyncIterable = ReadableStreamToAsyncIterable; //# sourceMappingURL=stream-utils.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/streaming.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._iterSSEMessages = exports.Stream = void 0;
const index_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/index.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const line_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/decoders/line.js [app-route] (ecmascript)");
const stream_utils_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/stream-utils.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const error_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
class Stream {
    constructor(iterator, controller){
        this.iterator = iterator;
        this.controller = controller;
    }
    static fromSSEResponse(response, controller) {
        let consumed = false;
        async function* iterator() {
            if (consumed) {
                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
            }
            consumed = true;
            let done = false;
            try {
                for await (const sse of _iterSSEMessages(response, controller)){
                    if (done) continue;
                    if (sse.data.startsWith('[DONE]')) {
                        done = true;
                        continue;
                    }
                    if (sse.event === null || sse.event.startsWith('response.') || sse.event.startsWith('transcript.')) {
                        let data;
                        try {
                            data = JSON.parse(sse.data);
                        } catch (e) {
                            console.error(`Could not parse message into JSON:`, sse.data);
                            console.error(`From chunk:`, sse.raw);
                            throw e;
                        }
                        if (data && data.error) {
                            throw new error_2.APIError(undefined, data.error, undefined, (0, core_1.createResponseHeaders)(response.headers));
                        }
                        yield data;
                    } else {
                        let data;
                        try {
                            data = JSON.parse(sse.data);
                        } catch (e) {
                            console.error(`Could not parse message into JSON:`, sse.data);
                            console.error(`From chunk:`, sse.raw);
                            throw e;
                        }
                        // TODO: Is this where the error should be thrown?
                        if (sse.event == 'error') {
                            throw new error_2.APIError(undefined, data.error, data.message, undefined);
                        }
                        yield {
                            event: sse.event,
                            data: data
                        };
                    }
                }
                done = true;
            } catch (e) {
                // If the user calls `stream.controller.abort()`, we should exit without throwing.
                if (e instanceof Error && e.name === 'AbortError') return;
                throw e;
            } finally{
                // If the user `break`s, abort the ongoing request.
                if (!done) controller.abort();
            }
        }
        return new Stream(iterator, controller);
    }
    /**
     * Generates a Stream from a newline-separated ReadableStream
     * where each item is a JSON value.
     */ static fromReadableStream(readableStream, controller) {
        let consumed = false;
        async function* iterLines() {
            const lineDecoder = new line_1.LineDecoder();
            const iter = (0, stream_utils_1.ReadableStreamToAsyncIterable)(readableStream);
            for await (const chunk of iter){
                for (const line of lineDecoder.decode(chunk)){
                    yield line;
                }
            }
            for (const line of lineDecoder.flush()){
                yield line;
            }
        }
        async function* iterator() {
            if (consumed) {
                throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
            }
            consumed = true;
            let done = false;
            try {
                for await (const line of iterLines()){
                    if (done) continue;
                    if (line) yield JSON.parse(line);
                }
                done = true;
            } catch (e) {
                // If the user calls `stream.controller.abort()`, we should exit without throwing.
                if (e instanceof Error && e.name === 'AbortError') return;
                throw e;
            } finally{
                // If the user `break`s, abort the ongoing request.
                if (!done) controller.abort();
            }
        }
        return new Stream(iterator, controller);
    }
    [Symbol.asyncIterator]() {
        return this.iterator();
    }
    /**
     * Splits the stream into two streams which can be
     * independently read from at different speeds.
     */ tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue)=>{
            return {
                next: ()=>{
                    if (queue.length === 0) {
                        const result = iterator.next();
                        left.push(result);
                        right.push(result);
                    }
                    return queue.shift();
                }
            };
        };
        return [
            new Stream(()=>teeIterator(left), this.controller),
            new Stream(()=>teeIterator(right), this.controller)
        ];
    }
    /**
     * Converts this stream to a newline-separated ReadableStream of
     * JSON stringified values in the stream
     * which can be turned back into a Stream with `Stream.fromReadableStream()`.
     */ toReadableStream() {
        const self = this;
        let iter;
        const encoder = new TextEncoder();
        return new index_1.ReadableStream({
            async start () {
                iter = self[Symbol.asyncIterator]();
            },
            async pull (ctrl) {
                try {
                    const { value, done } = await iter.next();
                    if (done) return ctrl.close();
                    const bytes = encoder.encode(JSON.stringify(value) + '\n');
                    ctrl.enqueue(bytes);
                } catch (err) {
                    ctrl.error(err);
                }
            },
            async cancel () {
                await iter.return?.();
            }
        });
    }
}
exports.Stream = Stream;
async function* _iterSSEMessages(response, controller) {
    if (!response.body) {
        controller.abort();
        throw new error_1.OpenAIError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder();
    const lineDecoder = new line_1.LineDecoder();
    const iter = (0, stream_utils_1.ReadableStreamToAsyncIterable)(response.body);
    for await (const sseChunk of iterSSEChunks(iter)){
        for (const line of lineDecoder.decode(sseChunk)){
            const sse = sseDecoder.decode(line);
            if (sse) yield sse;
        }
    }
    for (const line of lineDecoder.flush()){
        const sse = sseDecoder.decode(line);
        if (sse) yield sse;
    }
}
exports._iterSSEMessages = _iterSSEMessages;
/**
 * Given an async iterable iterator, iterates over it and yields full
 * SSE chunks, i.e. yields when a double new-line is encountered.
 */ async function* iterSSEChunks(iterator) {
    let data = new Uint8Array();
    for await (const chunk of iterator){
        if (chunk == null) {
            continue;
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? new TextEncoder().encode(chunk) : chunk;
        let newData = new Uint8Array(data.length + binaryChunk.length);
        newData.set(data);
        newData.set(binaryChunk, data.length);
        data = newData;
        let patternIndex;
        while((patternIndex = (0, line_1.findDoubleNewlineIndex)(data)) !== -1){
            yield data.slice(0, patternIndex);
            data = data.slice(patternIndex);
        }
    }
    if (data.length > 0) {
        yield data;
    }
}
class SSEDecoder {
    constructor(){
        this.event = null;
        this.data = [];
        this.chunks = [];
    }
    decode(line) {
        if (line.endsWith('\r')) {
            line = line.substring(0, line.length - 1);
        }
        if (!line) {
            // empty line and we didn't previously encounter any messages
            if (!this.event && !this.data.length) return null;
            const sse = {
                event: this.event,
                data: this.data.join('\n'),
                raw: this.chunks
            };
            this.event = null;
            this.data = [];
            this.chunks = [];
            return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(':')) {
            return null;
        }
        let [fieldname, _, value] = partition(line, ':');
        if (value.startsWith(' ')) {
            value = value.substring(1);
        }
        if (fieldname === 'event') {
            this.event = value;
        } else if (fieldname === 'data') {
            this.data.push(value);
        }
        return null;
    }
}
function partition(str, delimiter) {
    const index = str.indexOf(delimiter);
    if (index !== -1) {
        return [
            str.substring(0, index),
            delimiter,
            str.substring(index + delimiter.length)
        ];
    }
    return [
        str,
        '',
        ''
    ];
} //# sourceMappingURL=streaming.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/uploads.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isMultipartBody = exports.toFile = exports.isUploadable = exports.isBlobLike = exports.isFileLike = exports.isResponseLike = exports.fileFromPath = void 0;
const index_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/index.js [app-route] (ecmascript)");
var index_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "fileFromPath", {
    enumerable: true,
    get: function() {
        return index_2.fileFromPath;
    }
});
const isResponseLike = (value)=>value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';
exports.isResponseLike = isResponseLike;
const isFileLike = (value)=>value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && (0, exports.isBlobLike)(value);
exports.isFileLike = isFileLike;
/**
 * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check
 * adds the arrayBuffer() method type because it is available and used at runtime
 */ const isBlobLike = (value)=>value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';
exports.isBlobLike = isBlobLike;
const isUploadable = (value)=>{
    return (0, exports.isFileLike)(value) || (0, exports.isResponseLike)(value) || (0, index_1.isFsReadStream)(value);
};
exports.isUploadable = isUploadable;
/**
 * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats
 * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s
 * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible
 * @param {Object=} options additional properties
 * @param {string=} options.type the MIME type of the content
 * @param {number=} options.lastModified the last modified timestamp
 * @returns a {@link File} with the given properties
 */ async function toFile(value, name, options) {
    // If it's a promise, resolve it.
    value = await value;
    // If we've been given a `File` we don't need to do anything
    if ((0, exports.isFileLike)(value)) {
        return value;
    }
    if ((0, exports.isResponseLike)(value)) {
        const blob = await value.blob();
        name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? 'unknown_file');
        // we need to convert the `Blob` into an array buffer because the `Blob` class
        // that `node-fetch` defines is incompatible with the web standard which results
        // in `new File` interpreting it as a string instead of binary data.
        const data = (0, exports.isBlobLike)(blob) ? [
            await blob.arrayBuffer()
        ] : [
            blob
        ];
        return new index_1.File(data, name, options);
    }
    const bits = await getBytes(value);
    name || (name = getName(value) ?? 'unknown_file');
    if (!options?.type) {
        const type = bits[0]?.type;
        if (typeof type === 'string') {
            options = {
                ...options,
                type
            };
        }
    }
    return new index_1.File(bits, name, options);
}
exports.toFile = toFile;
async function getBytes(value) {
    let parts = [];
    if (typeof value === 'string' || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer) {
        parts.push(value);
    } else if ((0, exports.isBlobLike)(value)) {
        parts.push(await value.arrayBuffer());
    } else if (isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.
    ) {
        for await (const chunk of value){
            parts.push(chunk); // TODO, consider validating?
        }
    } else {
        throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
    }
    return parts;
}
function propsForError(value) {
    const props = Object.getOwnPropertyNames(value);
    return `[${props.map((p)=>`"${p}"`).join(', ')}]`;
}
function getName(value) {
    return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
    getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
const getStringFromMaybeBuffer = (x)=>{
    if (typeof x === 'string') return x;
    if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);
    return undefined;
};
const isAsyncIterableIterator = (value)=>value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';
const isMultipartBody = (body)=>body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';
exports.isMultipartBody = isMultipartBody;
/**
 * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.
 * Otherwise returns the request as is.
 */ const maybeMultipartFormRequestOptions = async (opts)=>{
    if (!hasUploadableValue(opts.body)) return opts;
    const form = await (0, exports.createForm)(opts.body);
    return (0, index_1.getMultipartRequestOptions)(form, opts);
};
exports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;
const multipartFormRequestOptions = async (opts)=>{
    const form = await (0, exports.createForm)(opts.body);
    return (0, index_1.getMultipartRequestOptions)(form, opts);
};
exports.multipartFormRequestOptions = multipartFormRequestOptions;
const createForm = async (body)=>{
    const form = new index_1.FormData();
    await Promise.all(Object.entries(body || {}).map(([key, value])=>addFormValue(form, key, value)));
    return form;
};
exports.createForm = createForm;
const hasUploadableValue = (value)=>{
    if ((0, exports.isUploadable)(value)) return true;
    if (Array.isArray(value)) return value.some(hasUploadableValue);
    if (value && typeof value === 'object') {
        for(const k in value){
            if (hasUploadableValue(value[k])) return true;
        }
    }
    return false;
};
const addFormValue = async (form, key, value)=>{
    if (value === undefined) return;
    if (value == null) {
        throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
    }
    // TODO: make nested formats configurable
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        form.append(key, String(value));
    } else if ((0, exports.isUploadable)(value)) {
        const file = await toFile(value);
        form.append(key, file);
    } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry)=>addFormValue(form, key + '[]', entry)));
    } else if (typeof value === 'object') {
        await Promise.all(Object.entries(value).map(([name, prop])=>addFormValue(form, `${key}[${name}]`, prop)));
    } else {
        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
    }
}; //# sourceMappingURL=uploads.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isObj = exports.toFloat32Array = exports.toBase64 = exports.getHeader = exports.getRequiredHeader = exports.isHeadersProtocol = exports.isRunningInBrowser = exports.debug = exports.hasOwn = exports.isEmptyObj = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.readEnv = exports.ensurePresent = exports.castToError = exports.sleep = exports.safeJSON = exports.isRequestOptions = exports.createResponseHeaders = exports.PagePromise = exports.AbstractPage = exports.APIClient = exports.APIPromise = exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = void 0;
const version_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/version.js [app-route] (ecmascript)");
const streaming_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/streaming.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_shims/index.js [app-route] (ecmascript)");
// try running side effects outside of _shims/index to workaround https://github.com/vercel/next.js/issues/76881
(0, index_1.init)();
const uploads_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/uploads.js [app-route] (ecmascript)");
var uploads_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/uploads.js [app-route] (ecmascript)");
Object.defineProperty(exports, "maybeMultipartFormRequestOptions", {
    enumerable: true,
    get: function() {
        return uploads_2.maybeMultipartFormRequestOptions;
    }
});
Object.defineProperty(exports, "multipartFormRequestOptions", {
    enumerable: true,
    get: function() {
        return uploads_2.multipartFormRequestOptions;
    }
});
Object.defineProperty(exports, "createForm", {
    enumerable: true,
    get: function() {
        return uploads_2.createForm;
    }
});
async function defaultParseResponse(props) {
    const { response } = props;
    if (props.options.stream) {
        debug('response', response.status, response.url, response.headers, response.body);
        // Note: there is an invariant here that isn't represented in the type system
        // that if you set `stream: true` the response type must also be `Stream<T>`
        if (props.options.__streamClass) {
            return props.options.__streamClass.fromSSEResponse(response, props.controller);
        }
        return streaming_1.Stream.fromSSEResponse(response, props.controller);
    }
    // fetch refuses to read the body when the status code is 204.
    if (response.status === 204) {
        return null;
    }
    if (props.options.__binaryResponse) {
        return response;
    }
    const contentType = response.headers.get('content-type');
    const mediaType = contentType?.split(';')[0]?.trim();
    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');
    if (isJSON) {
        const json = await response.json();
        debug('response', response.status, response.url, response.headers, json);
        return _addRequestID(json, response);
    }
    const text = await response.text();
    debug('response', response.status, response.url, response.headers, text);
    // TODO handle blob, arraybuffer, other content types, etc.
    return text;
}
function _addRequestID(value, response) {
    if (!value || typeof value !== 'object' || Array.isArray(value)) {
        return value;
    }
    return Object.defineProperty(value, '_request_id', {
        value: response.headers.get('x-request-id'),
        enumerable: false
    });
}
/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */ class APIPromise extends Promise {
    constructor(responsePromise, parseResponse = defaultParseResponse){
        super((resolve)=>{
            // this is maybe a bit weird but this has to be a no-op to not implicitly
            // parse the response body; instead .then, .catch, .finally are overridden
            // to parse the response
            resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
    }
    _thenUnwrap(transform) {
        return new APIPromise(this.responsePromise, async (props)=>_addRequestID(transform(await this.parseResponse(props), props), props.response));
    }
    /**
     * Gets the raw `Response` instance instead of parsing the response
     * data.
     *
     * If you want to parse the response body but still get the `Response`
     * instance, you can use {@link withResponse()}.
     *
     *  Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import  from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */ asResponse() {
        return this.responsePromise.then((p)=>p.response);
    }
    /**
     * Gets the parsed response data, the raw `Response` instance and the ID of the request,
     * returned via the X-Request-ID header which is useful for debugging requests and reporting
     * issues to OpenAI.
     *
     * If you just want to get the raw `Response` instance without parsing it,
     * you can use {@link asResponse()}.
     *
     *
     *  Getting the wrong TypeScript type for `Response`?
     * Try setting `"moduleResolution": "NodeNext"` if you can,
     * or add one of these imports before your first `import  from 'openai'`:
     * - `import 'openai/shims/node'` (if you're running on Node)
     * - `import 'openai/shims/web'` (otherwise)
     */ async withResponse() {
        const [data, response] = await Promise.all([
            this.parse(),
            this.asResponse()
        ]);
        return {
            data,
            response,
            request_id: response.headers.get('x-request-id')
        };
    }
    parse() {
        if (!this.parsedPromise) {
            this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
    }
    then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.parse().catch(onrejected);
    }
    finally(onfinally) {
        return this.parse().finally(onfinally);
    }
}
exports.APIPromise = APIPromise;
class APIClient {
    constructor({ baseURL, maxRetries = 2, timeout = 600000, httpAgent, fetch: overriddenFetch }){
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);
        this.timeout = validatePositiveInteger('timeout', timeout);
        this.httpAgent = httpAgent;
        this.fetch = overriddenFetch ?? index_1.fetch;
    }
    authHeaders(opts) {
        return {};
    }
    /**
     * Override this to add your own default headers, for example:
     *
     *  {
     *    ...super.defaultHeaders(),
     *    Authorization: 'Bearer 123',
     *  }
     */ defaultHeaders(opts) {
        return {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'User-Agent': this.getUserAgent(),
            ...getPlatformHeaders(),
            ...this.authHeaders(opts)
        };
    }
    /**
     * Override this to add your own headers validation:
     */ validateHeaders(headers, customHeaders) {}
    defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
    }
    get(path, opts) {
        return this.methodRequest('get', path, opts);
    }
    post(path, opts) {
        return this.methodRequest('post', path, opts);
    }
    patch(path, opts) {
        return this.methodRequest('patch', path, opts);
    }
    put(path, opts) {
        return this.methodRequest('put', path, opts);
    }
    delete(path, opts) {
        return this.methodRequest('delete', path, opts);
    }
    methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then(async (opts)=>{
            const body = opts && (0, uploads_1.isBlobLike)(opts?.body) ? new DataView(await opts.body.arrayBuffer()) : opts?.body instanceof DataView ? opts.body : opts?.body instanceof ArrayBuffer ? new DataView(opts.body) : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer) : opts?.body;
            return {
                method,
                path,
                ...opts,
                body
            };
        }));
    }
    getAPIList(path, Page, opts) {
        return this.requestAPIList(Page, {
            method: 'get',
            path,
            ...opts
        });
    }
    calculateContentLength(body) {
        if (typeof body === 'string') {
            if (typeof Buffer !== 'undefined') {
                return Buffer.byteLength(body, 'utf8').toString();
            }
            if (typeof TextEncoder !== 'undefined') {
                const encoder = new TextEncoder();
                const encoded = encoder.encode(body);
                return encoded.length.toString();
            }
        } else if (ArrayBuffer.isView(body)) {
            return body.byteLength.toString();
        }
        return null;
    }
    buildRequest(inputOptions, { retryCount = 0 } = {}) {
        const options = {
            ...inputOptions
        };
        const { method, path, query, headers: headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === 'string' ? options.body : (0, uploads_1.isMultipartBody)(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path, query);
        if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);
        options.timeout = options.timeout ?? this.timeout;
        const httpAgent = options.httpAgent ?? this.httpAgent ?? (0, index_1.getDefaultAgent)(url);
        const minAgentTimeout = options.timeout + 1000;
        if (typeof httpAgent?.options?.timeout === 'number' && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
            // Allow any given request to bump our agent active socket timeout.
            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,
            // and without mutating agent we would need to create more of them.
            // This tradeoff optimizes for performance.
            httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== 'get') {
            if (!inputOptions.idempotencyKey) inputOptions.idempotencyKey = this.defaultIdempotencyKey();
            headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({
            options,
            headers,
            contentLength,
            retryCount
        });
        const req = {
            method,
            ...body && {
                body: body
            },
            headers: reqHeaders,
            ...httpAgent && {
                agent: httpAgent
            },
            // @ts-ignore node-fetch uses a custom AbortSignal type that is
            // not compatible with standard web types
            signal: options.signal ?? null
        };
        return {
            req,
            url,
            timeout: options.timeout
        };
    }
    buildHeaders({ options, headers, contentLength, retryCount }) {
        const reqHeaders = {};
        if (contentLength) {
            reqHeaders['content-length'] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        // let builtin fetch set the Content-Type for multipart bodies
        if ((0, uploads_1.isMultipartBody)(options.body) && index_1.kind !== 'node') {
            delete reqHeaders['content-type'];
        }
        // Don't set theses headers if they were already set or removed through default headers or by the caller.
        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account
        // for the removal case.
        if ((0, exports.getHeader)(defaultHeaders, 'x-stainless-retry-count') === undefined && (0, exports.getHeader)(headers, 'x-stainless-retry-count') === undefined) {
            reqHeaders['x-stainless-retry-count'] = String(retryCount);
        }
        if ((0, exports.getHeader)(defaultHeaders, 'x-stainless-timeout') === undefined && (0, exports.getHeader)(headers, 'x-stainless-timeout') === undefined && options.timeout) {
            reqHeaders['x-stainless-timeout'] = String(Math.trunc(options.timeout / 1000));
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
    }
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */ async prepareOptions(options) {}
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */ async prepareRequest(request, { url, options }) {}
    parseHeaders(headers) {
        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header)=>[
                ...header
            ])) : {
            ...headers
        };
    }
    makeStatusError(status, error, message, headers) {
        return error_1.APIError.generate(status, error, message, headers);
    }
    request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
    }
    async makeRequest(optionsInput, retriesRemaining) {
        const options = await optionsInput;
        const maxRetries = options.maxRetries ?? this.maxRetries;
        if (retriesRemaining == null) {
            retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options, {
            retryCount: maxRetries - retriesRemaining
        });
        await this.prepareRequest(req, {
            url,
            options
        });
        debug('request', url, options, req.headers);
        if (options.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(exports.castToError);
        if (response instanceof Error) {
            if (options.signal?.aborted) {
                throw new error_1.APIUserAbortError();
            }
            if (retriesRemaining) {
                return this.retryRequest(options, retriesRemaining);
            }
            if (response.name === 'AbortError') {
                throw new error_1.APIConnectionTimeoutError();
            }
            throw new error_1.APIConnectionError({
                cause: response
            });
        }
        const responseHeaders = (0, exports.createResponseHeaders)(response.headers);
        if (!response.ok) {
            if (retriesRemaining && this.shouldRetry(response)) {
                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);
                return this.retryRequest(options, retriesRemaining, responseHeaders);
            }
            const errText = await response.text().catch((e)=>(0, exports.castToError)(e).message);
            const errJSON = (0, exports.safeJSON)(errText);
            const errMessage = errJSON ? undefined : errText;
            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
            throw err;
        }
        return {
            response,
            options,
            controller
        };
    }
    requestAPIList(Page, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page);
    }
    buildURL(path, query) {
        const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
            query = {
                ...defaultQuery,
                ...query
            };
        }
        if (typeof query === 'object' && query && !Array.isArray(query)) {
            url.search = this.stringifyQuery(query);
        }
        return url.toString();
    }
    stringifyQuery(query) {
        return Object.entries(query).filter(([_, value])=>typeof value !== 'undefined').map(([key, value])=>{
            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
            }
            if (value === null) {
                return `${encodeURIComponent(key)}=`;
            }
            throw new error_1.OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join('&');
    }
    async fetchWithTimeout(url, init, ms, controller) {
        const { signal, ...options } = init || {};
        if (signal) signal.addEventListener('abort', ()=>controller.abort());
        const timeout = setTimeout(()=>controller.abort(), ms);
        const fetchOptions = {
            signal: controller.signal,
            ...options
        };
        if (fetchOptions.method) {
            // Custom methods like 'patch' need to be uppercased
            // See https://github.com/nodejs/undici/issues/2294
            fetchOptions.method = fetchOptions.method.toUpperCase();
        }
        return(// use undefined this binding; fetch errors if bound to something else in browser/cloudflare
        this.fetch.call(undefined, url, fetchOptions).finally(()=>{
            clearTimeout(timeout);
        }));
    }
    shouldRetry(response) {
        // Note this is not a standard header.
        const shouldRetryHeader = response.headers.get('x-should-retry');
        // If the server explicitly says whether or not to retry, obey.
        if (shouldRetryHeader === 'true') return true;
        if (shouldRetryHeader === 'false') return false;
        // Retry on request timeouts.
        if (response.status === 408) return true;
        // Retry on lock timeouts.
        if (response.status === 409) return true;
        // Retry on rate limits.
        if (response.status === 429) return true;
        // Retry internal errors.
        if (response.status >= 500) return true;
        return false;
    }
    async retryRequest(options, retriesRemaining, responseHeaders) {
        let timeoutMillis;
        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.
        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];
        if (retryAfterMillisHeader) {
            const timeoutMs = parseFloat(retryAfterMillisHeader);
            if (!Number.isNaN(timeoutMs)) {
                timeoutMillis = timeoutMs;
            }
        }
        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
        const retryAfterHeader = responseHeaders?.['retry-after'];
        if (retryAfterHeader && !timeoutMillis) {
            const timeoutSeconds = parseFloat(retryAfterHeader);
            if (!Number.isNaN(timeoutSeconds)) {
                timeoutMillis = timeoutSeconds * 1000;
            } else {
                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
            }
        }
        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),
        // just do what it says, but otherwise calculate a default
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
            const maxRetries = options.maxRetries ?? this.maxRetries;
            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await (0, exports.sleep)(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
    }
    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8.0;
        const numRetries = maxRetries - retriesRemaining;
        // Apply exponential backoff, but not more than the max.
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        // Apply some jitter, take up to at most 25 percent of the retry time.
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1000;
    }
    getUserAgent() {
        return `${this.constructor.name}/JS ${version_1.VERSION}`;
    }
}
exports.APIClient = APIClient;
class AbstractPage {
    constructor(client, response, body, options){
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
    }
    hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length) return false;
        return this.nextPageInfo() != null;
    }
    async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
            throw new error_1.OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');
        }
        const nextOptions = {
            ...this.options
        };
        if ('params' in nextInfo && typeof nextOptions.query === 'object') {
            nextOptions.query = {
                ...nextOptions.query,
                ...nextInfo.params
            };
        } else if ('url' in nextInfo) {
            const params = [
                ...Object.entries(nextOptions.query || {}),
                ...nextInfo.url.searchParams.entries()
            ];
            for (const [key, value] of params){
                nextInfo.url.searchParams.set(key, value);
            }
            nextOptions.query = undefined;
            nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
    }
    async *iterPages() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let page = this;
        yield page;
        while(page.hasNextPage()){
            page = await page.getNextPage();
            yield page;
        }
    }
    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()){
            for (const item of page.getPaginatedItems()){
                yield item;
            }
        }
    }
}
exports.AbstractPage = AbstractPage;
/**
 * This subclass of Promise will resolve to an instantiated Page once the request completes.
 *
 * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
 *
 *    for await (const item of client.items.list()) {
 *      console.log(item)
 *    }
 */ class PagePromise extends APIPromise {
    constructor(client, request, Page){
        super(request, async (props)=>new Page(client, props.response, await defaultParseResponse(props), props.options));
    }
    /**
     * Allow auto-paginating iteration on an unawaited list call, eg:
     *
     *    for await (const item of client.items.list()) {
     *      console.log(item)
     *    }
     */ async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page){
            yield item;
        }
    }
}
exports.PagePromise = PagePromise;
const createResponseHeaders = (headers)=>{
    return new Proxy(Object.fromEntries(// @ts-ignore
    headers.entries()), {
        get (target, name) {
            const key = name.toString();
            return target[key.toLowerCase()] || target[key];
        }
    });
};
exports.createResponseHeaders = createResponseHeaders;
// This is required so that we can determine if a given object matches the RequestOptions
// type at runtime. While this requires duplication, it is enforced by the TypeScript
// compiler such that any missing / extraneous keys will cause an error.
const requestOptionsKeys = {
    method: true,
    path: true,
    query: true,
    body: true,
    headers: true,
    maxRetries: true,
    stream: true,
    timeout: true,
    httpAgent: true,
    signal: true,
    idempotencyKey: true,
    __metadata: true,
    __binaryRequest: true,
    __binaryResponse: true,
    __streamClass: true
};
const isRequestOptions = (obj)=>{
    return typeof obj === 'object' && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k)=>hasOwn(requestOptionsKeys, k));
};
exports.isRequestOptions = isRequestOptions;
const getPlatformProperties = ()=>{
    if (typeof Deno !== 'undefined' && Deno.build != null) {
        return {
            'X-Stainless-Lang': 'js',
            'X-Stainless-Package-Version': version_1.VERSION,
            'X-Stainless-OS': normalizePlatform(Deno.build.os),
            'X-Stainless-Arch': normalizeArch(Deno.build.arch),
            'X-Stainless-Runtime': 'deno',
            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown'
        };
    }
    if (typeof EdgeRuntime !== 'undefined') {
        return {
            'X-Stainless-Lang': 'js',
            'X-Stainless-Package-Version': version_1.VERSION,
            'X-Stainless-OS': 'Unknown',
            'X-Stainless-Arch': `other:${EdgeRuntime}`,
            'X-Stainless-Runtime': 'edge',
            'X-Stainless-Runtime-Version': process.version
        };
    }
    // Check if Node.js
    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {
        return {
            'X-Stainless-Lang': 'js',
            'X-Stainless-Package-Version': version_1.VERSION,
            'X-Stainless-OS': normalizePlatform(process.platform),
            'X-Stainless-Arch': normalizeArch(process.arch),
            'X-Stainless-Runtime': 'node',
            'X-Stainless-Runtime-Version': process.version
        };
    }
    const browserInfo = getBrowserInfo();
    if (browserInfo) {
        return {
            'X-Stainless-Lang': 'js',
            'X-Stainless-Package-Version': version_1.VERSION,
            'X-Stainless-OS': 'Unknown',
            'X-Stainless-Arch': 'unknown',
            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,
            'X-Stainless-Runtime-Version': browserInfo.version
        };
    }
    // TODO add support for Cloudflare workers, etc.
    return {
        'X-Stainless-Lang': 'js',
        'X-Stainless-Package-Version': version_1.VERSION,
        'X-Stainless-OS': 'Unknown',
        'X-Stainless-Arch': 'unknown',
        'X-Stainless-Runtime': 'unknown',
        'X-Stainless-Runtime-Version': 'unknown'
    };
};
// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts
function getBrowserInfo() {
    if (typeof navigator === 'undefined' || !navigator) {
        return null;
    }
    // NOTE: The order matters here!
    const browserPatterns = [
        {
            key: 'edge',
            pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        },
        {
            key: 'ie',
            pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        },
        {
            key: 'ie',
            pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/
        },
        {
            key: 'chrome',
            pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        },
        {
            key: 'firefox',
            pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        },
        {
            key: 'safari',
            pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/
        }
    ];
    // Find the FIRST matching browser
    for (const { key, pattern } of browserPatterns){
        const match = pattern.exec(navigator.userAgent);
        if (match) {
            const major = match[1] || 0;
            const minor = match[2] || 0;
            const patch = match[3] || 0;
            return {
                browser: key,
                version: `${major}.${minor}.${patch}`
            };
        }
    }
    return null;
}
const normalizeArch = (arch)=>{
    // Node docs:
    // - https://nodejs.org/api/process.html#processarch
    // Deno docs:
    // - https://doc.deno.land/deno/stable/~/Deno.build
    if (arch === 'x32') return 'x32';
    if (arch === 'x86_64' || arch === 'x64') return 'x64';
    if (arch === 'arm') return 'arm';
    if (arch === 'aarch64' || arch === 'arm64') return 'arm64';
    if (arch) return `other:${arch}`;
    return 'unknown';
};
const normalizePlatform = (platform)=>{
    // Node platforms:
    // - https://nodejs.org/api/process.html#processplatform
    // Deno platforms:
    // - https://doc.deno.land/deno/stable/~/Deno.build
    // - https://github.com/denoland/deno/issues/14799
    platform = platform.toLowerCase();
    // NOTE: this iOS check is untested and may not work
    // Node does not work natively on IOS, there is a fork at
    // https://github.com/nodejs-mobile/nodejs-mobile
    // however it is unknown at the time of writing how to detect if it is running
    if (platform.includes('ios')) return 'iOS';
    if (platform === 'android') return 'Android';
    if (platform === 'darwin') return 'MacOS';
    if (platform === 'win32') return 'Windows';
    if (platform === 'freebsd') return 'FreeBSD';
    if (platform === 'openbsd') return 'OpenBSD';
    if (platform === 'linux') return 'Linux';
    if (platform) return `Other:${platform}`;
    return 'Unknown';
};
let _platformHeaders;
const getPlatformHeaders = ()=>{
    return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
const safeJSON = (text)=>{
    try {
        return JSON.parse(text);
    } catch (err) {
        return undefined;
    }
};
exports.safeJSON = safeJSON;
// https://url.spec.whatwg.org/#url-scheme-string
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url)=>{
    return startsWithSchemeRegexp.test(url);
};
const sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
exports.sleep = sleep;
const validatePositiveInteger = (name, n)=>{
    if (typeof n !== 'number' || !Number.isInteger(n)) {
        throw new error_1.OpenAIError(`${name} must be an integer`);
    }
    if (n < 0) {
        throw new error_1.OpenAIError(`${name} must be a positive integer`);
    }
    return n;
};
const castToError = (err)=>{
    if (err instanceof Error) return err;
    if (typeof err === 'object' && err !== null) {
        try {
            return new Error(JSON.stringify(err));
        } catch  {}
    }
    return new Error(err);
};
exports.castToError = castToError;
const ensurePresent = (value)=>{
    if (value == null) throw new error_1.OpenAIError(`Expected a value to be given but received ${value} instead.`);
    return value;
};
exports.ensurePresent = ensurePresent;
/**
 * Read an environment variable.
 *
 * Trims beginning and trailing whitespace.
 *
 * Will return undefined if the environment variable doesn't exist or cannot be accessed.
 */ const readEnv = (env)=>{
    if (typeof process !== 'undefined') {
        return process.env?.[env]?.trim() ?? undefined;
    }
    if (typeof Deno !== 'undefined') {
        return Deno.env?.get?.(env)?.trim();
    }
    return undefined;
};
exports.readEnv = readEnv;
const coerceInteger = (value)=>{
    if (typeof value === 'number') return Math.round(value);
    if (typeof value === 'string') return parseInt(value, 10);
    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
};
exports.coerceInteger = coerceInteger;
const coerceFloat = (value)=>{
    if (typeof value === 'number') return value;
    if (typeof value === 'string') return parseFloat(value);
    throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
};
exports.coerceFloat = coerceFloat;
const coerceBoolean = (value)=>{
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') return value === 'true';
    return Boolean(value);
};
exports.coerceBoolean = coerceBoolean;
const maybeCoerceInteger = (value)=>{
    if (value === undefined) {
        return undefined;
    }
    return (0, exports.coerceInteger)(value);
};
exports.maybeCoerceInteger = maybeCoerceInteger;
const maybeCoerceFloat = (value)=>{
    if (value === undefined) {
        return undefined;
    }
    return (0, exports.coerceFloat)(value);
};
exports.maybeCoerceFloat = maybeCoerceFloat;
const maybeCoerceBoolean = (value)=>{
    if (value === undefined) {
        return undefined;
    }
    return (0, exports.coerceBoolean)(value);
};
exports.maybeCoerceBoolean = maybeCoerceBoolean;
// https://stackoverflow.com/a/34491287
function isEmptyObj(obj) {
    if (!obj) return true;
    for(const _k in obj)return false;
    return true;
}
exports.isEmptyObj = isEmptyObj;
// https://eslint.org/docs/latest/rules/no-prototype-builtins
function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
exports.hasOwn = hasOwn;
/**
 * Copies headers from "newHeaders" onto "targetHeaders",
 * using lower-case for all properties,
 * ignoring any keys with undefined values,
 * and deleting any keys with null values.
 */ function applyHeadersMut(targetHeaders, newHeaders) {
    for(const k in newHeaders){
        if (!hasOwn(newHeaders, k)) continue;
        const lowerKey = k.toLowerCase();
        if (!lowerKey) continue;
        const val = newHeaders[k];
        if (val === null) {
            delete targetHeaders[lowerKey];
        } else if (val !== undefined) {
            targetHeaders[lowerKey] = val;
        }
    }
}
const SENSITIVE_HEADERS = new Set([
    'authorization',
    'api-key'
]);
function debug(action, ...args) {
    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {
        const modifiedArgs = args.map((arg)=>{
            if (!arg) {
                return arg;
            }
            // Check for sensitive headers in request body 'headers' object
            if (arg['headers']) {
                // clone so we don't mutate
                const modifiedArg = {
                    ...arg,
                    headers: {
                        ...arg['headers']
                    }
                };
                for(const header in arg['headers']){
                    if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
                        modifiedArg['headers'][header] = 'REDACTED';
                    }
                }
                return modifiedArg;
            }
            let modifiedArg = null;
            // Check for sensitive headers in headers object
            for(const header in arg){
                if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
                    // avoid making a copy until we need to
                    modifiedArg ?? (modifiedArg = {
                        ...arg
                    });
                    modifiedArg[header] = 'REDACTED';
                }
            }
            return modifiedArg ?? arg;
        });
        console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
    }
}
exports.debug = debug;
/**
 * https://stackoverflow.com/a/2117523
 */ const uuid4 = ()=>{
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
};
const isRunningInBrowser = ()=>{
    return(// @ts-ignore
    ("TURBOPACK compile-time value", "undefined") !== 'undefined' && // @ts-ignore
    typeof window.document !== 'undefined' && // @ts-ignore
    typeof navigator !== 'undefined');
};
exports.isRunningInBrowser = isRunningInBrowser;
const isHeadersProtocol = (headers)=>{
    return typeof headers?.get === 'function';
};
exports.isHeadersProtocol = isHeadersProtocol;
const getRequiredHeader = (headers, header)=>{
    const foundHeader = (0, exports.getHeader)(headers, header);
    if (foundHeader === undefined) {
        throw new Error(`Could not find ${header} header`);
    }
    return foundHeader;
};
exports.getRequiredHeader = getRequiredHeader;
const getHeader = (headers, header)=>{
    const lowerCasedHeader = header.toLowerCase();
    if ((0, exports.isHeadersProtocol)(headers)) {
        // to deal with the case where the header looks like Stainless-Event-Id
        const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2)=>g1 + g2.toUpperCase());
        for (const key of [
            header,
            lowerCasedHeader,
            header.toUpperCase(),
            intercapsHeader
        ]){
            const value = headers.get(key);
            if (value) {
                return value;
            }
        }
    }
    for (const [key, value] of Object.entries(headers)){
        if (key.toLowerCase() === lowerCasedHeader) {
            if (Array.isArray(value)) {
                if (value.length <= 1) return value[0];
                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
                return value[0];
            }
            return value;
        }
    }
    return undefined;
};
exports.getHeader = getHeader;
/**
 * Encodes a string to Base64 format.
 */ const toBase64 = (str)=>{
    if (!str) return '';
    if (typeof Buffer !== 'undefined') {
        return Buffer.from(str).toString('base64');
    }
    if (typeof btoa !== 'undefined') {
        return btoa(str);
    }
    throw new error_1.OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');
};
exports.toBase64 = toBase64;
/**
 * Converts a Base64 encoded string to a Float32Array.
 * @param base64Str - The Base64 encoded string.
 * @returns An Array of numbers interpreted as Float32 values.
 */ const toFloat32Array = (base64Str)=>{
    if (typeof Buffer !== 'undefined') {
        // for Node.js environment
        const buf = Buffer.from(base64Str, 'base64');
        return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
    } else {
        // for legacy web platform APIs
        const binaryStr = atob(base64Str);
        const len = binaryStr.length;
        const bytes = new Uint8Array(len);
        for(let i = 0; i < len; i++){
            bytes[i] = binaryStr.charCodeAt(i);
        }
        return Array.from(new Float32Array(bytes.buffer));
    }
};
exports.toFloat32Array = toFloat32Array;
function isObj(obj) {
    return obj != null && typeof obj === 'object' && !Array.isArray(obj);
}
exports.isObj = isObj; //# sourceMappingURL=core.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CursorPage = exports.Page = void 0;
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
/**
 * Note: no pagination actually occurs yet, this is for forwards-compatibility.
 */ class Page extends core_1.AbstractPage {
    constructor(client, response, body, options){
        super(client, response, body, options);
        this.data = body.data || [];
        this.object = body.object;
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    // @deprecated Please use `nextPageInfo()` instead
    /**
     * This page represents a response that isn't actually paginated at the API level
     * so there will never be any next page params.
     */ nextPageParams() {
        return null;
    }
    nextPageInfo() {
        return null;
    }
}
exports.Page = Page;
class CursorPage extends core_1.AbstractPage {
    constructor(client, response, body, options){
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    hasNextPage() {
        if (this.has_more === false) {
            return false;
        }
        return super.hasNextPage();
    }
    // @deprecated Please use `nextPageInfo()` instead
    nextPageParams() {
        const info = this.nextPageInfo();
        if (!info) return null;
        if ('params' in info) return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length) return null;
        return params;
    }
    nextPageInfo() {
        const data = this.getPaginatedItems();
        if (!data.length) {
            return null;
        }
        const id = data[data.length - 1]?.id;
        if (!id) {
            return null;
        }
        return {
            params: {
                after: id
            }
        };
    }
}
exports.CursorPage = CursorPage; //# sourceMappingURL=pagination.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APIResource = void 0;
class APIResource {
    constructor(client){
        this._client = client;
    }
}
exports.APIResource = APIResource; //# sourceMappingURL=resource.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/messages.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionStoreMessagesPage = exports.Messages = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const completions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionStoreMessagesPage", {
    enumerable: true,
    get: function() {
        return completions_1.ChatCompletionStoreMessagesPage;
    }
});
class Messages extends resource_1.APIResource {
    list(completionId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(completionId, {}, query);
        }
        return this._client.getAPIList(`/chat/completions/${completionId}/messages`, completions_1.ChatCompletionStoreMessagesPage, {
            query,
            ...options
        });
    }
}
exports.Messages = Messages; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionStoreMessagesPage = exports.ChatCompletionsPage = exports.Completions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const MessagesAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/messages.js [app-route] (ecmascript)"));
const messages_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/messages.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Completions extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.messages = new MessagesAPI.Messages(this._client);
    }
    create(body, options) {
        return this._client.post('/chat/completions', {
            body,
            ...options,
            stream: body.stream ?? false
        });
    }
    /**
     * Get a stored chat completion. Only Chat Completions that have been created with
     * the `store` parameter set to `true` will be returned.
     *
     * @example
     * ```ts
     * const chatCompletion =
     *   await client.chat.completions.retrieve('completion_id');
     * ```
     */ retrieve(completionId, options) {
        return this._client.get(`/chat/completions/${completionId}`, options);
    }
    /**
     * Modify a stored chat completion. Only Chat Completions that have been created
     * with the `store` parameter set to `true` can be modified. Currently, the only
     * supported modification is to update the `metadata` field.
     *
     * @example
     * ```ts
     * const chatCompletion = await client.chat.completions.update(
     *   'completion_id',
     *   { metadata: { foo: 'string' } },
     * );
     * ```
     */ update(completionId, body, options) {
        return this._client.post(`/chat/completions/${completionId}`, {
            body,
            ...options
        });
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/chat/completions', ChatCompletionsPage, {
            query,
            ...options
        });
    }
    /**
     * Delete a stored chat completion. Only Chat Completions that have been created
     * with the `store` parameter set to `true` can be deleted.
     *
     * @example
     * ```ts
     * const chatCompletionDeleted =
     *   await client.chat.completions.del('completion_id');
     * ```
     */ del(completionId, options) {
        return this._client.delete(`/chat/completions/${completionId}`, options);
    }
}
exports.Completions = Completions;
class ChatCompletionsPage extends pagination_1.CursorPage {
}
exports.ChatCompletionsPage = ChatCompletionsPage;
class ChatCompletionStoreMessagesPage extends pagination_1.CursorPage {
}
exports.ChatCompletionStoreMessagesPage = ChatCompletionStoreMessagesPage;
Completions.ChatCompletionsPage = ChatCompletionsPage;
Completions.Messages = messages_1.Messages; //# sourceMappingURL=completions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/chat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chat = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const CompletionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)"));
const completions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)");
class Chat extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.completions = new CompletionsAPI.Completions(this._client);
    }
}
exports.Chat = Chat;
Chat.Completions = completions_1.Completions;
Chat.ChatCompletionsPage = completions_1.ChatCompletionsPage; //# sourceMappingURL=chat.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Messages = exports.Completions = exports.ChatCompletionsPage = exports.ChatCompletionStoreMessagesPage = void 0;
var completions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionStoreMessagesPage", {
    enumerable: true,
    get: function() {
        return completions_1.ChatCompletionStoreMessagesPage;
    }
});
Object.defineProperty(exports, "ChatCompletionsPage", {
    enumerable: true,
    get: function() {
        return completions_1.ChatCompletionsPage;
    }
});
Object.defineProperty(exports, "Completions", {
    enumerable: true,
    get: function() {
        return completions_1.Completions;
    }
});
var messages_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/messages.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Messages", {
    enumerable: true,
    get: function() {
        return messages_1.Messages;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Completions = exports.ChatCompletionsPage = exports.ChatCompletionStoreMessagesPage = exports.Chat = void 0;
var chat_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/chat.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Chat", {
    enumerable: true,
    get: function() {
        return chat_1.Chat;
    }
});
var index_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionStoreMessagesPage", {
    enumerable: true,
    get: function() {
        return index_1.ChatCompletionStoreMessagesPage;
    }
});
Object.defineProperty(exports, "ChatCompletionsPage", {
    enumerable: true,
    get: function() {
        return index_1.ChatCompletionsPage;
    }
});
Object.defineProperty(exports, "Completions", {
    enumerable: true,
    get: function() {
        return index_1.Completions;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/shared.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=shared.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/speech.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Speech = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Speech extends resource_1.APIResource {
    /**
     * Generates audio from the input text.
     *
     * @example
     * ```ts
     * const speech = await client.audio.speech.create({
     *   input: 'input',
     *   model: 'string',
     *   voice: 'ash',
     * });
     *
     * const content = await speech.blob();
     * console.log(content);
     * ```
     */ create(body, options) {
        return this._client.post('/audio/speech', {
            body,
            ...options,
            headers: {
                Accept: 'application/octet-stream',
                ...options?.headers
            },
            __binaryResponse: true
        });
    }
}
exports.Speech = Speech; //# sourceMappingURL=speech.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/transcriptions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transcriptions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
class Transcriptions extends resource_1.APIResource {
    create(body, options) {
        return this._client.post('/audio/transcriptions', Core.multipartFormRequestOptions({
            body,
            ...options,
            stream: body.stream ?? false,
            __metadata: {
                model: body.model
            }
        }));
    }
}
exports.Transcriptions = Transcriptions; //# sourceMappingURL=transcriptions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/translations.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Translations = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
class Translations extends resource_1.APIResource {
    create(body, options) {
        return this._client.post('/audio/translations', Core.multipartFormRequestOptions({
            body,
            ...options,
            __metadata: {
                model: body.model
            }
        }));
    }
}
exports.Translations = Translations; //# sourceMappingURL=translations.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/audio.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Audio = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const SpeechAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/speech.js [app-route] (ecmascript)"));
const speech_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/speech.js [app-route] (ecmascript)");
const TranscriptionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/transcriptions.js [app-route] (ecmascript)"));
const transcriptions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/transcriptions.js [app-route] (ecmascript)");
const TranslationsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/translations.js [app-route] (ecmascript)"));
const translations_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/translations.js [app-route] (ecmascript)");
class Audio extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);
        this.translations = new TranslationsAPI.Translations(this._client);
        this.speech = new SpeechAPI.Speech(this._client);
    }
}
exports.Audio = Audio;
Audio.Transcriptions = transcriptions_1.Transcriptions;
Audio.Translations = translations_1.Translations;
Audio.Speech = speech_1.Speech; //# sourceMappingURL=audio.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/batches.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BatchesPage = exports.Batches = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Batches extends resource_1.APIResource {
    /**
     * Creates and executes a batch from an uploaded file of requests
     */ create(body, options) {
        return this._client.post('/batches', {
            body,
            ...options
        });
    }
    /**
     * Retrieves a batch.
     */ retrieve(batchId, options) {
        return this._client.get(`/batches/${batchId}`, options);
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/batches', BatchesPage, {
            query,
            ...options
        });
    }
    /**
     * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
     * 10 minutes, before changing to `cancelled`, where it will have partial results
     * (if any) available in the output file.
     */ cancel(batchId, options) {
        return this._client.post(`/batches/${batchId}/cancel`, options);
    }
}
exports.Batches = Batches;
class BatchesPage extends pagination_1.CursorPage {
}
exports.BatchesPage = BatchesPage;
Batches.BatchesPage = BatchesPage; //# sourceMappingURL=batches.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/EventStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventStream = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
class EventStream {
    constructor(){
        _EventStream_instances.add(this);
        this.controller = new AbortController();
        _EventStream_connectedPromise.set(this, void 0);
        _EventStream_resolveConnectedPromise.set(this, ()=>{});
        _EventStream_rejectConnectedPromise.set(this, ()=>{});
        _EventStream_endPromise.set(this, void 0);
        _EventStream_resolveEndPromise.set(this, ()=>{});
        _EventStream_rejectEndPromise.set(this, ()=>{});
        _EventStream_listeners.set(this, {});
        _EventStream_ended.set(this, false);
        _EventStream_errored.set(this, false);
        _EventStream_aborted.set(this, false);
        _EventStream_catchingPromiseCreated.set(this, false);
        __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject)=>{
            __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
            __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
        }), "f");
        __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject)=>{
            __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
            __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
        }), "f");
        // Don't let these promises cause unhandled rejection errors.
        // we will manually cause an unhandled rejection error later
        // if the user hasn't registered any error listener or called
        // any promise-returning method.
        __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(()=>{});
        __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(()=>{});
    }
    _run(executor) {
        // Unfortunately if we call `executor()` immediately we get runtime errors about
        // references to `this` before the `super()` constructor call returns.
        setTimeout(()=>{
            executor().then(()=>{
                this._emitFinal();
                this._emit('end');
            }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
        }, 0);
    }
    _connected() {
        if (this.ended) return;
        __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
        this._emit('connect');
    }
    get ended() {
        return __classPrivateFieldGet(this, _EventStream_ended, "f");
    }
    get errored() {
        return __classPrivateFieldGet(this, _EventStream_errored, "f");
    }
    get aborted() {
        return __classPrivateFieldGet(this, _EventStream_aborted, "f");
    }
    abort() {
        this.controller.abort();
    }
    /**
     * Adds the listener function to the end of the listeners array for the event.
     * No checks are made to see if the listener has already been added. Multiple calls passing
     * the same combination of event and listener will result in the listener being added, and
     * called, multiple times.
     * @returns this ChatCompletionStream, so that calls can be chained
     */ on(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({
            listener
        });
        return this;
    }
    /**
     * Removes the specified listener from the listener array for the event.
     * off() will remove, at most, one instance of a listener from the listener array. If any single
     * listener has been added multiple times to the listener array for the specified event, then
     * off() must be called multiple times to remove each instance.
     * @returns this ChatCompletionStream, so that calls can be chained
     */ off(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (!listeners) return this;
        const index = listeners.findIndex((l)=>l.listener === listener);
        if (index >= 0) listeners.splice(index, 1);
        return this;
    }
    /**
     * Adds a one-time listener function for the event. The next time the event is triggered,
     * this listener is removed and then invoked.
     * @returns this ChatCompletionStream, so that calls can be chained
     */ once(event, listener) {
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({
            listener,
            once: true
        });
        return this;
    }
    /**
     * This is similar to `.once()`, but returns a Promise that resolves the next time
     * the event is triggered, instead of calling a listener callback.
     * @returns a Promise that resolves the next time given event is triggered,
     * or rejects if an error is emitted.  (If you request the 'error' event,
     * returns a promise that resolves with the error).
     *
     * Example:
     *
     *   const message = await stream.emitted('message') // rejects if the stream errors
     */ emitted(event) {
        return new Promise((resolve, reject)=>{
            __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
            if (event !== 'error') this.once('error', reject);
            this.once(event, resolve);
        });
    }
    async done() {
        __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
        await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
    }
    _emit(event, ...args) {
        // make sure we don't emit any events after end
        if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
            return;
        }
        if (event === 'end') {
            __classPrivateFieldSet(this, _EventStream_ended, true, "f");
            __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
        }
        const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (listeners) {
            __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l)=>!l.once);
            listeners.forEach(({ listener })=>listener(...args));
        }
        if (event === 'abort') {
            const error = args[0];
            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
                Promise.reject(error);
            }
            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
            this._emit('end');
            return;
        }
        if (event === 'error') {
            // NOTE: _emit('error', error) should only be called from #handleError().
            const error = args[0];
            if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
                // Trigger an unhandled rejection if the user hasn't registered any error handlers.
                // If you are seeing stack traces here, make sure to handle errors via either:
                // - runner.on('error', () => ...)
                // - await runner.done()
                // - await runner.finalChatCompletion()
                // - etc.
                Promise.reject(error);
            }
            __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
            __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
            this._emit('end');
        }
    }
    _emitFinal() {}
}
exports.EventStream = EventStream;
_EventStream_connectedPromise = new WeakMap(), _EventStream_resolveConnectedPromise = new WeakMap(), _EventStream_rejectConnectedPromise = new WeakMap(), _EventStream_endPromise = new WeakMap(), _EventStream_resolveEndPromise = new WeakMap(), _EventStream_rejectEndPromise = new WeakMap(), _EventStream_listeners = new WeakMap(), _EventStream_ended = new WeakMap(), _EventStream_errored = new WeakMap(), _EventStream_aborted = new WeakMap(), _EventStream_catchingPromiseCreated = new WeakMap(), _EventStream_instances = new WeakSet(), _EventStream_handleError = function _EventStream_handleError(error) {
    __classPrivateFieldSet(this, _EventStream_errored, true, "f");
    if (error instanceof Error && error.name === 'AbortError') {
        error = new error_1.APIUserAbortError();
    }
    if (error instanceof error_1.APIUserAbortError) {
        __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
        return this._emit('abort', error);
    }
    if (error instanceof error_1.OpenAIError) {
        return this._emit('error', error);
    }
    if (error instanceof Error) {
        const openAIError = new error_1.OpenAIError(error.message);
        // @ts-ignore
        openAIError.cause = error;
        return this._emit('error', openAIError);
    }
    return this._emit('error', new error_1.OpenAIError(String(error)));
}; //# sourceMappingURL=EventStream.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AssistantStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantStream = void 0;
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
const streaming_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/streaming.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const EventStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/EventStream.js [app-route] (ecmascript)");
class AssistantStream extends EventStream_1.EventStream {
    constructor(){
        super(...arguments);
        _AssistantStream_instances.add(this);
        //Track all events in a single list for reference
        _AssistantStream_events.set(this, []);
        //Used to accumulate deltas
        //We are accumulating many types so the value here is not strict
        _AssistantStream_runStepSnapshots.set(this, {});
        _AssistantStream_messageSnapshots.set(this, {});
        _AssistantStream_messageSnapshot.set(this, void 0);
        _AssistantStream_finalRun.set(this, void 0);
        _AssistantStream_currentContentIndex.set(this, void 0);
        _AssistantStream_currentContent.set(this, void 0);
        _AssistantStream_currentToolCallIndex.set(this, void 0);
        _AssistantStream_currentToolCall.set(this, void 0);
        //For current snapshot methods
        _AssistantStream_currentEvent.set(this, void 0);
        _AssistantStream_currentRunSnapshot.set(this, void 0);
        _AssistantStream_currentRunStepSnapshot.set(this, void 0);
    }
    [(_AssistantStream_events = new WeakMap(), _AssistantStream_runStepSnapshots = new WeakMap(), _AssistantStream_messageSnapshots = new WeakMap(), _AssistantStream_messageSnapshot = new WeakMap(), _AssistantStream_finalRun = new WeakMap(), _AssistantStream_currentContentIndex = new WeakMap(), _AssistantStream_currentContent = new WeakMap(), _AssistantStream_currentToolCallIndex = new WeakMap(), _AssistantStream_currentToolCall = new WeakMap(), _AssistantStream_currentEvent = new WeakMap(), _AssistantStream_currentRunSnapshot = new WeakMap(), _AssistantStream_currentRunStepSnapshot = new WeakMap(), _AssistantStream_instances = new WeakSet(), Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        //Catch all for passing along all events
        this.on('event', (event)=>{
            const reader = readQueue.shift();
            if (reader) {
                reader.resolve(event);
            } else {
                pushQueue.push(event);
            }
        });
        this.on('end', ()=>{
            done = true;
            for (const reader of readQueue){
                reader.resolve(undefined);
            }
            readQueue.length = 0;
        });
        this.on('abort', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        this.on('error', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        return {
            next: async ()=>{
                if (!pushQueue.length) {
                    if (done) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    return new Promise((resolve, reject)=>readQueue.push({
                            resolve,
                            reject
                        })).then((chunk)=>chunk ? {
                            value: chunk,
                            done: false
                        } : {
                            value: undefined,
                            done: true
                        });
                }
                const chunk = pushQueue.shift();
                return {
                    value: chunk,
                    done: false
                };
            },
            return: async ()=>{
                this.abort();
                return {
                    value: undefined,
                    done: true
                };
            }
        };
    }
    static fromReadableStream(stream) {
        const runner = new AssistantStream();
        runner._run(()=>runner._fromReadableStream(stream));
        return runner;
    }
    async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        this._connected();
        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream){
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    toReadableStream() {
        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
    }
    static createToolAssistantStream(threadId, runId, runs, params, options) {
        const runner = new AssistantStream();
        runner._run(()=>runner._runToolAssistantStream(threadId, runId, runs, params, {
                ...options,
                headers: {
                    ...options?.headers,
                    'X-Stainless-Helper-Method': 'stream'
                }
            }));
        return runner;
    }
    async _createToolAssistantStream(run, threadId, runId, params, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        const body = {
            ...params,
            stream: true
        };
        const stream = await run.submitToolOutputs(threadId, runId, body, {
            ...options,
            signal: this.controller.signal
        });
        this._connected();
        for await (const event of stream){
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static createThreadAssistantStream(params, thread, options) {
        const runner = new AssistantStream();
        runner._run(()=>runner._threadAssistantStream(params, thread, {
                ...options,
                headers: {
                    ...options?.headers,
                    'X-Stainless-Helper-Method': 'stream'
                }
            }));
        return runner;
    }
    static createAssistantStream(threadId, runs, params, options) {
        const runner = new AssistantStream();
        runner._run(()=>runner._runAssistantStream(threadId, runs, params, {
                ...options,
                headers: {
                    ...options?.headers,
                    'X-Stainless-Helper-Method': 'stream'
                }
            }));
        return runner;
    }
    currentEvent() {
        return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
    }
    currentRun() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
    }
    currentMessageSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
    }
    currentRunStepSnapshot() {
        return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
    }
    async finalRunSteps() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
    }
    async finalMessages() {
        await this.done();
        return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
    }
    async finalRun() {
        await this.done();
        if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f")) throw Error('Final run was not received.');
        return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }
    async _createThreadAssistantStream(thread, params, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        const body = {
            ...params,
            stream: true
        };
        const stream = await thread.createAndRun(body, {
            ...options,
            signal: this.controller.signal
        });
        this._connected();
        for await (const event of stream){
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    async _createAssistantStream(run, threadId, params, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        const body = {
            ...params,
            stream: true
        };
        const stream = await run.create(threadId, body, {
            ...options,
            signal: this.controller.signal
        });
        this._connected();
        for await (const event of stream){
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
    }
    static accumulateDelta(acc, delta) {
        for (const [key, deltaValue] of Object.entries(delta)){
            if (!acc.hasOwnProperty(key)) {
                acc[key] = deltaValue;
                continue;
            }
            let accValue = acc[key];
            if (accValue === null || accValue === undefined) {
                acc[key] = deltaValue;
                continue;
            }
            // We don't accumulate these special properties
            if (key === 'index' || key === 'type') {
                acc[key] = deltaValue;
                continue;
            }
            // Type-specific accumulation logic
            if (typeof accValue === 'string' && typeof deltaValue === 'string') {
                accValue += deltaValue;
            } else if (typeof accValue === 'number' && typeof deltaValue === 'number') {
                accValue += deltaValue;
            } else if (Core.isObj(accValue) && Core.isObj(deltaValue)) {
                accValue = this.accumulateDelta(accValue, deltaValue);
            } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
                if (accValue.every((x)=>typeof x === 'string' || typeof x === 'number')) {
                    accValue.push(...deltaValue); // Use spread syntax for efficient addition
                    continue;
                }
                for (const deltaEntry of deltaValue){
                    if (!Core.isObj(deltaEntry)) {
                        throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
                    }
                    const index = deltaEntry['index'];
                    if (index == null) {
                        console.error(deltaEntry);
                        throw new Error('Expected array delta entry to have an `index` property');
                    }
                    if (typeof index !== 'number') {
                        throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
                    }
                    const accEntry = accValue[index];
                    if (accEntry == null) {
                        accValue.push(deltaEntry);
                    } else {
                        accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
                    }
                }
                continue;
            } else {
                throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
            }
            acc[key] = accValue;
        }
        return acc;
    }
    _addRun(run) {
        return run;
    }
    async _threadAssistantStream(params, thread, options) {
        return await this._createThreadAssistantStream(thread, params, options);
    }
    async _runAssistantStream(threadId, runs, params, options) {
        return await this._createAssistantStream(runs, threadId, params, options);
    }
    async _runToolAssistantStream(threadId, runId, runs, params, options) {
        return await this._createToolAssistantStream(runs, threadId, runId, params, options);
    }
}
exports.AssistantStream = AssistantStream;
_AssistantStream_addEvent = function _AssistantStream_addEvent(event) {
    if (this.ended) return;
    __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
    __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
    switch(event.event){
        case 'thread.created':
            break;
        case 'thread.run.created':
        case 'thread.run.queued':
        case 'thread.run.in_progress':
        case 'thread.run.requires_action':
        case 'thread.run.completed':
        case 'thread.run.incomplete':
        case 'thread.run.failed':
        case 'thread.run.cancelling':
        case 'thread.run.cancelled':
        case 'thread.run.expired':
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
            break;
        case 'thread.run.step.created':
        case 'thread.run.step.in_progress':
        case 'thread.run.step.delta':
        case 'thread.run.step.completed':
        case 'thread.run.step.failed':
        case 'thread.run.step.cancelled':
        case 'thread.run.step.expired':
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
            break;
        case 'thread.message.created':
        case 'thread.message.in_progress':
        case 'thread.message.delta':
        case 'thread.message.completed':
        case 'thread.message.incomplete':
            __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
            break;
        case 'error':
            //This is included for completeness, but errors are processed in the SSE event processing so this should not occur
            throw new Error('Encountered an error event in event processing - errors should be processed earlier');
        default:
            assertNever(event);
    }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest() {
    if (this.ended) {
        throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
    }
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f")) throw Error('Final run has not been received');
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage(event) {
    const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
    __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
    __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
    for (const content of newContent){
        const snapshotContent = accumulatedMessage.content[content.index];
        if (snapshotContent?.type == 'text') {
            this._emit('textCreated', snapshotContent.text);
        }
    }
    switch(event.event){
        case 'thread.message.created':
            this._emit('messageCreated', event.data);
            break;
        case 'thread.message.in_progress':
            break;
        case 'thread.message.delta':
            this._emit('messageDelta', event.data.delta, accumulatedMessage);
            if (event.data.delta.content) {
                for (const content of event.data.delta.content){
                    //If it is text delta, emit a text delta event
                    if (content.type == 'text' && content.text) {
                        let textDelta = content.text;
                        let snapshot = accumulatedMessage.content[content.index];
                        if (snapshot && snapshot.type == 'text') {
                            this._emit('textDelta', textDelta, snapshot.text);
                        } else {
                            throw Error('The snapshot associated with this text delta is not text or missing');
                        }
                    }
                    if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
                        //See if we have in progress content
                        if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                            switch(__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type){
                                case 'text':
                                    this._emit('textDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                                    break;
                                case 'image_file':
                                    this._emit('imageFileDone', __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                                    break;
                            }
                        }
                        __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
                    }
                    __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
                }
            }
            break;
        case 'thread.message.completed':
        case 'thread.message.incomplete':
            //We emit the latest content we were working on on completion (including incomplete)
            if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== undefined) {
                const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
                if (currentContent) {
                    switch(currentContent.type){
                        case 'image_file':
                            this._emit('imageFileDone', currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                            break;
                        case 'text':
                            this._emit('textDone', currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                            break;
                    }
                }
            }
            if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
                this._emit('messageDone', event.data);
            }
            __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, "f");
    }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep(event) {
    const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
    __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
    switch(event.event){
        case 'thread.run.step.created':
            this._emit('runStepCreated', event.data);
            break;
        case 'thread.run.step.delta':
            const delta = event.data.delta;
            if (delta.step_details && delta.step_details.type == 'tool_calls' && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == 'tool_calls') {
                for (const toolCall of delta.step_details.tool_calls){
                    if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
                        this._emit('toolCallDelta', toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
                    } else {
                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                            this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                        }
                        __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
                        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
                        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) this._emit('toolCallCreated', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                    }
                }
            }
            this._emit('runStepDelta', event.data.delta, accumulatedRunStep);
            break;
        case 'thread.run.step.completed':
        case 'thread.run.step.failed':
        case 'thread.run.step.cancelled':
        case 'thread.run.step.expired':
            __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, "f");
            const details = event.data.step_details;
            if (details.type == 'tool_calls') {
                if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                    this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                    __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
                }
            }
            this._emit('runStepDone', event.data, accumulatedRunStep);
            break;
        case 'thread.run.step.in_progress':
            break;
    }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent(event) {
    __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
    this._emit('event', event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep(event) {
    switch(event.event){
        case 'thread.run.step.created':
            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
            return event.data;
        case 'thread.run.step.delta':
            let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
            if (!snapshot) {
                throw Error('Received a RunStepDelta before creation of a snapshot');
            }
            let data = event.data;
            if (data.delta) {
                const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
                __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
            }
            return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        case 'thread.run.step.completed':
        case 'thread.run.step.failed':
        case 'thread.run.step.cancelled':
        case 'thread.run.step.expired':
        case 'thread.run.step.in_progress':
            __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
            break;
    }
    if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id]) return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    throw new Error('No snapshot available');
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage(event, snapshot) {
    let newContent = [];
    switch(event.event){
        case 'thread.message.created':
            //On creation the snapshot is just the initial message
            return [
                event.data,
                newContent
            ];
        case 'thread.message.delta':
            if (!snapshot) {
                throw Error('Received a delta with no existing snapshot (there should be one from message creation)');
            }
            let data = event.data;
            //If this delta does not have content, nothing to process
            if (data.delta.content) {
                for (const contentElement of data.delta.content){
                    if (contentElement.index in snapshot.content) {
                        let currentContent = snapshot.content[contentElement.index];
                        snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
                    } else {
                        snapshot.content[contentElement.index] = contentElement;
                        // This is a new element
                        newContent.push(contentElement);
                    }
                }
            }
            return [
                snapshot,
                newContent
            ];
        case 'thread.message.in_progress':
        case 'thread.message.completed':
        case 'thread.message.incomplete':
            //No changes on other thread events
            if (snapshot) {
                return [
                    snapshot,
                    newContent
                ];
            } else {
                throw Error('Received thread message event with no existing snapshot');
            }
    }
    throw Error('Tried to accumulate a non-message event');
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent(contentElement, currentContent) {
    return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun(event) {
    __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
    switch(event.event){
        case 'thread.run.created':
            break;
        case 'thread.run.queued':
            break;
        case 'thread.run.in_progress':
            break;
        case 'thread.run.requires_action':
        case 'thread.run.cancelled':
        case 'thread.run.failed':
        case 'thread.run.completed':
        case 'thread.run.expired':
            __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                this._emit('toolCallDone', __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
            }
            break;
        case 'thread.run.cancelling':
            break;
    }
};
function assertNever(_x) {} //# sourceMappingURL=AssistantStream.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/assistants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantsPage = exports.Assistants = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
const AssistantStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AssistantStream.js [app-route] (ecmascript)");
class Assistants extends resource_1.APIResource {
    /**
     * Create an assistant with a model and instructions.
     *
     * @example
     * ```ts
     * const assistant = await client.beta.assistants.create({
     *   model: 'gpt-4o',
     * });
     * ```
     */ create(body, options) {
        return this._client.post('/assistants', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieves an assistant.
     *
     * @example
     * ```ts
     * const assistant = await client.beta.assistants.retrieve(
     *   'assistant_id',
     * );
     * ```
     */ retrieve(assistantId, options) {
        return this._client.get(`/assistants/${assistantId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Modifies an assistant.
     *
     * @example
     * ```ts
     * const assistant = await client.beta.assistants.update(
     *   'assistant_id',
     * );
     * ```
     */ update(assistantId, body, options) {
        return this._client.post(`/assistants/${assistantId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/assistants', AssistantsPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Delete an assistant.
     *
     * @example
     * ```ts
     * const assistantDeleted = await client.beta.assistants.del(
     *   'assistant_id',
     * );
     * ```
     */ del(assistantId, options) {
        return this._client.delete(`/assistants/${assistantId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.Assistants = Assistants;
class AssistantsPage extends pagination_1.CursorPage {
}
exports.AssistantsPage = AssistantsPage;
Assistants.AssistantsPage = AssistantsPage; //# sourceMappingURL=assistants.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/RunnableFunction.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParsingToolFunction = exports.ParsingFunction = exports.isRunnableFunctionWithParse = void 0;
function isRunnableFunctionWithParse(fn) {
    return typeof fn.parse === 'function';
}
exports.isRunnableFunctionWithParse = isRunnableFunctionWithParse;
/**
 * This is helper class for passing a `function` and `parse` where the `function`
 * argument type matches the `parse` return type.
 *
 * @deprecated - please use ParsingToolFunction instead.
 */ class ParsingFunction {
    constructor(input){
        this.function = input.function;
        this.parse = input.parse;
        this.parameters = input.parameters;
        this.description = input.description;
        this.name = input.name;
    }
}
exports.ParsingFunction = ParsingFunction;
/**
 * This is helper class for passing a `function` and `parse` where the `function`
 * argument type matches the `parse` return type.
 */ class ParsingToolFunction {
    constructor(input){
        this.type = 'function';
        this.function = input;
    }
}
exports.ParsingToolFunction = ParsingToolFunction; //# sourceMappingURL=RunnableFunction.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/chatCompletionUtils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPresent = exports.isToolMessage = exports.isFunctionMessage = exports.isAssistantMessage = void 0;
const isAssistantMessage = (message)=>{
    return message?.role === 'assistant';
};
exports.isAssistantMessage = isAssistantMessage;
const isFunctionMessage = (message)=>{
    return message?.role === 'function';
};
exports.isFunctionMessage = isFunctionMessage;
const isToolMessage = (message)=>{
    return message?.role === 'tool';
};
exports.isToolMessage = isToolMessage;
function isPresent(obj) {
    return obj != null;
}
exports.isPresent = isPresent; //# sourceMappingURL=chatCompletionUtils.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateInputTools = exports.hasAutoParseableInput = exports.shouldParseToolCall = exports.parseChatCompletion = exports.maybeParseChatCompletion = exports.isAutoParsableTool = exports.makeParseableTool = exports.isAutoParsableResponseFormat = exports.makeParseableTextFormat = exports.makeParseableResponseFormat = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
function makeParseableResponseFormat(response_format, parser) {
    const obj = {
        ...response_format
    };
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-response-format',
            enumerable: false
        },
        $parseRaw: {
            value: parser,
            enumerable: false
        }
    });
    return obj;
}
exports.makeParseableResponseFormat = makeParseableResponseFormat;
function makeParseableTextFormat(response_format, parser) {
    const obj = {
        ...response_format
    };
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-response-format',
            enumerable: false
        },
        $parseRaw: {
            value: parser,
            enumerable: false
        }
    });
    return obj;
}
exports.makeParseableTextFormat = makeParseableTextFormat;
function isAutoParsableResponseFormat(response_format) {
    return response_format?.['$brand'] === 'auto-parseable-response-format';
}
exports.isAutoParsableResponseFormat = isAutoParsableResponseFormat;
function makeParseableTool(tool, { parser, callback }) {
    const obj = {
        ...tool
    };
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-tool',
            enumerable: false
        },
        $parseRaw: {
            value: parser,
            enumerable: false
        },
        $callback: {
            value: callback,
            enumerable: false
        }
    });
    return obj;
}
exports.makeParseableTool = makeParseableTool;
function isAutoParsableTool(tool) {
    return tool?.['$brand'] === 'auto-parseable-tool';
}
exports.isAutoParsableTool = isAutoParsableTool;
function maybeParseChatCompletion(completion, params) {
    if (!params || !hasAutoParseableInput(params)) {
        return {
            ...completion,
            choices: completion.choices.map((choice)=>({
                    ...choice,
                    message: {
                        ...choice.message,
                        parsed: null,
                        ...choice.message.tool_calls ? {
                            tool_calls: choice.message.tool_calls
                        } : undefined
                    }
                }))
        };
    }
    return parseChatCompletion(completion, params);
}
exports.maybeParseChatCompletion = maybeParseChatCompletion;
function parseChatCompletion(completion, params) {
    const choices = completion.choices.map((choice)=>{
        if (choice.finish_reason === 'length') {
            throw new error_1.LengthFinishReasonError();
        }
        if (choice.finish_reason === 'content_filter') {
            throw new error_1.ContentFilterFinishReasonError();
        }
        return {
            ...choice,
            message: {
                ...choice.message,
                ...choice.message.tool_calls ? {
                    tool_calls: choice.message.tool_calls?.map((toolCall)=>parseToolCall(params, toolCall)) ?? undefined
                } : undefined,
                parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
            }
        };
    });
    return {
        ...completion,
        choices
    };
}
exports.parseChatCompletion = parseChatCompletion;
function parseResponseFormat(params, content) {
    if (params.response_format?.type !== 'json_schema') {
        return null;
    }
    if (params.response_format?.type === 'json_schema') {
        if ('$parseRaw' in params.response_format) {
            const response_format = params.response_format;
            return response_format.$parseRaw(content);
        }
        return JSON.parse(content);
    }
    return null;
}
function parseToolCall(params, toolCall) {
    const inputTool = params.tools?.find((inputTool)=>inputTool.function?.name === toolCall.function.name);
    return {
        ...toolCall,
        function: {
            ...toolCall.function,
            parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
        }
    };
}
function shouldParseToolCall(params, toolCall) {
    if (!params) {
        return false;
    }
    const inputTool = params.tools?.find((inputTool)=>inputTool.function?.name === toolCall.function.name);
    return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;
}
exports.shouldParseToolCall = shouldParseToolCall;
function hasAutoParseableInput(params) {
    if (isAutoParsableResponseFormat(params.response_format)) {
        return true;
    }
    return params.tools?.some((t)=>isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true) ?? false;
}
exports.hasAutoParseableInput = hasAutoParseableInput;
function validateInputTools(tools) {
    for (const tool of tools ?? []){
        if (tool.type !== 'function') {
            throw new error_1.OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
        }
        if (tool.function.strict !== true) {
            throw new error_1.OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
        }
    }
}
exports.validateInputTools = validateInputTools; //# sourceMappingURL=parser.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AbstractChatCompletionRunner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractChatCompletionRunner = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const RunnableFunction_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/RunnableFunction.js [app-route] (ecmascript)");
const chatCompletionUtils_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/chatCompletionUtils.js [app-route] (ecmascript)");
const EventStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/EventStream.js [app-route] (ecmascript)");
const parser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/parser.js [app-route] (ecmascript)");
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
class AbstractChatCompletionRunner extends EventStream_1.EventStream {
    constructor(){
        super(...arguments);
        _AbstractChatCompletionRunner_instances.add(this);
        this._chatCompletions = [];
        this.messages = [];
    }
    _addChatCompletion(chatCompletion) {
        this._chatCompletions.push(chatCompletion);
        this._emit('chatCompletion', chatCompletion);
        const message = chatCompletion.choices[0]?.message;
        if (message) this._addMessage(message);
        return chatCompletion;
    }
    _addMessage(message, emit = true) {
        if (!('content' in message)) message.content = null;
        this.messages.push(message);
        if (emit) {
            this._emit('message', message);
            if (((0, chatCompletionUtils_1.isFunctionMessage)(message) || (0, chatCompletionUtils_1.isToolMessage)(message)) && message.content) {
                // Note, this assumes that {role: 'tool', content: } is always the result of a call of tool of type=function.
                this._emit('functionCallResult', message.content);
            } else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.function_call) {
                this._emit('functionCall', message.function_call);
            } else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.tool_calls) {
                for (const tool_call of message.tool_calls){
                    if (tool_call.type === 'function') {
                        this._emit('functionCall', tool_call.function);
                    }
                }
            }
        }
    }
    /**
     * @returns a promise that resolves with the final ChatCompletion, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
     */ async finalChatCompletion() {
        await this.done();
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (!completion) throw new error_1.OpenAIError('stream ended without producing a ChatCompletion');
        return completion;
    }
    /**
     * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */ async finalContent() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    }
    /**
     * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
     * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */ async finalMessage() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    }
    /**
     * @returns a promise that resolves with the content of the final FunctionCall, or rejects
     * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
     */ async finalFunctionCall() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    }
    async finalFunctionCallResult() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    }
    async totalUsage() {
        await this.done();
        return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
    }
    allChatCompletions() {
        return [
            ...this._chatCompletions
        ];
    }
    _emitFinal() {
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (completion) this._emit('finalChatCompletion', completion);
        const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
        if (finalMessage) this._emit('finalMessage', finalMessage);
        const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
        if (finalContent) this._emit('finalContent', finalContent);
        const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
        if (finalFunctionCall) this._emit('finalFunctionCall', finalFunctionCall);
        const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
        if (finalFunctionCallResult != null) this._emit('finalFunctionCallResult', finalFunctionCallResult);
        if (this._chatCompletions.some((c)=>c.usage)) {
            this._emit('totalUsage', __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
        }
    }
    async _createChatCompletion(client, params, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
        const chatCompletion = await client.chat.completions.create({
            ...params,
            stream: false
        }, {
            ...options,
            signal: this.controller.signal
        });
        this._connected();
        return this._addChatCompletion((0, parser_1.parseChatCompletion)(chatCompletion, params));
    }
    async _runChatCompletion(client, params, options) {
        for (const message of params.messages){
            this._addMessage(message, false);
        }
        return await this._createChatCompletion(client, params, options);
    }
    async _runFunctions(client, params, options) {
        const role = 'function';
        const { function_call = 'auto', stream, ...restParams } = params;
        const singleFunctionToCall = typeof function_call !== 'string' && function_call?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
        const functionsByName = {};
        for (const f of params.functions){
            functionsByName[f.name || f.function.name] = f;
        }
        const functions = params.functions.map((f)=>({
                name: f.name || f.function.name,
                parameters: f.parameters,
                description: f.description
            }));
        for (const message of params.messages){
            this._addMessage(message, false);
        }
        for(let i = 0; i < maxChatCompletions; ++i){
            const chatCompletion = await this._createChatCompletion(client, {
                ...restParams,
                function_call,
                functions,
                messages: [
                    ...this.messages
                ]
            }, options);
            const message = chatCompletion.choices[0]?.message;
            if (!message) {
                throw new error_1.OpenAIError(`missing message in ChatCompletion response`);
            }
            if (!message.function_call) return;
            const { name, arguments: args } = message.function_call;
            const fn = functionsByName[name];
            if (!fn) {
                const content = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f)=>JSON.stringify(f.name)).join(', ')}. Please try again`;
                this._addMessage({
                    role,
                    name,
                    content
                });
                continue;
            } else if (singleFunctionToCall && singleFunctionToCall !== name) {
                const content = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
                this._addMessage({
                    role,
                    name,
                    content
                });
                continue;
            }
            let parsed;
            try {
                parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;
            } catch (error) {
                this._addMessage({
                    role,
                    name,
                    content: error instanceof Error ? error.message : String(error)
                });
                continue;
            }
            // @ts-expect-error it can't rule out `never` type.
            const rawContent = await fn.function(parsed, this);
            const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
            this._addMessage({
                role,
                name,
                content
            });
            if (singleFunctionToCall) return;
        }
    }
    async _runTools(client, params, options) {
        const role = 'tool';
        const { tool_choice = 'auto', stream, ...restParams } = params;
        const singleFunctionToCall = typeof tool_choice !== 'string' && tool_choice?.function?.name;
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
        // TODO(someday): clean this logic up
        const inputTools = params.tools.map((tool)=>{
            if ((0, parser_1.isAutoParsableTool)(tool)) {
                if (!tool.$callback) {
                    throw new error_1.OpenAIError('Tool given to `.runTools()` that does not have an associated function');
                }
                return {
                    type: 'function',
                    function: {
                        function: tool.$callback,
                        name: tool.function.name,
                        description: tool.function.description || '',
                        parameters: tool.function.parameters,
                        parse: tool.$parseRaw,
                        strict: true
                    }
                };
            }
            return tool;
        });
        const functionsByName = {};
        for (const f of inputTools){
            if (f.type === 'function') {
                functionsByName[f.function.name || f.function.function.name] = f.function;
            }
        }
        const tools = 'tools' in params ? inputTools.map((t)=>t.type === 'function' ? {
                type: 'function',
                function: {
                    name: t.function.name || t.function.function.name,
                    parameters: t.function.parameters,
                    description: t.function.description,
                    strict: t.function.strict
                }
            } : t) : undefined;
        for (const message of params.messages){
            this._addMessage(message, false);
        }
        for(let i = 0; i < maxChatCompletions; ++i){
            const chatCompletion = await this._createChatCompletion(client, {
                ...restParams,
                tool_choice,
                tools,
                messages: [
                    ...this.messages
                ]
            }, options);
            const message = chatCompletion.choices[0]?.message;
            if (!message) {
                throw new error_1.OpenAIError(`missing message in ChatCompletion response`);
            }
            if (!message.tool_calls?.length) {
                return;
            }
            for (const tool_call of message.tool_calls){
                if (tool_call.type !== 'function') continue;
                const tool_call_id = tool_call.id;
                const { name, arguments: args } = tool_call.function;
                const fn = functionsByName[name];
                if (!fn) {
                    const content = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name)=>JSON.stringify(name)).join(', ')}. Please try again`;
                    this._addMessage({
                        role,
                        tool_call_id,
                        content
                    });
                    continue;
                } else if (singleFunctionToCall && singleFunctionToCall !== name) {
                    const content = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
                    this._addMessage({
                        role,
                        tool_call_id,
                        content
                    });
                    continue;
                }
                let parsed;
                try {
                    parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;
                } catch (error) {
                    const content = error instanceof Error ? error.message : String(error);
                    this._addMessage({
                        role,
                        tool_call_id,
                        content
                    });
                    continue;
                }
                // @ts-expect-error it can't rule out `never` type.
                const rawContent = await fn.function(parsed, this);
                const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
                this._addMessage({
                    role,
                    tool_call_id,
                    content
                });
                if (singleFunctionToCall) {
                    return;
                }
            }
        }
        return;
    }
}
exports.AbstractChatCompletionRunner = AbstractChatCompletionRunner;
_AbstractChatCompletionRunner_instances = new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent() {
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage() {
    let i = this.messages.length;
    while(i-- > 0){
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message)) {
            const { function_call, ...rest } = message;
            // TODO: support audio here
            const ret = {
                ...rest,
                content: message.content ?? null,
                refusal: message.refusal ?? null
            };
            if (function_call) {
                ret.function_call = function_call;
            }
            return ret;
        }
    }
    throw new error_1.OpenAIError('stream ended without producing a ChatCompletionMessage with role=assistant');
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall() {
    for(let i = this.messages.length - 1; i >= 0; i--){
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message?.function_call) {
            return message.function_call;
        }
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message?.tool_calls?.length) {
            return message.tool_calls.at(-1)?.function;
        }
    }
    return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult() {
    for(let i = this.messages.length - 1; i >= 0; i--){
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isFunctionMessage)(message) && message.content != null) {
            return message.content;
        }
        if ((0, chatCompletionUtils_1.isToolMessage)(message) && message.content != null && typeof message.content === 'string' && this.messages.some((x)=>x.role === 'assistant' && x.tool_calls?.some((y)=>y.type === 'function' && y.id === message.tool_call_id))) {
            return message.content;
        }
    }
    return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage() {
    const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0
    };
    for (const { usage } of this._chatCompletions){
        if (usage) {
            total.completion_tokens += usage.completion_tokens;
            total.prompt_tokens += usage.prompt_tokens;
            total.total_tokens += usage.total_tokens;
        }
    }
    return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams(params) {
    if (params.n != null && params.n > 1) {
        throw new error_1.OpenAIError('ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.');
    }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent) {
    return typeof rawContent === 'string' ? rawContent : rawContent === undefined ? 'undefined' : JSON.stringify(rawContent);
}; //# sourceMappingURL=AbstractChatCompletionRunner.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionRunner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionRunner = void 0;
const AbstractChatCompletionRunner_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AbstractChatCompletionRunner.js [app-route] (ecmascript)");
const chatCompletionUtils_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/chatCompletionUtils.js [app-route] (ecmascript)");
class ChatCompletionRunner extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {
    /** @deprecated - please use `runTools` instead. */ static runFunctions(client, params, options) {
        const runner = new ChatCompletionRunner();
        const opts = {
            ...options,
            headers: {
                ...options?.headers,
                'X-Stainless-Helper-Method': 'runFunctions'
            }
        };
        runner._run(()=>runner._runFunctions(client, params, opts));
        return runner;
    }
    static runTools(client, params, options) {
        const runner = new ChatCompletionRunner();
        const opts = {
            ...options,
            headers: {
                ...options?.headers,
                'X-Stainless-Helper-Method': 'runTools'
            }
        };
        runner._run(()=>runner._runTools(client, params, opts));
        return runner;
    }
    _addMessage(message, emit = true) {
        super._addMessage(message, emit);
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.content) {
            this._emit('content', message.content);
        }
    }
}
exports.ChatCompletionRunner = ChatCompletionRunner; //# sourceMappingURL=ChatCompletionRunner.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/_vendor/partial-json-parser/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MalformedJSON = exports.PartialJSON = exports.partialParse = void 0;
const STR = 0b000000001;
const NUM = 0b000000010;
const ARR = 0b000000100;
const OBJ = 0b000001000;
const NULL = 0b000010000;
const BOOL = 0b000100000;
const NAN = 0b001000000;
const INFINITY = 0b010000000;
const MINUS_INFINITY = 0b100000000;
const INF = INFINITY | MINUS_INFINITY;
const SPECIAL = NULL | BOOL | INF | NAN;
const ATOM = STR | NUM | SPECIAL;
const COLLECTION = ARR | OBJ;
const ALL = ATOM | COLLECTION;
const Allow = {
    STR,
    NUM,
    ARR,
    OBJ,
    NULL,
    BOOL,
    NAN,
    INFINITY,
    MINUS_INFINITY,
    INF,
    SPECIAL,
    ATOM,
    COLLECTION,
    ALL
};
// The JSON string segment was unable to be parsed completely
class PartialJSON extends Error {
}
exports.PartialJSON = PartialJSON;
class MalformedJSON extends Error {
}
exports.MalformedJSON = MalformedJSON;
/**
 * Parse incomplete JSON
 * @param {string} jsonString Partial JSON to be parsed
 * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details
 * @returns The parsed JSON
 * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)
 * @throws {MalformedJSON} If the JSON is malformed
 */ function parseJSON(jsonString, allowPartial = Allow.ALL) {
    if (typeof jsonString !== 'string') {
        throw new TypeError(`expecting str, got ${typeof jsonString}`);
    }
    if (!jsonString.trim()) {
        throw new Error(`${jsonString} is empty`);
    }
    return _parseJSON(jsonString.trim(), allowPartial);
}
const _parseJSON = (jsonString, allow)=>{
    const length = jsonString.length;
    let index = 0;
    const markPartialJSON = (msg)=>{
        throw new PartialJSON(`${msg} at position ${index}`);
    };
    const throwMalformedError = (msg)=>{
        throw new MalformedJSON(`${msg} at position ${index}`);
    };
    const parseAny = ()=>{
        skipBlank();
        if (index >= length) markPartialJSON('Unexpected end of input');
        if (jsonString[index] === '"') return parseStr();
        if (jsonString[index] === '{') return parseObj();
        if (jsonString[index] === '[') return parseArr();
        if (jsonString.substring(index, index + 4) === 'null' || Allow.NULL & allow && length - index < 4 && 'null'.startsWith(jsonString.substring(index))) {
            index += 4;
            return null;
        }
        if (jsonString.substring(index, index + 4) === 'true' || Allow.BOOL & allow && length - index < 4 && 'true'.startsWith(jsonString.substring(index))) {
            index += 4;
            return true;
        }
        if (jsonString.substring(index, index + 5) === 'false' || Allow.BOOL & allow && length - index < 5 && 'false'.startsWith(jsonString.substring(index))) {
            index += 5;
            return false;
        }
        if (jsonString.substring(index, index + 8) === 'Infinity' || Allow.INFINITY & allow && length - index < 8 && 'Infinity'.startsWith(jsonString.substring(index))) {
            index += 8;
            return Infinity;
        }
        if (jsonString.substring(index, index + 9) === '-Infinity' || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && '-Infinity'.startsWith(jsonString.substring(index))) {
            index += 9;
            return -Infinity;
        }
        if (jsonString.substring(index, index + 3) === 'NaN' || Allow.NAN & allow && length - index < 3 && 'NaN'.startsWith(jsonString.substring(index))) {
            index += 3;
            return NaN;
        }
        return parseNum();
    };
    const parseStr = ()=>{
        const start = index;
        let escape = false;
        index++; // skip initial quote
        while(index < length && (jsonString[index] !== '"' || escape && jsonString[index - 1] === '\\')){
            escape = jsonString[index] === '\\' ? !escape : false;
            index++;
        }
        if (jsonString.charAt(index) == '"') {
            try {
                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));
            } catch (e) {
                throwMalformedError(String(e));
            }
        } else if (Allow.STR & allow) {
            try {
                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '"');
            } catch (e) {
                // SyntaxError: Invalid escape sequence
                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('\\')) + '"');
            }
        }
        markPartialJSON('Unterminated string literal');
    };
    const parseObj = ()=>{
        index++; // skip initial brace
        skipBlank();
        const obj = {};
        try {
            while(jsonString[index] !== '}'){
                skipBlank();
                if (index >= length && Allow.OBJ & allow) return obj;
                const key = parseStr();
                skipBlank();
                index++; // skip colon
                try {
                    const value = parseAny();
                    Object.defineProperty(obj, key, {
                        value,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                } catch (e) {
                    if (Allow.OBJ & allow) return obj;
                    else throw e;
                }
                skipBlank();
                if (jsonString[index] === ',') index++; // skip comma
            }
        } catch (e) {
            if (Allow.OBJ & allow) return obj;
            else markPartialJSON("Expected '}' at end of object");
        }
        index++; // skip final brace
        return obj;
    };
    const parseArr = ()=>{
        index++; // skip initial bracket
        const arr = [];
        try {
            while(jsonString[index] !== ']'){
                arr.push(parseAny());
                skipBlank();
                if (jsonString[index] === ',') {
                    index++; // skip comma
                }
            }
        } catch (e) {
            if (Allow.ARR & allow) {
                return arr;
            }
            markPartialJSON("Expected ']' at end of array");
        }
        index++; // skip final bracket
        return arr;
    };
    const parseNum = ()=>{
        if (index === 0) {
            if (jsonString === '-' && Allow.NUM & allow) markPartialJSON("Not sure what '-' is");
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                if (Allow.NUM & allow) {
                    try {
                        if ('.' === jsonString[jsonString.length - 1]) return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('.')));
                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf('e')));
                    } catch (e) {}
                }
                throwMalformedError(String(e));
            }
        }
        const start = index;
        if (jsonString[index] === '-') index++;
        while(jsonString[index] && !',]}'.includes(jsonString[index]))index++;
        if (index == length && !(Allow.NUM & allow)) markPartialJSON('Unterminated number literal');
        try {
            return JSON.parse(jsonString.substring(start, index));
        } catch (e) {
            if (jsonString.substring(start, index) === '-' && Allow.NUM & allow) markPartialJSON("Not sure what '-' is");
            try {
                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf('e')));
            } catch (e) {
                throwMalformedError(String(e));
            }
        }
    };
    const skipBlank = ()=>{
        while(index < length && ' \n\r\t'.includes(jsonString[index])){
            index++;
        }
    };
    return parseAny();
};
// using this function with malformed JSON is undefined behavior
const partialParse = (input)=>parseJSON(input, Allow.ALL ^ Allow.NUM);
exports.partialParse = partialParse; //# sourceMappingURL=parser.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionStream = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const AbstractChatCompletionRunner_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AbstractChatCompletionRunner.js [app-route] (ecmascript)");
const streaming_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/streaming.js [app-route] (ecmascript)");
const parser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/parser.js [app-route] (ecmascript)");
const parser_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/_vendor/partial-json-parser/parser.js [app-route] (ecmascript)");
class ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {
    constructor(params){
        super();
        _ChatCompletionStream_instances.add(this);
        _ChatCompletionStream_params.set(this, void 0);
        _ChatCompletionStream_choiceEventStates.set(this, void 0);
        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
        __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
    }
    get currentChatCompletionSnapshot() {
        return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    }
    /**
     * Intended for use on the frontend, consuming a stream produced with
     * `.toReadableStream()` on the backend.
     *
     * Note that messages sent to the model do not appear in `.on('message')`
     * in this context.
     */ static fromReadableStream(stream) {
        const runner = new ChatCompletionStream(null);
        runner._run(()=>runner._fromReadableStream(stream));
        return runner;
    }
    static createChatCompletion(client, params, options) {
        const runner = new ChatCompletionStream(params);
        runner._run(()=>runner._runChatCompletion(client, {
                ...params,
                stream: true
            }, {
                ...options,
                headers: {
                    ...options?.headers,
                    'X-Stainless-Helper-Method': 'stream'
                }
            }));
        return runner;
    }
    async _createChatCompletion(client, params, options) {
        super._createChatCompletion;
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        const stream = await client.chat.completions.create({
            ...params,
            stream: true
        }, {
            ...options,
            signal: this.controller.signal
        });
        this._connected();
        for await (const chunk of stream){
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    async _fromReadableStream(readableStream, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        this._connected();
        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);
        let chatId;
        for await (const chunk of stream){
            if (chatId && chatId !== chunk.id) {
                // A new request has been made.
                this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
            }
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
            chatId = chunk.id;
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
    }
    [(_ChatCompletionStream_params = new WeakMap(), _ChatCompletionStream_choiceEventStates = new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {
        if (this.ended) return;
        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
    }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {
        let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
        if (state) {
            return state;
        }
        state = {
            content_done: false,
            refusal_done: false,
            logprobs_content_done: false,
            logprobs_refusal_done: false,
            done_tool_calls: new Set(),
            current_tool_call_index: null
        };
        __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
        return state;
    }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {
        if (this.ended) return;
        const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
        this._emit('chunk', chunk, completion);
        for (const choice of chunk.choices){
            const choiceSnapshot = completion.choices[choice.index];
            if (choice.delta.content != null && choiceSnapshot.message?.role === 'assistant' && choiceSnapshot.message?.content) {
                this._emit('content', choice.delta.content, choiceSnapshot.message.content);
                this._emit('content.delta', {
                    delta: choice.delta.content,
                    snapshot: choiceSnapshot.message.content,
                    parsed: choiceSnapshot.message.parsed
                });
            }
            if (choice.delta.refusal != null && choiceSnapshot.message?.role === 'assistant' && choiceSnapshot.message?.refusal) {
                this._emit('refusal.delta', {
                    delta: choice.delta.refusal,
                    snapshot: choiceSnapshot.message.refusal
                });
            }
            if (choice.logprobs?.content != null && choiceSnapshot.message?.role === 'assistant') {
                this._emit('logprobs.content.delta', {
                    content: choice.logprobs?.content,
                    snapshot: choiceSnapshot.logprobs?.content ?? []
                });
            }
            if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === 'assistant') {
                this._emit('logprobs.refusal.delta', {
                    refusal: choice.logprobs?.refusal,
                    snapshot: choiceSnapshot.logprobs?.refusal ?? []
                });
            }
            const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
            if (choiceSnapshot.finish_reason) {
                __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
                if (state.current_tool_call_index != null) {
                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
                }
            }
            for (const toolCall of choice.delta.tool_calls ?? []){
                if (state.current_tool_call_index !== toolCall.index) {
                    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
                    // new tool call started, the previous one is done
                    if (state.current_tool_call_index != null) {
                        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
                    }
                }
                state.current_tool_call_index = toolCall.index;
            }
            for (const toolCallDelta of choice.delta.tool_calls ?? []){
                const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
                if (!toolCallSnapshot?.type) {
                    continue;
                }
                if (toolCallSnapshot?.type === 'function') {
                    this._emit('tool_calls.function.arguments.delta', {
                        name: toolCallSnapshot.function?.name,
                        index: toolCallDelta.index,
                        arguments: toolCallSnapshot.function.arguments,
                        parsed_arguments: toolCallSnapshot.function.parsed_arguments,
                        arguments_delta: toolCallDelta.function?.arguments ?? ''
                    });
                } else {
                    assertNever(toolCallSnapshot?.type);
                }
            }
        }
    }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {
        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (state.done_tool_calls.has(toolCallIndex)) {
            // we've already fired the done event
            return;
        }
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
        if (!toolCallSnapshot) {
            throw new Error('no tool call snapshot');
        }
        if (!toolCallSnapshot.type) {
            throw new Error('tool call snapshot missing `type`');
        }
        if (toolCallSnapshot.type === 'function') {
            const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.tools?.find((tool)=>tool.type === 'function' && tool.function.name === toolCallSnapshot.function.name);
            this._emit('tool_calls.function.arguments.done', {
                name: toolCallSnapshot.function.name,
                index: toolCallIndex,
                arguments: toolCallSnapshot.function.arguments,
                parsed_arguments: (0, parser_1.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
            });
        } else {
            assertNever(toolCallSnapshot.type);
        }
    }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {
        const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.message.content && !state.content_done) {
            state.content_done = true;
            const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
            this._emit('content.done', {
                content: choiceSnapshot.message.content,
                parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
            });
        }
        if (choiceSnapshot.message.refusal && !state.refusal_done) {
            state.refusal_done = true;
            this._emit('refusal.done', {
                refusal: choiceSnapshot.message.refusal
            });
        }
        if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
            state.logprobs_content_done = true;
            this._emit('logprobs.content.done', {
                content: choiceSnapshot.logprobs.content
            });
        }
        if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
            state.logprobs_refusal_done = true;
            this._emit('logprobs.refusal.done', {
                refusal: choiceSnapshot.logprobs.refusal
            });
        }
    }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {
        if (this.ended) {
            throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        if (!snapshot) {
            throw new error_1.OpenAIError(`request ended without sending any chunks`);
        }
        __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
        __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
        return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
    }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {
        const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.response_format;
        if ((0, parser_1.isAutoParsableResponseFormat)(responseFormat)) {
            return responseFormat;
        }
        return null;
    }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {
        var _a, _b, _c, _d;
        let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        const { choices, ...rest } = chunk;
        if (!snapshot) {
            snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
                ...rest,
                choices: []
            }, "f");
        } else {
            Object.assign(snapshot, rest);
        }
        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices){
            let choice = snapshot.choices[index];
            if (!choice) {
                choice = snapshot.choices[index] = {
                    finish_reason,
                    index,
                    message: {},
                    logprobs,
                    ...other
                };
            }
            if (logprobs) {
                if (!choice.logprobs) {
                    choice.logprobs = Object.assign({}, logprobs);
                } else {
                    const { content, refusal, ...rest } = logprobs;
                    assertIsEmpty(rest);
                    Object.assign(choice.logprobs, rest);
                    if (content) {
                        (_a = choice.logprobs).content ?? (_a.content = []);
                        choice.logprobs.content.push(...content);
                    }
                    if (refusal) {
                        (_b = choice.logprobs).refusal ?? (_b.refusal = []);
                        choice.logprobs.refusal.push(...refusal);
                    }
                }
            }
            if (finish_reason) {
                choice.finish_reason = finish_reason;
                if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && (0, parser_1.hasAutoParseableInput)(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
                    if (finish_reason === 'length') {
                        throw new error_1.LengthFinishReasonError();
                    }
                    if (finish_reason === 'content_filter') {
                        throw new error_1.ContentFilterFinishReasonError();
                    }
                }
            }
            Object.assign(choice, other);
            if (!delta) continue; // Shouldn't happen; just in case.
            const { content, refusal, function_call, role, tool_calls, ...rest } = delta;
            assertIsEmpty(rest);
            Object.assign(choice.message, rest);
            if (refusal) {
                choice.message.refusal = (choice.message.refusal || '') + refusal;
            }
            if (role) choice.message.role = role;
            if (function_call) {
                if (!choice.message.function_call) {
                    choice.message.function_call = function_call;
                } else {
                    if (function_call.name) choice.message.function_call.name = function_call.name;
                    if (function_call.arguments) {
                        (_c = choice.message.function_call).arguments ?? (_c.arguments = '');
                        choice.message.function_call.arguments += function_call.arguments;
                    }
                }
            }
            if (content) {
                choice.message.content = (choice.message.content || '') + content;
                if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
                    choice.message.parsed = (0, parser_2.partialParse)(choice.message.content);
                }
            }
            if (tool_calls) {
                if (!choice.message.tool_calls) choice.message.tool_calls = [];
                for (const { index, id, type, function: fn, ...rest } of tool_calls){
                    const tool_call = (_d = choice.message.tool_calls)[index] ?? (_d[index] = {});
                    Object.assign(tool_call, rest);
                    if (id) tool_call.id = id;
                    if (type) tool_call.type = type;
                    if (fn) tool_call.function ?? (tool_call.function = {
                        name: fn.name ?? '',
                        arguments: ''
                    });
                    if (fn?.name) tool_call.function.name = fn.name;
                    if (fn?.arguments) {
                        tool_call.function.arguments += fn.arguments;
                        if ((0, parser_1.shouldParseToolCall)(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
                            tool_call.function.parsed_arguments = (0, parser_2.partialParse)(tool_call.function.arguments);
                        }
                    }
                }
            }
        }
        return snapshot;
    }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on('chunk', (chunk)=>{
            const reader = readQueue.shift();
            if (reader) {
                reader.resolve(chunk);
            } else {
                pushQueue.push(chunk);
            }
        });
        this.on('end', ()=>{
            done = true;
            for (const reader of readQueue){
                reader.resolve(undefined);
            }
            readQueue.length = 0;
        });
        this.on('abort', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        this.on('error', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        return {
            next: async ()=>{
                if (!pushQueue.length) {
                    if (done) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    return new Promise((resolve, reject)=>readQueue.push({
                            resolve,
                            reject
                        })).then((chunk)=>chunk ? {
                            value: chunk,
                            done: false
                        } : {
                            value: undefined,
                            done: true
                        });
                }
                const chunk = pushQueue.shift();
                return {
                    value: chunk,
                    done: false
                };
            },
            return: async ()=>{
                this.abort();
                return {
                    value: undefined,
                    done: true
                };
            }
        };
    }
    toReadableStream() {
        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
    }
}
exports.ChatCompletionStream = ChatCompletionStream;
function finalizeChatCompletion(snapshot, params) {
    const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
    const completion = {
        ...rest,
        id,
        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest })=>{
            if (!finish_reason) {
                throw new error_1.OpenAIError(`missing finish_reason for choice ${index}`);
            }
            const { content = null, function_call, tool_calls, ...messageRest } = message;
            const role = message.role; // this is what we expect; in theory it could be different which would make our types a slight lie but would be fine.
            if (!role) {
                throw new error_1.OpenAIError(`missing role for choice ${index}`);
            }
            if (function_call) {
                const { arguments: args, name } = function_call;
                if (args == null) {
                    throw new error_1.OpenAIError(`missing function_call.arguments for choice ${index}`);
                }
                if (!name) {
                    throw new error_1.OpenAIError(`missing function_call.name for choice ${index}`);
                }
                return {
                    ...choiceRest,
                    message: {
                        content,
                        function_call: {
                            arguments: args,
                            name
                        },
                        role,
                        refusal: message.refusal ?? null
                    },
                    finish_reason,
                    index,
                    logprobs
                };
            }
            if (tool_calls) {
                return {
                    ...choiceRest,
                    index,
                    finish_reason,
                    logprobs,
                    message: {
                        ...messageRest,
                        role,
                        content,
                        refusal: message.refusal ?? null,
                        tool_calls: tool_calls.map((tool_call, i)=>{
                            const { function: fn, type, id, ...toolRest } = tool_call;
                            const { arguments: args, name, ...fnRest } = fn || {};
                            if (id == null) {
                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].id\n${str(snapshot)}`);
                            }
                            if (type == null) {
                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].type\n${str(snapshot)}`);
                            }
                            if (name == null) {
                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\n${str(snapshot)}`);
                            }
                            if (args == null) {
                                throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\n${str(snapshot)}`);
                            }
                            return {
                                ...toolRest,
                                id,
                                type,
                                function: {
                                    ...fnRest,
                                    name,
                                    arguments: args
                                }
                            };
                        })
                    }
                };
            }
            return {
                ...choiceRest,
                message: {
                    ...messageRest,
                    content,
                    role,
                    refusal: message.refusal ?? null
                },
                finish_reason,
                index,
                logprobs
            };
        }),
        created,
        model,
        object: 'chat.completion',
        ...system_fingerprint ? {
            system_fingerprint
        } : {}
    };
    return (0, parser_1.maybeParseChatCompletion)(completion, params);
}
function str(x) {
    return JSON.stringify(x);
}
/**
 * Ensures the given argument is an empty object, useful for
 * asserting that all known properties on an object have been
 * destructured.
 */ function assertIsEmpty(obj) {
    return;
}
function assertNever(_x) {} //# sourceMappingURL=ChatCompletionStream.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStreamingRunner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionStreamingRunner = void 0;
const ChatCompletionStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStream.js [app-route] (ecmascript)");
class ChatCompletionStreamingRunner extends ChatCompletionStream_1.ChatCompletionStream {
    static fromReadableStream(stream) {
        const runner = new ChatCompletionStreamingRunner(null);
        runner._run(()=>runner._fromReadableStream(stream));
        return runner;
    }
    /** @deprecated - please use `runTools` instead. */ static runFunctions(client, params, options) {
        const runner = new ChatCompletionStreamingRunner(null);
        const opts = {
            ...options,
            headers: {
                ...options?.headers,
                'X-Stainless-Helper-Method': 'runFunctions'
            }
        };
        runner._run(()=>runner._runFunctions(client, params, opts));
        return runner;
    }
    static runTools(client, params, options) {
        const runner = new ChatCompletionStreamingRunner(// @ts-expect-error TODO these types are incompatible
        params);
        const opts = {
            ...options,
            headers: {
                ...options?.headers,
                'X-Stainless-Helper-Method': 'runTools'
            }
        };
        runner._run(()=>runner._runTools(client, params, opts));
        return runner;
    }
}
exports.ChatCompletionStreamingRunner = ChatCompletionStreamingRunner; //# sourceMappingURL=ChatCompletionStreamingRunner.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/chat/completions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Completions = exports.ChatCompletionRunner = exports.ChatCompletionStream = exports.ParsingToolFunction = exports.ParsingFunction = exports.ChatCompletionStreamingRunner = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const ChatCompletionRunner_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionRunner.js [app-route] (ecmascript)");
const ChatCompletionStreamingRunner_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStreamingRunner.js [app-route] (ecmascript)");
const ChatCompletionStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStream.js [app-route] (ecmascript)");
const parser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/parser.js [app-route] (ecmascript)");
var ChatCompletionStreamingRunner_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStreamingRunner.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionStreamingRunner", {
    enumerable: true,
    get: function() {
        return ChatCompletionStreamingRunner_2.ChatCompletionStreamingRunner;
    }
});
var RunnableFunction_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/RunnableFunction.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ParsingFunction", {
    enumerable: true,
    get: function() {
        return RunnableFunction_1.ParsingFunction;
    }
});
Object.defineProperty(exports, "ParsingToolFunction", {
    enumerable: true,
    get: function() {
        return RunnableFunction_1.ParsingToolFunction;
    }
});
var ChatCompletionStream_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionStream", {
    enumerable: true,
    get: function() {
        return ChatCompletionStream_2.ChatCompletionStream;
    }
});
var ChatCompletionRunner_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ChatCompletionRunner.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatCompletionRunner", {
    enumerable: true,
    get: function() {
        return ChatCompletionRunner_2.ChatCompletionRunner;
    }
});
class Completions extends resource_1.APIResource {
    parse(body, options) {
        (0, parser_1.validateInputTools)(body.tools);
        return this._client.chat.completions.create(body, {
            ...options,
            headers: {
                ...options?.headers,
                'X-Stainless-Helper-Method': 'beta.chat.completions.parse'
            }
        })._thenUnwrap((completion)=>(0, parser_1.parseChatCompletion)(completion, body));
    }
    runFunctions(body, options) {
        if (body.stream) {
            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
        }
        return ChatCompletionRunner_1.ChatCompletionRunner.runFunctions(this._client, body, options);
    }
    runTools(body, options) {
        if (body.stream) {
            return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runTools(this._client, body, options);
        }
        return ChatCompletionRunner_1.ChatCompletionRunner.runTools(this._client, body, options);
    }
    /**
     * Creates a chat completion stream
     */ stream(body, options) {
        return ChatCompletionStream_1.ChatCompletionStream.createChatCompletion(this._client, body, options);
    }
}
exports.Completions = Completions; //# sourceMappingURL=completions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/chat/chat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Chat = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const CompletionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/chat/completions.js [app-route] (ecmascript)"));
class Chat extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.completions = new CompletionsAPI.Completions(this._client);
    }
}
exports.Chat = Chat;
(function(Chat) {
    Chat.Completions = CompletionsAPI.Completions;
})(Chat = exports.Chat || (exports.Chat = {})); //# sourceMappingURL=chat.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/sessions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sessions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Sessions extends resource_1.APIResource {
    /**
     * Create an ephemeral API token for use in client-side applications with the
     * Realtime API. Can be configured with the same session parameters as the
     * `session.update` client event.
     *
     * It responds with a session object, plus a `client_secret` key which contains a
     * usable ephemeral API token that can be used to authenticate browser clients for
     * the Realtime API.
     *
     * @example
     * ```ts
     * const session =
     *   await client.beta.realtime.sessions.create();
     * ```
     */ create(body, options) {
        return this._client.post('/realtime/sessions', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.Sessions = Sessions; //# sourceMappingURL=sessions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/transcription-sessions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriptionSessions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class TranscriptionSessions extends resource_1.APIResource {
    /**
     * Create an ephemeral API token for use in client-side applications with the
     * Realtime API specifically for realtime transcriptions. Can be configured with
     * the same session parameters as the `transcription_session.update` client event.
     *
     * It responds with a session object, plus a `client_secret` key which contains a
     * usable ephemeral API token that can be used to authenticate browser clients for
     * the Realtime API.
     *
     * @example
     * ```ts
     * const transcriptionSession =
     *   await client.beta.realtime.transcriptionSessions.create();
     * ```
     */ create(body, options) {
        return this._client.post('/realtime/transcription_sessions', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.TranscriptionSessions = TranscriptionSessions; //# sourceMappingURL=transcription-sessions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/realtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Realtime = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const SessionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/sessions.js [app-route] (ecmascript)"));
const sessions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/sessions.js [app-route] (ecmascript)");
const TranscriptionSessionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/transcription-sessions.js [app-route] (ecmascript)"));
const transcription_sessions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/transcription-sessions.js [app-route] (ecmascript)");
class Realtime extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.sessions = new SessionsAPI.Sessions(this._client);
        this.transcriptionSessions = new TranscriptionSessionsAPI.TranscriptionSessions(this._client);
    }
}
exports.Realtime = Realtime;
Realtime.Sessions = sessions_1.Sessions;
Realtime.TranscriptionSessions = transcription_sessions_1.TranscriptionSessions; //# sourceMappingURL=realtime.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/messages.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessagesPage = exports.Messages = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
/**
 * @deprecated The Assistants API is deprecated in favor of the Responses API
 */ class Messages extends resource_1.APIResource {
    /**
     * Create a message.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ create(threadId, body, options) {
        return this._client.post(`/threads/${threadId}/messages`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieve a message.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ retrieve(threadId, messageId, options) {
        return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Modifies a message.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ update(threadId, messageId, body, options) {
        return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(threadId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(threadId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Deletes a message.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ del(threadId, messageId, options) {
        return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.Messages = Messages;
class MessagesPage extends pagination_1.CursorPage {
}
exports.MessagesPage = MessagesPage;
Messages.MessagesPage = MessagesPage; //# sourceMappingURL=messages.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/steps.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunStepsPage = exports.Steps = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
/**
 * @deprecated The Assistants API is deprecated in favor of the Responses API
 */ class Steps extends resource_1.APIResource {
    retrieve(threadId, runId, stepId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.retrieve(threadId, runId, stepId, {}, query);
        }
        return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(threadId, runId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(threadId, runId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.Steps = Steps;
class RunStepsPage extends pagination_1.CursorPage {
}
exports.RunStepsPage = RunStepsPage;
Steps.RunStepsPage = RunStepsPage; //# sourceMappingURL=steps.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/runs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunsPage = exports.Runs = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const AssistantStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AssistantStream.js [app-route] (ecmascript)");
const core_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const StepsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/steps.js [app-route] (ecmascript)"));
const steps_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/steps.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
/**
 * @deprecated The Assistants API is deprecated in favor of the Responses API
 */ class Runs extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.steps = new StepsAPI.Steps(this._client);
    }
    create(threadId, params, options) {
        const { include, ...body } = params;
        return this._client.post(`/threads/${threadId}/runs`, {
            query: {
                include
            },
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            },
            stream: params.stream ?? false
        });
    }
    /**
     * Retrieves a run.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ retrieve(threadId, runId, options) {
        return this._client.get(`/threads/${threadId}/runs/${runId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Modifies a run.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ update(threadId, runId, body, options) {
        return this._client.post(`/threads/${threadId}/runs/${runId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(threadId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(threadId, {}, query);
        }
        return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Cancels a run that is `in_progress`.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ cancel(threadId, runId, options) {
        return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * A helper to create a run an poll for a terminal state. More information on Run
     * lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */ async createAndPoll(threadId, body, options) {
        const run = await this.create(threadId, body, options);
        return await this.poll(threadId, run.id, options);
    }
    /**
     * Create a Run stream
     *
     * @deprecated use `stream` instead
     */ createAndStream(threadId, body, options) {
        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    /**
     * A helper to poll a run status until it reaches a terminal state. More
     * information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */ async poll(threadId, runId, options) {
        const headers = {
            ...options?.headers,
            'X-Stainless-Poll-Helper': 'true'
        };
        if (options?.pollIntervalMs) {
            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();
        }
        while(true){
            const { data: run, response } = await this.retrieve(threadId, runId, {
                ...options,
                headers: {
                    ...options?.headers,
                    ...headers
                }
            }).withResponse();
            switch(run.status){
                //If we are in any sort of intermediate state we poll
                case 'queued':
                case 'in_progress':
                case 'cancelling':
                    let sleepInterval = 5000;
                    if (options?.pollIntervalMs) {
                        sleepInterval = options.pollIntervalMs;
                    } else {
                        const headerInterval = response.headers.get('openai-poll-after-ms');
                        if (headerInterval) {
                            const headerIntervalMs = parseInt(headerInterval);
                            if (!isNaN(headerIntervalMs)) {
                                sleepInterval = headerIntervalMs;
                            }
                        }
                    }
                    await (0, core_2.sleep)(sleepInterval);
                    break;
                //We return the run in any terminal state.
                case 'requires_action':
                case 'incomplete':
                case 'cancelled':
                case 'completed':
                case 'failed':
                case 'expired':
                    return run;
            }
        }
    }
    /**
     * Create a Run stream
     */ stream(threadId, body, options) {
        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
    }
    submitToolOutputs(threadId, runId, body, options) {
        return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            },
            stream: body.stream ?? false
        });
    }
    /**
     * A helper to submit a tool output to a run and poll for a terminal run state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */ async submitToolOutputsAndPoll(threadId, runId, body, options) {
        const run = await this.submitToolOutputs(threadId, runId, body, options);
        return await this.poll(threadId, run.id, options);
    }
    /**
     * Submit the tool outputs from a previous run and stream the run to a terminal
     * state. More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */ submitToolOutputsStream(threadId, runId, body, options) {
        return AssistantStream_1.AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
    }
}
exports.Runs = Runs;
class RunsPage extends pagination_1.CursorPage {
}
exports.RunsPage = RunsPage;
Runs.RunsPage = RunsPage;
Runs.Steps = steps_1.Steps;
Runs.RunStepsPage = steps_1.RunStepsPage; //# sourceMappingURL=runs.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/threads.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Threads = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const AssistantStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/AssistantStream.js [app-route] (ecmascript)");
const MessagesAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/messages.js [app-route] (ecmascript)"));
const messages_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/messages.js [app-route] (ecmascript)");
const RunsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/runs.js [app-route] (ecmascript)"));
const runs_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/runs/runs.js [app-route] (ecmascript)");
/**
 * @deprecated The Assistants API is deprecated in favor of the Responses API
 */ class Threads extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.runs = new RunsAPI.Runs(this._client);
        this.messages = new MessagesAPI.Messages(this._client);
    }
    create(body = {}, options) {
        if ((0, core_1.isRequestOptions)(body)) {
            return this.create({}, body);
        }
        return this._client.post('/threads', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieves a thread.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ retrieve(threadId, options) {
        return this._client.get(`/threads/${threadId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Modifies a thread.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ update(threadId, body, options) {
        return this._client.post(`/threads/${threadId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Delete a thread.
     *
     * @deprecated The Assistants API is deprecated in favor of the Responses API
     */ del(threadId, options) {
        return this._client.delete(`/threads/${threadId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    createAndRun(body, options) {
        return this._client.post('/threads/runs', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            },
            stream: body.stream ?? false
        });
    }
    /**
     * A helper to create a thread, start a run and then poll for a terminal state.
     * More information on Run lifecycles can be found here:
     * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
     */ async createAndRunPoll(body, options) {
        const run = await this.createAndRun(body, options);
        return await this.runs.poll(run.thread_id, run.id, options);
    }
    /**
     * Create a thread and stream the run back
     */ createAndRunStream(body, options) {
        return AssistantStream_1.AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
    }
}
exports.Threads = Threads;
Threads.Runs = runs_1.Runs;
Threads.RunsPage = runs_1.RunsPage;
Threads.Messages = messages_1.Messages;
Threads.MessagesPage = messages_1.MessagesPage; //# sourceMappingURL=threads.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/beta.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Beta = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const AssistantsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/assistants.js [app-route] (ecmascript)"));
const ChatAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/chat/chat.js [app-route] (ecmascript)"));
const assistants_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/assistants.js [app-route] (ecmascript)");
const RealtimeAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/realtime.js [app-route] (ecmascript)"));
const realtime_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/realtime/realtime.js [app-route] (ecmascript)");
const ThreadsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/threads.js [app-route] (ecmascript)"));
const threads_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/threads/threads.js [app-route] (ecmascript)");
const chat_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/chat/chat.js [app-route] (ecmascript)");
class Beta extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.realtime = new RealtimeAPI.Realtime(this._client);
        this.chat = new ChatAPI.Chat(this._client);
        this.assistants = new AssistantsAPI.Assistants(this._client);
        this.threads = new ThreadsAPI.Threads(this._client);
    }
}
exports.Beta = Beta;
Beta.Realtime = realtime_1.Realtime;
Beta.Assistants = assistants_1.Assistants;
Beta.AssistantsPage = assistants_1.AssistantsPage;
Beta.Threads = threads_1.Threads; //# sourceMappingURL=beta.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/completions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Completions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Completions extends resource_1.APIResource {
    create(body, options) {
        return this._client.post('/completions', {
            body,
            ...options,
            stream: body.stream ?? false
        });
    }
}
exports.Completions = Completions; //# sourceMappingURL=completions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/content.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Content = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Content extends resource_1.APIResource {
    /**
     * Retrieve Container File Content
     */ retrieve(containerId, fileId, options) {
        return this._client.get(`/containers/${containerId}/files/${fileId}/content`, {
            ...options,
            headers: {
                Accept: 'application/binary',
                ...options?.headers
            },
            __binaryResponse: true
        });
    }
}
exports.Content = Content; //# sourceMappingURL=content.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/files.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileListResponsesPage = exports.Files = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
const ContentAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/content.js [app-route] (ecmascript)"));
const content_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/content.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Files extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.content = new ContentAPI.Content(this._client);
    }
    /**
     * Create a Container File
     *
     * You can send either a multipart/form-data request with the raw file content, or
     * a JSON request with a file ID.
     */ create(containerId, body, options) {
        return this._client.post(`/containers/${containerId}/files`, Core.multipartFormRequestOptions({
            body,
            ...options
        }));
    }
    /**
     * Retrieve Container File
     */ retrieve(containerId, fileId, options) {
        return this._client.get(`/containers/${containerId}/files/${fileId}`, options);
    }
    list(containerId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(containerId, {}, query);
        }
        return this._client.getAPIList(`/containers/${containerId}/files`, FileListResponsesPage, {
            query,
            ...options
        });
    }
    /**
     * Delete Container File
     */ del(containerId, fileId, options) {
        return this._client.delete(`/containers/${containerId}/files/${fileId}`, {
            ...options,
            headers: {
                Accept: '*/*',
                ...options?.headers
            }
        });
    }
}
exports.Files = Files;
class FileListResponsesPage extends pagination_1.CursorPage {
}
exports.FileListResponsesPage = FileListResponsesPage;
Files.FileListResponsesPage = FileListResponsesPage;
Files.Content = content_1.Content; //# sourceMappingURL=files.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/containers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContainerListResponsesPage = exports.Containers = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const FilesAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/files.js [app-route] (ecmascript)"));
const files_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/files/files.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Containers extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.files = new FilesAPI.Files(this._client);
    }
    /**
     * Create Container
     */ create(body, options) {
        return this._client.post('/containers', {
            body,
            ...options
        });
    }
    /**
     * Retrieve Container
     */ retrieve(containerId, options) {
        return this._client.get(`/containers/${containerId}`, options);
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/containers', ContainerListResponsesPage, {
            query,
            ...options
        });
    }
    /**
     * Delete Container
     */ del(containerId, options) {
        return this._client.delete(`/containers/${containerId}`, {
            ...options,
            headers: {
                Accept: '*/*',
                ...options?.headers
            }
        });
    }
}
exports.Containers = Containers;
class ContainerListResponsesPage extends pagination_1.CursorPage {
}
exports.ContainerListResponsesPage = ContainerListResponsesPage;
Containers.ContainerListResponsesPage = ContainerListResponsesPage;
Containers.Files = files_1.Files;
Containers.FileListResponsesPage = files_1.FileListResponsesPage; //# sourceMappingURL=containers.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/embeddings.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Embeddings = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
class Embeddings extends resource_1.APIResource {
    /**
     * Creates an embedding vector representing the input text.
     *
     * @example
     * ```ts
     * const createEmbeddingResponse =
     *   await client.embeddings.create({
     *     input: 'The quick brown fox jumped over the lazy dog',
     *     model: 'text-embedding-3-small',
     *   });
     * ```
     */ create(body, options) {
        const hasUserProvidedEncodingFormat = !!body.encoding_format;
        // No encoding_format specified, defaulting to base64 for performance reasons
        // See https://github.com/openai/openai-node/pull/1312
        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : 'base64';
        if (hasUserProvidedEncodingFormat) {
            Core.debug('Request', 'User defined encoding_format:', body.encoding_format);
        }
        const response = this._client.post('/embeddings', {
            body: {
                ...body,
                encoding_format: encoding_format
            },
            ...options
        });
        // if the user specified an encoding_format, return the response as-is
        if (hasUserProvidedEncodingFormat) {
            return response;
        }
        // in this stage, we are sure the user did not specify an encoding_format
        // and we defaulted to base64 for performance reasons
        // we are sure then that the response is base64 encoded, let's decode it
        // the returned result will be a float32 array since this is OpenAI API's default encoding
        Core.debug('response', 'Decoding base64 embeddings to float32 array');
        return response._thenUnwrap((response)=>{
            if (response && response.data) {
                response.data.forEach((embeddingBase64Obj)=>{
                    const embeddingBase64Str = embeddingBase64Obj.embedding;
                    embeddingBase64Obj.embedding = Core.toFloat32Array(embeddingBase64Str);
                });
            }
            return response;
        });
    }
}
exports.Embeddings = Embeddings; //# sourceMappingURL=embeddings.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/output-items.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OutputItemListResponsesPage = exports.OutputItems = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class OutputItems extends resource_1.APIResource {
    /**
     * Get an evaluation run output item by ID.
     */ retrieve(evalId, runId, outputItemId, options) {
        return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);
    }
    list(evalId, runId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(evalId, runId, {}, query);
        }
        return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, {
            query,
            ...options
        });
    }
}
exports.OutputItems = OutputItems;
class OutputItemListResponsesPage extends pagination_1.CursorPage {
}
exports.OutputItemListResponsesPage = OutputItemListResponsesPage;
OutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage; //# sourceMappingURL=output-items.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/runs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RunListResponsesPage = exports.Runs = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const OutputItemsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/output-items.js [app-route] (ecmascript)"));
const output_items_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/output-items.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Runs extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.outputItems = new OutputItemsAPI.OutputItems(this._client);
    }
    /**
     * Kicks off a new run for a given evaluation, specifying the data source, and what
     * model configuration to use to test. The datasource will be validated against the
     * schema specified in the config of the evaluation.
     */ create(evalId, body, options) {
        return this._client.post(`/evals/${evalId}/runs`, {
            body,
            ...options
        });
    }
    /**
     * Get an evaluation run by ID.
     */ retrieve(evalId, runId, options) {
        return this._client.get(`/evals/${evalId}/runs/${runId}`, options);
    }
    list(evalId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(evalId, {}, query);
        }
        return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, {
            query,
            ...options
        });
    }
    /**
     * Delete an eval run.
     */ del(evalId, runId, options) {
        return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);
    }
    /**
     * Cancel an ongoing evaluation run.
     */ cancel(evalId, runId, options) {
        return this._client.post(`/evals/${evalId}/runs/${runId}`, options);
    }
}
exports.Runs = Runs;
class RunListResponsesPage extends pagination_1.CursorPage {
}
exports.RunListResponsesPage = RunListResponsesPage;
Runs.RunListResponsesPage = RunListResponsesPage;
Runs.OutputItems = output_items_1.OutputItems;
Runs.OutputItemListResponsesPage = output_items_1.OutputItemListResponsesPage; //# sourceMappingURL=runs.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/evals.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvalListResponsesPage = exports.Evals = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const RunsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/runs.js [app-route] (ecmascript)"));
const runs_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/runs/runs.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Evals extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.runs = new RunsAPI.Runs(this._client);
    }
    /**
     * Create the structure of an evaluation that can be used to test a model's
     * performance. An evaluation is a set of testing criteria and the config for a
     * data source, which dictates the schema of the data used in the evaluation. After
     * creating an evaluation, you can run it on different models and model parameters.
     * We support several types of graders and datasources. For more information, see
     * the [Evals guide](https://platform.openai.com/docs/guides/evals).
     */ create(body, options) {
        return this._client.post('/evals', {
            body,
            ...options
        });
    }
    /**
     * Get an evaluation by ID.
     */ retrieve(evalId, options) {
        return this._client.get(`/evals/${evalId}`, options);
    }
    /**
     * Update certain properties of an evaluation.
     */ update(evalId, body, options) {
        return this._client.post(`/evals/${evalId}`, {
            body,
            ...options
        });
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/evals', EvalListResponsesPage, {
            query,
            ...options
        });
    }
    /**
     * Delete an evaluation.
     */ del(evalId, options) {
        return this._client.delete(`/evals/${evalId}`, options);
    }
}
exports.Evals = Evals;
class EvalListResponsesPage extends pagination_1.CursorPage {
}
exports.EvalListResponsesPage = EvalListResponsesPage;
Evals.EvalListResponsesPage = EvalListResponsesPage;
Evals.Runs = runs_1.Runs;
Evals.RunListResponsesPage = runs_1.RunListResponsesPage; //# sourceMappingURL=evals.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/files.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileObjectsPage = exports.Files = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const core_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Files extends resource_1.APIResource {
    /**
     * Upload a file that can be used across various endpoints. Individual files can be
     * up to 512 MB, and the size of all files uploaded by one organization can be up
     * to 100 GB.
     *
     * The Assistants API supports files up to 2 million tokens and of specific file
     * types. See the
     * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
     * details.
     *
     * The Fine-tuning API only supports `.jsonl` files. The input also has certain
     * required formats for fine-tuning
     * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
     * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
     * models.
     *
     * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
     * has a specific required
     * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
     *
     * Please [contact us](https://help.openai.com/) if you need to increase these
     * storage limits.
     */ create(body, options) {
        return this._client.post('/files', Core.multipartFormRequestOptions({
            body,
            ...options
        }));
    }
    /**
     * Returns information about a specific file.
     */ retrieve(fileId, options) {
        return this._client.get(`/files/${fileId}`, options);
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/files', FileObjectsPage, {
            query,
            ...options
        });
    }
    /**
     * Delete a file.
     */ del(fileId, options) {
        return this._client.delete(`/files/${fileId}`, options);
    }
    /**
     * Returns the contents of the specified file.
     */ content(fileId, options) {
        return this._client.get(`/files/${fileId}/content`, {
            ...options,
            headers: {
                Accept: 'application/binary',
                ...options?.headers
            },
            __binaryResponse: true
        });
    }
    /**
     * Returns the contents of the specified file.
     *
     * @deprecated The `.content()` method should be used instead
     */ retrieveContent(fileId, options) {
        return this._client.get(`/files/${fileId}/content`, options);
    }
    /**
     * Waits for the given file to be processed, default timeout is 30 mins.
     */ async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {
        const TERMINAL_STATES = new Set([
            'processed',
            'error',
            'deleted'
        ]);
        const start = Date.now();
        let file = await this.retrieve(id);
        while(!file.status || !TERMINAL_STATES.has(file.status)){
            await (0, core_2.sleep)(pollInterval);
            file = await this.retrieve(id);
            if (Date.now() - start > maxWait) {
                throw new error_1.APIConnectionTimeoutError({
                    message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
                });
            }
        }
        return file;
    }
}
exports.Files = Files;
class FileObjectsPage extends pagination_1.CursorPage {
}
exports.FileObjectsPage = FileObjectsPage;
Files.FileObjectsPage = FileObjectsPage; //# sourceMappingURL=files.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/methods.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Methods = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Methods extends resource_1.APIResource {
}
exports.Methods = Methods; //# sourceMappingURL=methods.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/graders.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Graders = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Graders extends resource_1.APIResource {
    /**
     * Run a grader.
     *
     * @example
     * ```ts
     * const response = await client.fineTuning.alpha.graders.run({
     *   grader: {
     *     input: 'input',
     *     name: 'name',
     *     operation: 'eq',
     *     reference: 'reference',
     *     type: 'string_check',
     *   },
     *   model_sample: 'model_sample',
     *   reference_answer: 'string',
     * });
     * ```
     */ run(body, options) {
        return this._client.post('/fine_tuning/alpha/graders/run', {
            body,
            ...options
        });
    }
    /**
     * Validate a grader.
     *
     * @example
     * ```ts
     * const response =
     *   await client.fineTuning.alpha.graders.validate({
     *     grader: {
     *       input: 'input',
     *       name: 'name',
     *       operation: 'eq',
     *       reference: 'reference',
     *       type: 'string_check',
     *     },
     *   });
     * ```
     */ validate(body, options) {
        return this._client.post('/fine_tuning/alpha/graders/validate', {
            body,
            ...options
        });
    }
}
exports.Graders = Graders; //# sourceMappingURL=graders.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/alpha.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Alpha = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const GradersAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/graders.js [app-route] (ecmascript)"));
const graders_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/graders.js [app-route] (ecmascript)");
class Alpha extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.graders = new GradersAPI.Graders(this._client);
    }
}
exports.Alpha = Alpha;
Alpha.Graders = graders_1.Graders; //# sourceMappingURL=alpha.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/permissions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PermissionCreateResponsesPage = exports.Permissions = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Permissions extends resource_1.APIResource {
    /**
     * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
     *
     * This enables organization owners to share fine-tuned models with other projects
     * in their organization.
     *
     * @example
     * ```ts
     * // Automatically fetches more pages as needed.
     * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
     *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
     *   { project_ids: ['string'] },
     * )) {
     *   // ...
     * }
     * ```
     */ create(fineTunedModelCheckpoint, body, options) {
        return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, {
            body,
            method: 'post',
            ...options
        });
    }
    retrieve(fineTunedModelCheckpoint, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.retrieve(fineTunedModelCheckpoint, {}, query);
        }
        return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
            query,
            ...options
        });
    }
    /**
     * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
     *
     * Organization owners can use this endpoint to delete a permission for a
     * fine-tuned model checkpoint.
     *
     * @example
     * ```ts
     * const permission =
     *   await client.fineTuning.checkpoints.permissions.del(
     *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
     *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
     *   );
     * ```
     */ del(fineTunedModelCheckpoint, permissionId, options) {
        return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);
    }
}
exports.Permissions = Permissions;
/**
 * Note: no pagination actually occurs yet, this is for forwards-compatibility.
 */ class PermissionCreateResponsesPage extends pagination_1.Page {
}
exports.PermissionCreateResponsesPage = PermissionCreateResponsesPage;
Permissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage; //# sourceMappingURL=permissions.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Checkpoints = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const PermissionsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/permissions.js [app-route] (ecmascript)"));
const permissions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/permissions.js [app-route] (ecmascript)");
class Checkpoints extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.permissions = new PermissionsAPI.Permissions(this._client);
    }
}
exports.Checkpoints = Checkpoints;
Checkpoints.Permissions = permissions_1.Permissions;
Checkpoints.PermissionCreateResponsesPage = permissions_1.PermissionCreateResponsesPage; //# sourceMappingURL=checkpoints.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/checkpoints.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineTuningJobCheckpointsPage = exports.Checkpoints = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Checkpoints extends resource_1.APIResource {
    list(fineTuningJobId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(fineTuningJobId, {}, query);
        }
        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, {
            query,
            ...options
        });
    }
}
exports.Checkpoints = Checkpoints;
class FineTuningJobCheckpointsPage extends pagination_1.CursorPage {
}
exports.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
Checkpoints.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage; //# sourceMappingURL=checkpoints.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/jobs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineTuningJobEventsPage = exports.FineTuningJobsPage = exports.Jobs = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const CheckpointsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/checkpoints.js [app-route] (ecmascript)"));
const checkpoints_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/checkpoints.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Jobs extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);
    }
    /**
     * Creates a fine-tuning job which begins the process of creating a new model from
     * a given dataset.
     *
     * Response includes details of the enqueued job including job status and the name
     * of the fine-tuned models once complete.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     *
     * @example
     * ```ts
     * const fineTuningJob = await client.fineTuning.jobs.create({
     *   model: 'gpt-4o-mini',
     *   training_file: 'file-abc123',
     * });
     * ```
     */ create(body, options) {
        return this._client.post('/fine_tuning/jobs', {
            body,
            ...options
        });
    }
    /**
     * Get info about a fine-tuning job.
     *
     * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
     *
     * @example
     * ```ts
     * const fineTuningJob = await client.fineTuning.jobs.retrieve(
     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
     * );
     * ```
     */ retrieve(fineTuningJobId, options) {
        return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/fine_tuning/jobs', FineTuningJobsPage, {
            query,
            ...options
        });
    }
    /**
     * Immediately cancel a fine-tune job.
     *
     * @example
     * ```ts
     * const fineTuningJob = await client.fineTuning.jobs.cancel(
     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
     * );
     * ```
     */ cancel(fineTuningJobId, options) {
        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
    }
    listEvents(fineTuningJobId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.listEvents(fineTuningJobId, {}, query);
        }
        return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
            query,
            ...options
        });
    }
    /**
     * Pause a fine-tune job.
     *
     * @example
     * ```ts
     * const fineTuningJob = await client.fineTuning.jobs.pause(
     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
     * );
     * ```
     */ pause(fineTuningJobId, options) {
        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);
    }
    /**
     * Resume a fine-tune job.
     *
     * @example
     * ```ts
     * const fineTuningJob = await client.fineTuning.jobs.resume(
     *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
     * );
     * ```
     */ resume(fineTuningJobId, options) {
        return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);
    }
}
exports.Jobs = Jobs;
class FineTuningJobsPage extends pagination_1.CursorPage {
}
exports.FineTuningJobsPage = FineTuningJobsPage;
class FineTuningJobEventsPage extends pagination_1.CursorPage {
}
exports.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = checkpoints_1.Checkpoints;
Jobs.FineTuningJobCheckpointsPage = checkpoints_1.FineTuningJobCheckpointsPage; //# sourceMappingURL=jobs.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/fine-tuning.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FineTuning = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const MethodsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/methods.js [app-route] (ecmascript)"));
const methods_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/methods.js [app-route] (ecmascript)");
const AlphaAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/alpha.js [app-route] (ecmascript)"));
const alpha_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/alpha/alpha.js [app-route] (ecmascript)");
const CheckpointsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.js [app-route] (ecmascript)"));
const checkpoints_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.js [app-route] (ecmascript)");
const JobsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/jobs.js [app-route] (ecmascript)"));
const jobs_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/jobs/jobs.js [app-route] (ecmascript)");
class FineTuning extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.methods = new MethodsAPI.Methods(this._client);
        this.jobs = new JobsAPI.Jobs(this._client);
        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);
        this.alpha = new AlphaAPI.Alpha(this._client);
    }
}
exports.FineTuning = FineTuning;
FineTuning.Methods = methods_1.Methods;
FineTuning.Jobs = jobs_1.Jobs;
FineTuning.FineTuningJobsPage = jobs_1.FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = jobs_1.FineTuningJobEventsPage;
FineTuning.Checkpoints = checkpoints_1.Checkpoints;
FineTuning.Alpha = alpha_1.Alpha; //# sourceMappingURL=fine-tuning.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/grader-models.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GraderModels = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class GraderModels extends resource_1.APIResource {
}
exports.GraderModels = GraderModels; //# sourceMappingURL=grader-models.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/graders.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Graders = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const GraderModelsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/grader-models.js [app-route] (ecmascript)"));
const grader_models_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/grader-models.js [app-route] (ecmascript)");
class Graders extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.graderModels = new GraderModelsAPI.GraderModels(this._client);
    }
}
exports.Graders = Graders;
Graders.GraderModels = grader_models_1.GraderModels; //# sourceMappingURL=graders.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/images.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Images = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
class Images extends resource_1.APIResource {
    /**
     * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
     *
     * @example
     * ```ts
     * const imagesResponse = await client.images.createVariation({
     *   image: fs.createReadStream('otter.png'),
     * });
     * ```
     */ createVariation(body, options) {
        return this._client.post('/images/variations', Core.multipartFormRequestOptions({
            body,
            ...options
        }));
    }
    /**
     * Creates an edited or extended image given one or more source images and a
     * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.
     *
     * @example
     * ```ts
     * const imagesResponse = await client.images.edit({
     *   image: fs.createReadStream('path/to/file'),
     *   prompt: 'A cute baby sea otter wearing a beret',
     * });
     * ```
     */ edit(body, options) {
        return this._client.post('/images/edits', Core.multipartFormRequestOptions({
            body,
            ...options
        }));
    }
    /**
     * Creates an image given a prompt.
     * [Learn more](https://platform.openai.com/docs/guides/images).
     *
     * @example
     * ```ts
     * const imagesResponse = await client.images.generate({
     *   prompt: 'A cute baby sea otter',
     * });
     * ```
     */ generate(body, options) {
        return this._client.post('/images/generations', {
            body,
            ...options
        });
    }
}
exports.Images = Images; //# sourceMappingURL=images.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/models.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelsPage = exports.Models = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Models extends resource_1.APIResource {
    /**
     * Retrieves a model instance, providing basic information about the model such as
     * the owner and permissioning.
     */ retrieve(model, options) {
        return this._client.get(`/models/${model}`, options);
    }
    /**
     * Lists the currently available models, and provides basic information about each
     * one such as the owner and availability.
     */ list(options) {
        return this._client.getAPIList('/models', ModelsPage, options);
    }
    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization to
     * delete a model.
     */ del(model, options) {
        return this._client.delete(`/models/${model}`, options);
    }
}
exports.Models = Models;
/**
 * Note: no pagination actually occurs yet, this is for forwards-compatibility.
 */ class ModelsPage extends pagination_1.Page {
}
exports.ModelsPage = ModelsPage;
Models.ModelsPage = ModelsPage; //# sourceMappingURL=models.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/moderations.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Moderations = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
class Moderations extends resource_1.APIResource {
    /**
     * Classifies if text and/or image inputs are potentially harmful. Learn more in
     * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
     */ create(body, options) {
        return this._client.post('/moderations', {
            body,
            ...options
        });
    }
}
exports.Moderations = Moderations; //# sourceMappingURL=moderations.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ResponsesParser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addOutputText = exports.validateInputTools = exports.shouldParseToolCall = exports.isAutoParsableTool = exports.makeParseableResponseTool = exports.hasAutoParseableInput = exports.parseResponse = exports.maybeParseResponse = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const parser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/parser.js [app-route] (ecmascript)");
function maybeParseResponse(response, params) {
    if (!params || !hasAutoParseableInput(params)) {
        return {
            ...response,
            output_parsed: null,
            output: response.output.map((item)=>{
                if (item.type === 'function_call') {
                    return {
                        ...item,
                        parsed_arguments: null
                    };
                }
                if (item.type === 'message') {
                    return {
                        ...item,
                        content: item.content.map((content)=>({
                                ...content,
                                parsed: null
                            }))
                    };
                } else {
                    return item;
                }
            })
        };
    }
    return parseResponse(response, params);
}
exports.maybeParseResponse = maybeParseResponse;
function parseResponse(response, params) {
    const output = response.output.map((item)=>{
        if (item.type === 'function_call') {
            return {
                ...item,
                parsed_arguments: parseToolCall(params, item)
            };
        }
        if (item.type === 'message') {
            const content = item.content.map((content)=>{
                if (content.type === 'output_text') {
                    return {
                        ...content,
                        parsed: parseTextFormat(params, content.text)
                    };
                }
                return content;
            });
            return {
                ...item,
                content
            };
        }
        return item;
    });
    const parsed = Object.assign({}, response, {
        output
    });
    if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {
        addOutputText(parsed);
    }
    Object.defineProperty(parsed, 'output_parsed', {
        enumerable: true,
        get () {
            for (const output of parsed.output){
                if (output.type !== 'message') {
                    continue;
                }
                for (const content of output.content){
                    if (content.type === 'output_text' && content.parsed !== null) {
                        return content.parsed;
                    }
                }
            }
            return null;
        }
    });
    return parsed;
}
exports.parseResponse = parseResponse;
function parseTextFormat(params, content) {
    if (params.text?.format?.type !== 'json_schema') {
        return null;
    }
    if ('$parseRaw' in params.text?.format) {
        const text_format = params.text?.format;
        return text_format.$parseRaw(content);
    }
    return JSON.parse(content);
}
function hasAutoParseableInput(params) {
    if ((0, parser_1.isAutoParsableResponseFormat)(params.text?.format)) {
        return true;
    }
    return false;
}
exports.hasAutoParseableInput = hasAutoParseableInput;
function makeParseableResponseTool(tool, { parser, callback }) {
    const obj = {
        ...tool
    };
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-tool',
            enumerable: false
        },
        $parseRaw: {
            value: parser,
            enumerable: false
        },
        $callback: {
            value: callback,
            enumerable: false
        }
    });
    return obj;
}
exports.makeParseableResponseTool = makeParseableResponseTool;
function isAutoParsableTool(tool) {
    return tool?.['$brand'] === 'auto-parseable-tool';
}
exports.isAutoParsableTool = isAutoParsableTool;
function getInputToolByName(input_tools, name) {
    return input_tools.find((tool)=>tool.type === 'function' && tool.name === name);
}
function parseToolCall(params, toolCall) {
    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
    return {
        ...toolCall,
        ...toolCall,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
    };
}
function shouldParseToolCall(params, toolCall) {
    if (!params) {
        return false;
    }
    const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
    return isAutoParsableTool(inputTool) || inputTool?.strict || false;
}
exports.shouldParseToolCall = shouldParseToolCall;
function validateInputTools(tools) {
    for (const tool of tools ?? []){
        if (tool.type !== 'function') {
            throw new error_1.OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
        }
        if (tool.function.strict !== true) {
            throw new error_1.OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
        }
    }
}
exports.validateInputTools = validateInputTools;
function addOutputText(rsp) {
    const texts = [];
    for (const output of rsp.output){
        if (output.type !== 'message') {
            continue;
        }
        for (const content of output.content){
            if (content.type === 'output_text') {
                texts.push(content.text);
            }
        }
    }
    rsp.output_text = texts.join('');
}
exports.addOutputText = addOutputText; //# sourceMappingURL=ResponsesParser.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/input-items.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResponseItemsPage = exports.InputItems = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const responses_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/responses.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ResponseItemsPage", {
    enumerable: true,
    get: function() {
        return responses_1.ResponseItemsPage;
    }
});
class InputItems extends resource_1.APIResource {
    list(responseId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(responseId, {}, query);
        }
        return this._client.getAPIList(`/responses/${responseId}/input_items`, responses_1.ResponseItemsPage, {
            query,
            ...options
        });
    }
}
exports.InputItems = InputItems; //# sourceMappingURL=input-items.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/responses/ResponseStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __classPrivateFieldSet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResponseStream = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
const EventStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/EventStream.js [app-route] (ecmascript)");
const ResponsesParser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ResponsesParser.js [app-route] (ecmascript)");
class ResponseStream extends EventStream_1.EventStream {
    constructor(params){
        super();
        _ResponseStream_instances.add(this);
        _ResponseStream_params.set(this, void 0);
        _ResponseStream_currentResponseSnapshot.set(this, void 0);
        _ResponseStream_finalResponse.set(this, void 0);
        __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
    }
    static createResponse(client, params, options) {
        const runner = new ResponseStream(params);
        runner._run(()=>runner._createOrRetrieveResponse(client, params, {
                ...options,
                headers: {
                    ...options?.headers,
                    'X-Stainless-Helper-Method': 'stream'
                }
            }));
        return runner;
    }
    async _createOrRetrieveResponse(client, params, options) {
        const signal = options?.signal;
        if (signal) {
            if (signal.aborted) this.controller.abort();
            signal.addEventListener('abort', ()=>this.controller.abort());
        }
        __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
        let stream;
        let starting_after = null;
        if ('response_id' in params) {
            stream = await client.responses.retrieve(params.response_id, {
                stream: true
            }, {
                ...options,
                signal: this.controller.signal,
                stream: true
            });
            starting_after = params.starting_after ?? null;
        } else {
            stream = await client.responses.create({
                ...params,
                stream: true
            }, {
                ...options,
                signal: this.controller.signal
            });
        }
        this._connected();
        for await (const event of stream){
            __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
        }
        if (stream.controller.signal?.aborted) {
            throw new error_1.APIUserAbortError();
        }
        return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
    }
    [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {
        if (this.ended) return;
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
    }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {
        if (this.ended) return;
        const maybeEmit = (name, event)=>{
            if (starting_after == null || event.sequence_number > starting_after) {
                this._emit(name, event);
            }
        };
        const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
        maybeEmit('event', event);
        switch(event.type){
            case 'response.output_text.delta':
                {
                    const output = response.output[event.output_index];
                    if (!output) {
                        throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
                    }
                    if (output.type === 'message') {
                        const content = output.content[event.content_index];
                        if (!content) {
                            throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);
                        }
                        if (content.type !== 'output_text') {
                            throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);
                        }
                        maybeEmit('response.output_text.delta', {
                            ...event,
                            snapshot: content.text
                        });
                    }
                    break;
                }
            case 'response.function_call_arguments.delta':
                {
                    const output = response.output[event.output_index];
                    if (!output) {
                        throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
                    }
                    if (output.type === 'function_call') {
                        maybeEmit('response.function_call_arguments.delta', {
                            ...event,
                            snapshot: output.arguments
                        });
                    }
                    break;
                }
            default:
                maybeEmit(event.type, event);
                break;
        }
    }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {
        if (this.ended) {
            throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
            throw new error_1.OpenAIError(`request ended without sending any events`);
        }
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
        const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
        __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
        return parsedResponse;
    }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {
        let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
            if (event.type !== 'response.created') {
                throw new error_1.OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
            }
            snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
            return snapshot;
        }
        switch(event.type){
            case 'response.output_item.added':
                {
                    snapshot.output.push(event.item);
                    break;
                }
            case 'response.content_part.added':
                {
                    const output = snapshot.output[event.output_index];
                    if (!output) {
                        throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
                    }
                    if (output.type === 'message') {
                        output.content.push(event.part);
                    }
                    break;
                }
            case 'response.output_text.delta':
                {
                    const output = snapshot.output[event.output_index];
                    if (!output) {
                        throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
                    }
                    if (output.type === 'message') {
                        const content = output.content[event.content_index];
                        if (!content) {
                            throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);
                        }
                        if (content.type !== 'output_text') {
                            throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);
                        }
                        content.text += event.delta;
                    }
                    break;
                }
            case 'response.function_call_arguments.delta':
                {
                    const output = snapshot.output[event.output_index];
                    if (!output) {
                        throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
                    }
                    if (output.type === 'function_call') {
                        output.arguments += event.delta;
                    }
                    break;
                }
            case 'response.completed':
                {
                    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
                    break;
                }
        }
        return snapshot;
    }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on('event', (event)=>{
            const reader = readQueue.shift();
            if (reader) {
                reader.resolve(event);
            } else {
                pushQueue.push(event);
            }
        });
        this.on('end', ()=>{
            done = true;
            for (const reader of readQueue){
                reader.resolve(undefined);
            }
            readQueue.length = 0;
        });
        this.on('abort', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        this.on('error', (err)=>{
            done = true;
            for (const reader of readQueue){
                reader.reject(err);
            }
            readQueue.length = 0;
        });
        return {
            next: async ()=>{
                if (!pushQueue.length) {
                    if (done) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    return new Promise((resolve, reject)=>readQueue.push({
                            resolve,
                            reject
                        })).then((event)=>event ? {
                            value: event,
                            done: false
                        } : {
                            value: undefined,
                            done: true
                        });
                }
                const event = pushQueue.shift();
                return {
                    value: event,
                    done: false
                };
            },
            return: async ()=>{
                this.abort();
                return {
                    value: undefined,
                    done: true
                };
            }
        };
    }
    /**
     * @returns a promise that resolves with the final Response, or rejects
     * if an error occurred or the stream ended prematurely without producing a REsponse.
     */ async finalResponse() {
        await this.done();
        const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
        if (!response) throw new error_1.OpenAIError('stream ended without producing a ChatCompletion');
        return response;
    }
}
exports.ResponseStream = ResponseStream;
function finalizeResponse(snapshot, params) {
    return (0, ResponsesParser_1.maybeParseResponse)(snapshot, params);
} //# sourceMappingURL=ResponseStream.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/responses.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResponseItemsPage = exports.Responses = void 0;
const ResponsesParser_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/ResponsesParser.js [app-route] (ecmascript)");
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const InputItemsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/input-items.js [app-route] (ecmascript)"));
const input_items_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/input-items.js [app-route] (ecmascript)");
const ResponseStream_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/responses/ResponseStream.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Responses extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.inputItems = new InputItemsAPI.InputItems(this._client);
    }
    create(body, options) {
        return this._client.post('/responses', {
            body,
            ...options,
            stream: body.stream ?? false
        })._thenUnwrap((rsp)=>{
            if ('object' in rsp && rsp.object === 'response') {
                (0, ResponsesParser_1.addOutputText)(rsp);
            }
            return rsp;
        });
    }
    retrieve(responseId, query = {}, options) {
        return this._client.get(`/responses/${responseId}`, {
            query,
            ...options,
            stream: query?.stream ?? false
        });
    }
    /**
     * Deletes a model response with the given ID.
     *
     * @example
     * ```ts
     * await client.responses.del(
     *   'resp_677efb5139a88190b512bc3fef8e535d',
     * );
     * ```
     */ del(responseId, options) {
        return this._client.delete(`/responses/${responseId}`, {
            ...options,
            headers: {
                Accept: '*/*',
                ...options?.headers
            }
        });
    }
    parse(body, options) {
        return this._client.responses.create(body, options)._thenUnwrap((response)=>(0, ResponsesParser_1.parseResponse)(response, body));
    }
    /**
     * Creates a model response stream
     */ stream(body, options) {
        return ResponseStream_1.ResponseStream.createResponse(this._client, body, options);
    }
    /**
     * Cancels a model response with the given ID. Only responses created with the
     * `background` parameter set to `true` can be cancelled.
     * [Learn more](https://platform.openai.com/docs/guides/background).
     *
     * @example
     * ```ts
     * await client.responses.cancel(
     *   'resp_677efb5139a88190b512bc3fef8e535d',
     * );
     * ```
     */ cancel(responseId, options) {
        return this._client.post(`/responses/${responseId}/cancel`, {
            ...options,
            headers: {
                Accept: '*/*',
                ...options?.headers
            }
        });
    }
}
exports.Responses = Responses;
class ResponseItemsPage extends pagination_1.CursorPage {
}
exports.ResponseItemsPage = ResponseItemsPage;
Responses.InputItems = input_items_1.InputItems; //# sourceMappingURL=responses.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/parts.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parts = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
class Parts extends resource_1.APIResource {
    /**
     * Adds a
     * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
     * A Part represents a chunk of bytes from the file you are trying to upload.
     *
     * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
     * maximum of 8 GB.
     *
     * It is possible to add multiple Parts in parallel. You can decide the intended
     * order of the Parts when you
     * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
     */ create(uploadId, body, options) {
        return this._client.post(`/uploads/${uploadId}/parts`, Core.multipartFormRequestOptions({
            body,
            ...options
        }));
    }
}
exports.Parts = Parts; //# sourceMappingURL=parts.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/uploads.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Uploads = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const PartsAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/parts.js [app-route] (ecmascript)"));
const parts_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/parts.js [app-route] (ecmascript)");
class Uploads extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.parts = new PartsAPI.Parts(this._client);
    }
    /**
     * Creates an intermediate
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
     * that you can add
     * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
     * Currently, an Upload can accept at most 8 GB in total and expires after an hour
     * after you create it.
     *
     * Once you complete the Upload, we will create a
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * contains all the parts you uploaded. This File is usable in the rest of our
     * platform as a regular File object.
     *
     * For certain `purpose` values, the correct `mime_type` must be specified. Please
     * refer to documentation for the
     * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
     *
     * For guidance on the proper filename extensions for each purpose, please follow
     * the documentation on
     * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
     */ create(body, options) {
        return this._client.post('/uploads', {
            body,
            ...options
        });
    }
    /**
     * Cancels the Upload. No Parts may be added after an Upload is cancelled.
     */ cancel(uploadId, options) {
        return this._client.post(`/uploads/${uploadId}/cancel`, options);
    }
    /**
     * Completes the
     * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
     *
     * Within the returned Upload object, there is a nested
     * [File](https://platform.openai.com/docs/api-reference/files/object) object that
     * is ready to use in the rest of the platform.
     *
     * You can specify the order of the Parts by passing in an ordered list of the Part
     * IDs.
     *
     * The number of bytes uploaded upon completion must match the number of bytes
     * initially specified when creating the Upload object. No Parts may be added after
     * an Upload is completed.
     */ complete(uploadId, body, options) {
        return this._client.post(`/uploads/${uploadId}/complete`, {
            body,
            ...options
        });
    }
}
exports.Uploads = Uploads;
Uploads.Parts = parts_1.Parts; //# sourceMappingURL=uploads.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/Util.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.allSettledWithThrow = void 0;
/**
 * Like `Promise.allSettled()` but throws an error if any promises are rejected.
 */ const allSettledWithThrow = async (promises)=>{
    const results = await Promise.allSettled(promises);
    const rejected = results.filter((result)=>result.status === 'rejected');
    if (rejected.length) {
        for (const result of rejected){
            console.error(result.reason);
        }
        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
    }
    // Note: TS was complaining about using `.filter().map()` here for some reason
    const values = [];
    for (const result of results){
        if (result.status === 'fulfilled') {
            values.push(result.value);
        }
    }
    return values;
};
exports.allSettledWithThrow = allSettledWithThrow; //# sourceMappingURL=Util.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/files.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileContentResponsesPage = exports.VectorStoreFilesPage = exports.Files = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class Files extends resource_1.APIResource {
    /**
     * Create a vector store file by attaching a
     * [File](https://platform.openai.com/docs/api-reference/files) to a
     * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
     */ create(vectorStoreId, body, options) {
        return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieves a vector store file.
     */ retrieve(vectorStoreId, fileId, options) {
        return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Update attributes on a vector store file.
     */ update(vectorStoreId, fileId, body, options) {
        return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(vectorStoreId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list(vectorStoreId, {}, query);
        }
        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Delete a vector store file. This will remove the file from the vector store but
     * the file itself will not be deleted. To delete the file, use the
     * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
     * endpoint.
     */ del(vectorStoreId, fileId, options) {
        return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Attach a file to the given vector store and wait for it to be processed.
     */ async createAndPoll(vectorStoreId, body, options) {
        const file = await this.create(vectorStoreId, body, options);
        return await this.poll(vectorStoreId, file.id, options);
    }
    /**
     * Wait for the vector store file to finish processing.
     *
     * Note: this will return even if the file failed to process, you need to check
     * file.last_error and file.status to handle these cases
     */ async poll(vectorStoreId, fileId, options) {
        const headers = {
            ...options?.headers,
            'X-Stainless-Poll-Helper': 'true'
        };
        if (options?.pollIntervalMs) {
            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();
        }
        while(true){
            const fileResponse = await this.retrieve(vectorStoreId, fileId, {
                ...options,
                headers
            }).withResponse();
            const file = fileResponse.data;
            switch(file.status){
                case 'in_progress':
                    let sleepInterval = 5000;
                    if (options?.pollIntervalMs) {
                        sleepInterval = options.pollIntervalMs;
                    } else {
                        const headerInterval = fileResponse.response.headers.get('openai-poll-after-ms');
                        if (headerInterval) {
                            const headerIntervalMs = parseInt(headerInterval);
                            if (!isNaN(headerIntervalMs)) {
                                sleepInterval = headerIntervalMs;
                            }
                        }
                    }
                    await (0, core_1.sleep)(sleepInterval);
                    break;
                case 'failed':
                case 'completed':
                    return file;
            }
        }
    }
    /**
     * Upload a file to the `files` API and then attach it to the given vector store.
     *
     * Note the file will be asynchronously processed (you can use the alternative
     * polling helper method to wait for processing to complete).
     */ async upload(vectorStoreId, file, options) {
        const fileInfo = await this._client.files.create({
            file: file,
            purpose: 'assistants'
        }, options);
        return this.create(vectorStoreId, {
            file_id: fileInfo.id
        }, options);
    }
    /**
     * Add a file to a vector store and poll until processing is complete.
     */ async uploadAndPoll(vectorStoreId, file, options) {
        const fileInfo = await this.upload(vectorStoreId, file, options);
        return await this.poll(vectorStoreId, fileInfo.id, options);
    }
    /**
     * Retrieve the parsed contents of a vector store file.
     */ content(vectorStoreId, fileId, options) {
        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.Files = Files;
class VectorStoreFilesPage extends pagination_1.CursorPage {
}
exports.VectorStoreFilesPage = VectorStoreFilesPage;
/**
 * Note: no pagination actually occurs yet, this is for forwards-compatibility.
 */ class FileContentResponsesPage extends pagination_1.Page {
}
exports.FileContentResponsesPage = FileContentResponsesPage;
Files.VectorStoreFilesPage = VectorStoreFilesPage;
Files.FileContentResponsesPage = FileContentResponsesPage; //# sourceMappingURL=files.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/file-batches.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorStoreFilesPage = exports.FileBatches = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const core_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const Util_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/lib/Util.js [app-route] (ecmascript)");
const files_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/files.js [app-route] (ecmascript)");
Object.defineProperty(exports, "VectorStoreFilesPage", {
    enumerable: true,
    get: function() {
        return files_1.VectorStoreFilesPage;
    }
});
class FileBatches extends resource_1.APIResource {
    /**
     * Create a vector store file batch.
     */ create(vectorStoreId, body, options) {
        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieves a vector store file batch.
     */ retrieve(vectorStoreId, batchId, options) {
        return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of
     * files in this batch as soon as possible.
     */ cancel(vectorStoreId, batchId, options) {
        return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Create a vector store batch and poll until all files have been processed.
     */ async createAndPoll(vectorStoreId, body, options) {
        const batch = await this.create(vectorStoreId, body);
        return await this.poll(vectorStoreId, batch.id, options);
    }
    listFiles(vectorStoreId, batchId, query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.listFiles(vectorStoreId, batchId, {}, query);
        }
        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, files_1.VectorStoreFilesPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Wait for the given file batch to be processed.
     *
     * Note: this will return even if one of the files failed to process, you need to
     * check batch.file_counts.failed_count to handle this case.
     */ async poll(vectorStoreId, batchId, options) {
        const headers = {
            ...options?.headers,
            'X-Stainless-Poll-Helper': 'true'
        };
        if (options?.pollIntervalMs) {
            headers['X-Stainless-Custom-Poll-Interval'] = options.pollIntervalMs.toString();
        }
        while(true){
            const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
                ...options,
                headers
            }).withResponse();
            switch(batch.status){
                case 'in_progress':
                    let sleepInterval = 5000;
                    if (options?.pollIntervalMs) {
                        sleepInterval = options.pollIntervalMs;
                    } else {
                        const headerInterval = response.headers.get('openai-poll-after-ms');
                        if (headerInterval) {
                            const headerIntervalMs = parseInt(headerInterval);
                            if (!isNaN(headerIntervalMs)) {
                                sleepInterval = headerIntervalMs;
                            }
                        }
                    }
                    await (0, core_2.sleep)(sleepInterval);
                    break;
                case 'failed':
                case 'cancelled':
                case 'completed':
                    return batch;
            }
        }
    }
    /**
     * Uploads the given files concurrently and then creates a vector store file batch.
     *
     * The concurrency limit is configurable using the `maxConcurrency` parameter.
     */ async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
        if (files == null || files.length == 0) {
            throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
        }
        const configuredConcurrency = options?.maxConcurrency ?? 5;
        // We cap the number of workers at the number of files (so we don't start any unnecessary workers)
        const concurrencyLimit = Math.min(configuredConcurrency, files.length);
        const client = this._client;
        const fileIterator = files.values();
        const allFileIds = [
            ...fileIds
        ];
        // This code is based on this design. The libraries don't accommodate our environment limits.
        // https://stackoverflow.com/questions/40639432/what-is-the-best-way-to-limit-concurrency-when-using-es6s-promise-all
        async function processFiles(iterator) {
            for (let item of iterator){
                const fileObj = await client.files.create({
                    file: item,
                    purpose: 'assistants'
                }, options);
                allFileIds.push(fileObj.id);
            }
        }
        // Start workers to process results
        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
        // Wait for all processing to complete.
        await (0, Util_1.allSettledWithThrow)(workers);
        return await this.createAndPoll(vectorStoreId, {
            file_ids: allFileIds
        });
    }
}
exports.FileBatches = FileBatches; //# sourceMappingURL=file-batches.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/vector-stores.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorStoreSearchResponsesPage = exports.VectorStoresPage = exports.VectorStores = void 0;
const resource_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resource.js [app-route] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)");
const FileBatchesAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/file-batches.js [app-route] (ecmascript)"));
const file_batches_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/file-batches.js [app-route] (ecmascript)");
const FilesAPI = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/files.js [app-route] (ecmascript)"));
const files_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/files.js [app-route] (ecmascript)");
const pagination_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)");
class VectorStores extends resource_1.APIResource {
    constructor(){
        super(...arguments);
        this.files = new FilesAPI.Files(this._client);
        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);
    }
    /**
     * Create a vector store.
     */ create(body, options) {
        return this._client.post('/vector_stores', {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Retrieves a vector store.
     */ retrieve(vectorStoreId, options) {
        return this._client.get(`/vector_stores/${vectorStoreId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Modifies a vector store.
     */ update(vectorStoreId, body, options) {
        return this._client.post(`/vector_stores/${vectorStoreId}`, {
            body,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    list(query = {}, options) {
        if ((0, core_1.isRequestOptions)(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/vector_stores', VectorStoresPage, {
            query,
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Delete a vector store.
     */ del(vectorStoreId, options) {
        return this._client.delete(`/vector_stores/${vectorStoreId}`, {
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
    /**
     * Search a vector store for relevant chunks based on a query and file attributes
     * filter.
     */ search(vectorStoreId, body, options) {
        return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {
            body,
            method: 'post',
            ...options,
            headers: {
                'OpenAI-Beta': 'assistants=v2',
                ...options?.headers
            }
        });
    }
}
exports.VectorStores = VectorStores;
class VectorStoresPage extends pagination_1.CursorPage {
}
exports.VectorStoresPage = VectorStoresPage;
/**
 * Note: no pagination actually occurs yet, this is for forwards-compatibility.
 */ class VectorStoreSearchResponsesPage extends pagination_1.Page {
}
exports.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.Files = files_1.Files;
VectorStores.VectorStoreFilesPage = files_1.VectorStoreFilesPage;
VectorStores.FileContentResponsesPage = files_1.FileContentResponsesPage;
VectorStores.FileBatches = file_batches_1.FileBatches; //# sourceMappingURL=vector-stores.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorStores = exports.VectorStoreSearchResponsesPage = exports.VectorStoresPage = exports.Uploads = exports.Responses = exports.Moderations = exports.Models = exports.ModelsPage = exports.Images = exports.Graders = exports.FineTuning = exports.Files = exports.FileObjectsPage = exports.Evals = exports.EvalListResponsesPage = exports.Embeddings = exports.Containers = exports.ContainerListResponsesPage = exports.Completions = exports.Beta = exports.Batches = exports.BatchesPage = exports.Audio = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/shared.js [app-route] (ecmascript)"), exports);
var audio_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/audio.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Audio", {
    enumerable: true,
    get: function() {
        return audio_1.Audio;
    }
});
var batches_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/batches.js [app-route] (ecmascript)");
Object.defineProperty(exports, "BatchesPage", {
    enumerable: true,
    get: function() {
        return batches_1.BatchesPage;
    }
});
Object.defineProperty(exports, "Batches", {
    enumerable: true,
    get: function() {
        return batches_1.Batches;
    }
});
var beta_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/beta.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Beta", {
    enumerable: true,
    get: function() {
        return beta_1.Beta;
    }
});
var completions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/completions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Completions", {
    enumerable: true,
    get: function() {
        return completions_1.Completions;
    }
});
var containers_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/containers.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ContainerListResponsesPage", {
    enumerable: true,
    get: function() {
        return containers_1.ContainerListResponsesPage;
    }
});
Object.defineProperty(exports, "Containers", {
    enumerable: true,
    get: function() {
        return containers_1.Containers;
    }
});
var embeddings_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/embeddings.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Embeddings", {
    enumerable: true,
    get: function() {
        return embeddings_1.Embeddings;
    }
});
var evals_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/evals.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EvalListResponsesPage", {
    enumerable: true,
    get: function() {
        return evals_1.EvalListResponsesPage;
    }
});
Object.defineProperty(exports, "Evals", {
    enumerable: true,
    get: function() {
        return evals_1.Evals;
    }
});
var files_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/files.js [app-route] (ecmascript)");
Object.defineProperty(exports, "FileObjectsPage", {
    enumerable: true,
    get: function() {
        return files_1.FileObjectsPage;
    }
});
Object.defineProperty(exports, "Files", {
    enumerable: true,
    get: function() {
        return files_1.Files;
    }
});
var fine_tuning_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/fine-tuning.js [app-route] (ecmascript)");
Object.defineProperty(exports, "FineTuning", {
    enumerable: true,
    get: function() {
        return fine_tuning_1.FineTuning;
    }
});
var graders_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/graders.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Graders", {
    enumerable: true,
    get: function() {
        return graders_1.Graders;
    }
});
var images_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/images.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Images", {
    enumerable: true,
    get: function() {
        return images_1.Images;
    }
});
var models_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/models.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ModelsPage", {
    enumerable: true,
    get: function() {
        return models_1.ModelsPage;
    }
});
Object.defineProperty(exports, "Models", {
    enumerable: true,
    get: function() {
        return models_1.Models;
    }
});
var moderations_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/moderations.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Moderations", {
    enumerable: true,
    get: function() {
        return moderations_1.Moderations;
    }
});
var responses_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/responses.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Responses", {
    enumerable: true,
    get: function() {
        return responses_1.Responses;
    }
});
var uploads_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/uploads.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Uploads", {
    enumerable: true,
    get: function() {
        return uploads_1.Uploads;
    }
});
var vector_stores_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/vector-stores.js [app-route] (ecmascript)");
Object.defineProperty(exports, "VectorStoresPage", {
    enumerable: true,
    get: function() {
        return vector_stores_1.VectorStoresPage;
    }
});
Object.defineProperty(exports, "VectorStoreSearchResponsesPage", {
    enumerable: true,
    get: function() {
        return vector_stores_1.VectorStoreSearchResponsesPage;
    }
});
Object.defineProperty(exports, "VectorStores", {
    enumerable: true,
    get: function() {
        return vector_stores_1.VectorStores;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/openai/node_modules/openai/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnprocessableEntityError = exports.PermissionDeniedError = exports.InternalServerError = exports.AuthenticationError = exports.BadRequestError = exports.RateLimitError = exports.ConflictError = exports.NotFoundError = exports.APIUserAbortError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIError = exports.OpenAIError = exports.fileFromPath = exports.toFile = exports.AzureOpenAI = exports.OpenAI = void 0;
const qs = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/internal/qs/index.js [app-route] (ecmascript)"));
const Core = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/core.js [app-route] (ecmascript)"));
const Errors = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)"));
const Pagination = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/pagination.js [app-route] (ecmascript)"));
const Uploads = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/uploads.js [app-route] (ecmascript)"));
const API = __importStar(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/index.js [app-route] (ecmascript)"));
const batches_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/batches.js [app-route] (ecmascript)");
const completions_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/completions.js [app-route] (ecmascript)");
const embeddings_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/embeddings.js [app-route] (ecmascript)");
const files_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/files.js [app-route] (ecmascript)");
const images_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/images.js [app-route] (ecmascript)");
const models_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/models.js [app-route] (ecmascript)");
const moderations_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/moderations.js [app-route] (ecmascript)");
const audio_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/audio/audio.js [app-route] (ecmascript)");
const beta_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/beta/beta.js [app-route] (ecmascript)");
const chat_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/chat.js [app-route] (ecmascript)");
const containers_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/containers/containers.js [app-route] (ecmascript)");
const evals_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/evals/evals.js [app-route] (ecmascript)");
const fine_tuning_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/fine-tuning/fine-tuning.js [app-route] (ecmascript)");
const graders_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/graders/graders.js [app-route] (ecmascript)");
const responses_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/responses/responses.js [app-route] (ecmascript)");
const uploads_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/uploads/uploads.js [app-route] (ecmascript)");
const vector_stores_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/vector-stores/vector-stores.js [app-route] (ecmascript)");
const completions_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/resources/chat/completions/completions.js [app-route] (ecmascript)");
/**
 * API Client for interfacing with the OpenAI API.
 */ class OpenAI extends Core.APIClient {
    /**
     * API Client for interfacing with the OpenAI API.
     *
     * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */ constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('OPENAI_API_KEY'), organization = Core.readEnv('OPENAI_ORG_ID') ?? null, project = Core.readEnv('OPENAI_PROJECT_ID') ?? null, ...opts } = {}){
        if (apiKey === undefined) {
            throw new Errors.OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
        }
        const options = {
            apiKey,
            organization,
            project,
            ...opts,
            baseURL: baseURL || `https://api.openai.com/v1`
        };
        if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {
            throw new Errors.OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
        }
        super({
            baseURL: options.baseURL,
            timeout: options.timeout ?? 600000 /* 10 minutes */ ,
            httpAgent: options.httpAgent,
            maxRetries: options.maxRetries,
            fetch: options.fetch
        });
        this.completions = new API.Completions(this);
        this.chat = new API.Chat(this);
        this.embeddings = new API.Embeddings(this);
        this.files = new API.Files(this);
        this.images = new API.Images(this);
        this.audio = new API.Audio(this);
        this.moderations = new API.Moderations(this);
        this.models = new API.Models(this);
        this.fineTuning = new API.FineTuning(this);
        this.graders = new API.Graders(this);
        this.vectorStores = new API.VectorStores(this);
        this.beta = new API.Beta(this);
        this.batches = new API.Batches(this);
        this.uploads = new API.Uploads(this);
        this.responses = new API.Responses(this);
        this.evals = new API.Evals(this);
        this.containers = new API.Containers(this);
        this._options = options;
        this.apiKey = apiKey;
        this.organization = organization;
        this.project = project;
    }
    defaultQuery() {
        return this._options.defaultQuery;
    }
    defaultHeaders(opts) {
        return {
            ...super.defaultHeaders(opts),
            'OpenAI-Organization': this.organization,
            'OpenAI-Project': this.project,
            ...this._options.defaultHeaders
        };
    }
    authHeaders(opts) {
        return {
            Authorization: `Bearer ${this.apiKey}`
        };
    }
    stringifyQuery(query) {
        return qs.stringify(query, {
            arrayFormat: 'brackets'
        });
    }
}
exports.OpenAI = OpenAI;
_a = OpenAI;
OpenAI.OpenAI = _a;
OpenAI.DEFAULT_TIMEOUT = 600000; // 10 minutes
OpenAI.OpenAIError = Errors.OpenAIError;
OpenAI.APIError = Errors.APIError;
OpenAI.APIConnectionError = Errors.APIConnectionError;
OpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;
OpenAI.APIUserAbortError = Errors.APIUserAbortError;
OpenAI.NotFoundError = Errors.NotFoundError;
OpenAI.ConflictError = Errors.ConflictError;
OpenAI.RateLimitError = Errors.RateLimitError;
OpenAI.BadRequestError = Errors.BadRequestError;
OpenAI.AuthenticationError = Errors.AuthenticationError;
OpenAI.InternalServerError = Errors.InternalServerError;
OpenAI.PermissionDeniedError = Errors.PermissionDeniedError;
OpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;
OpenAI.toFile = Uploads.toFile;
OpenAI.fileFromPath = Uploads.fileFromPath;
OpenAI.Completions = completions_1.Completions;
OpenAI.Chat = chat_1.Chat;
OpenAI.ChatCompletionsPage = completions_2.ChatCompletionsPage;
OpenAI.Embeddings = embeddings_1.Embeddings;
OpenAI.Files = files_1.Files;
OpenAI.FileObjectsPage = files_1.FileObjectsPage;
OpenAI.Images = images_1.Images;
OpenAI.Audio = audio_1.Audio;
OpenAI.Moderations = moderations_1.Moderations;
OpenAI.Models = models_1.Models;
OpenAI.ModelsPage = models_1.ModelsPage;
OpenAI.FineTuning = fine_tuning_1.FineTuning;
OpenAI.Graders = graders_1.Graders;
OpenAI.VectorStores = vector_stores_1.VectorStores;
OpenAI.VectorStoresPage = vector_stores_1.VectorStoresPage;
OpenAI.VectorStoreSearchResponsesPage = vector_stores_1.VectorStoreSearchResponsesPage;
OpenAI.Beta = beta_1.Beta;
OpenAI.Batches = batches_1.Batches;
OpenAI.BatchesPage = batches_1.BatchesPage;
OpenAI.Uploads = uploads_1.Uploads;
OpenAI.Responses = responses_1.Responses;
OpenAI.Evals = evals_1.Evals;
OpenAI.EvalListResponsesPage = evals_1.EvalListResponsesPage;
OpenAI.Containers = containers_1.Containers;
OpenAI.ContainerListResponsesPage = containers_1.ContainerListResponsesPage;
/** API Client for interfacing with the Azure OpenAI API. */ class AzureOpenAI extends OpenAI {
    /**
     * API Client for interfacing with the Azure OpenAI API.
     *
     * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]
     * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`
     * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]
     * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.
     * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
     * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.
     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
     * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
     */ constructor({ baseURL = Core.readEnv('OPENAI_BASE_URL'), apiKey = Core.readEnv('AZURE_OPENAI_API_KEY'), apiVersion = Core.readEnv('OPENAI_API_VERSION'), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}){
        if (!apiVersion) {
            throw new Errors.OpenAIError("The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).");
        }
        if (typeof azureADTokenProvider === 'function') {
            dangerouslyAllowBrowser = true;
        }
        if (!azureADTokenProvider && !apiKey) {
            throw new Errors.OpenAIError('Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.');
        }
        if (azureADTokenProvider && apiKey) {
            throw new Errors.OpenAIError('The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.');
        }
        // define a sentinel value to avoid any typing issues
        apiKey ?? (apiKey = API_KEY_SENTINEL);
        opts.defaultQuery = {
            ...opts.defaultQuery,
            'api-version': apiVersion
        };
        if (!baseURL) {
            if (!endpoint) {
                endpoint = process.env['AZURE_OPENAI_ENDPOINT'];
            }
            if (!endpoint) {
                throw new Errors.OpenAIError('Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable');
            }
            baseURL = `${endpoint}/openai`;
        } else {
            if (endpoint) {
                throw new Errors.OpenAIError('baseURL and endpoint are mutually exclusive');
            }
        }
        super({
            apiKey,
            baseURL,
            ...opts,
            ...dangerouslyAllowBrowser !== undefined ? {
                dangerouslyAllowBrowser
            } : {}
        });
        this.apiVersion = '';
        this._azureADTokenProvider = azureADTokenProvider;
        this.apiVersion = apiVersion;
        this.deploymentName = deployment;
    }
    buildRequest(options, props = {}) {
        if (_deployments_endpoints.has(options.path) && options.method === 'post' && options.body !== undefined) {
            if (!Core.isObj(options.body)) {
                throw new Error('Expected request body to be an object');
            }
            const model = this.deploymentName || options.body['model'] || options.__metadata?.['model'];
            if (model !== undefined && !this.baseURL.includes('/deployments')) {
                options.path = `/deployments/${model}${options.path}`;
            }
        }
        return super.buildRequest(options, props);
    }
    async _getAzureADToken() {
        if (typeof this._azureADTokenProvider === 'function') {
            const token = await this._azureADTokenProvider();
            if (!token || typeof token !== 'string') {
                throw new Errors.OpenAIError(`Expected 'azureADTokenProvider' argument to return a string but it returned ${token}`);
            }
            return token;
        }
        return undefined;
    }
    authHeaders(opts) {
        return {};
    }
    async prepareOptions(opts) {
        /**
         * The user should provide a bearer token provider if they want
         * to use Azure AD authentication. The user shouldn't set the
         * Authorization header manually because the header is overwritten
         * with the Azure AD token if a bearer token provider is provided.
         */ if (opts.headers?.['api-key']) {
            return super.prepareOptions(opts);
        }
        const token = await this._getAzureADToken();
        opts.headers ?? (opts.headers = {});
        if (token) {
            opts.headers['Authorization'] = `Bearer ${token}`;
        } else if (this.apiKey !== API_KEY_SENTINEL) {
            opts.headers['api-key'] = this.apiKey;
        } else {
            throw new Errors.OpenAIError('Unable to handle auth');
        }
        return super.prepareOptions(opts);
    }
}
exports.AzureOpenAI = AzureOpenAI;
const _deployments_endpoints = new Set([
    '/completions',
    '/chat/completions',
    '/embeddings',
    '/audio/transcriptions',
    '/audio/translations',
    '/audio/speech',
    '/images/generations',
    '/images/edits'
]);
const API_KEY_SENTINEL = '<Missing Key>';
// ---------------------- End Azure ----------------------
var uploads_2 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/uploads.js [app-route] (ecmascript)");
Object.defineProperty(exports, "toFile", {
    enumerable: true,
    get: function() {
        return uploads_2.toFile;
    }
});
Object.defineProperty(exports, "fileFromPath", {
    enumerable: true,
    get: function() {
        return uploads_2.fileFromPath;
    }
});
var error_1 = __turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/error.js [app-route] (ecmascript)");
Object.defineProperty(exports, "OpenAIError", {
    enumerable: true,
    get: function() {
        return error_1.OpenAIError;
    }
});
Object.defineProperty(exports, "APIError", {
    enumerable: true,
    get: function() {
        return error_1.APIError;
    }
});
Object.defineProperty(exports, "APIConnectionError", {
    enumerable: true,
    get: function() {
        return error_1.APIConnectionError;
    }
});
Object.defineProperty(exports, "APIConnectionTimeoutError", {
    enumerable: true,
    get: function() {
        return error_1.APIConnectionTimeoutError;
    }
});
Object.defineProperty(exports, "APIUserAbortError", {
    enumerable: true,
    get: function() {
        return error_1.APIUserAbortError;
    }
});
Object.defineProperty(exports, "NotFoundError", {
    enumerable: true,
    get: function() {
        return error_1.NotFoundError;
    }
});
Object.defineProperty(exports, "ConflictError", {
    enumerable: true,
    get: function() {
        return error_1.ConflictError;
    }
});
Object.defineProperty(exports, "RateLimitError", {
    enumerable: true,
    get: function() {
        return error_1.RateLimitError;
    }
});
Object.defineProperty(exports, "BadRequestError", {
    enumerable: true,
    get: function() {
        return error_1.BadRequestError;
    }
});
Object.defineProperty(exports, "AuthenticationError", {
    enumerable: true,
    get: function() {
        return error_1.AuthenticationError;
    }
});
Object.defineProperty(exports, "InternalServerError", {
    enumerable: true,
    get: function() {
        return error_1.InternalServerError;
    }
});
Object.defineProperty(exports, "PermissionDeniedError", {
    enumerable: true,
    get: function() {
        return error_1.PermissionDeniedError;
    }
});
Object.defineProperty(exports, "UnprocessableEntityError", {
    enumerable: true,
    get: function() {
        return error_1.UnprocessableEntityError;
    }
});
exports = module.exports = OpenAI;
module.exports.AzureOpenAI = AzureOpenAI;
exports.default = OpenAI; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    getAvailableSchemas: ()=>getAvailableSchemas,
    getSchemaInfo: ()=>getSchemaInfo,
    getSchemaVersion: ()=>getSchemaVersion,
    isBrowser: ()=>isBrowser,
    loadSchema: ()=>loadSchema,
    snakeCase: ()=>snakeCase,
    validateConfigSchema: ()=>validateConfigSchema
});
module.exports = __toCommonJS(index_exports);
// ../../../../../schemas/embedding_functions/amazon_bedrock.json
var amazon_bedrock_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Amazon Bedrock Embedding Function Schema",
    description: "Schema for the Amazon Bedrock embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        session_args: {
            type: "object",
            description: "The arguments to pass to the boto3 session"
        },
        model_name: {
            type: "string",
            description: "The name of the model to use for embeddings"
        },
        kwargs: {
            type: "object",
            description: "Additional arguments to pass to the Amazon Bedrock client"
        }
    },
    required: [
        "session_args",
        "model_name",
        "kwargs"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/base_schema.json
var base_schema_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Embedding Function Base Schema",
    description: "Base schema for all embedding functions in Chroma",
    type: "object",
    properties: {
        version: {
            type: "string",
            description: "Schema version for the embedding function"
        },
        name: {
            type: "string",
            description: "Name of the embedding function"
        },
        config: {
            type: "object",
            description: "Configuration parameters for the embedding function"
        }
    },
    required: [
        "version",
        "name",
        "config"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/chroma_langchain.json
var chroma_langchain_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Langchain Embedding Function Schema",
    description: "Schema for the langchain embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        embedding_function: {
            type: "string",
            description: "Parameter embedding_function for the langchain embedding function"
        }
    },
    required: [
        "embedding_function"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/cohere.json
var cohere_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Cohere Embedding Function Schema",
    description: "Schema for the Cohere embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Cohere API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/default.json
var default_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Default Embedding Function Schema",
    description: "Schema for the default embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {},
    required: [],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/google_generative_ai.json
var google_generative_ai_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Google Generative AI Embedding Function Schema",
    description: "Schema for the Google Generative AI embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        task_type: {
            type: "string",
            description: "The task type for the embeddings (e.g., RETRIEVAL_DOCUMENT)"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Google Generative AI API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name",
        "task_type"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/google_palm.json
var google_palm_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Google PaLM Embedding Function Schema",
    description: "Schema for the Google PaLM embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Google PaLM API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/google_vertex.json
var google_vertex_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Google Vertex Embedding Function Schema",
    description: "Schema for the Google Vertex embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        project_id: {
            type: "string",
            description: "The Google Cloud project ID"
        },
        region: {
            type: "string",
            description: "The Google Cloud region"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Google Vertex API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name",
        "project_id",
        "region"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/huggingface.json
var huggingface_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "HuggingFace Embedding Function Schema",
    description: "Schema for the HuggingFace embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the HuggingFace API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/huggingface_server.json
var huggingface_server_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "HuggingFace Embedding Server Schema",
    description: "Schema for the HuggingFace embedding server configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        url: {
            type: "string",
            description: "The URL of the HuggingFace Embedding Server"
        },
        api_key_env_var: {
            type: "string",
            description: "The environment variable name that contains your API key for the HuggingFace API"
        }
    },
    required: [
        "url"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/instructor.json
var instructor_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Instructor Embedding Function Schema",
    description: "Schema for the instructor embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Parameter model_name for the instructor embedding function"
        },
        device: {
            type: "string",
            description: "Parameter device for the instructor embedding function"
        },
        instruction: {
            type: "string",
            description: "Parameter instruction for the instructor embedding function"
        }
    },
    required: [
        "model_name",
        "device"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/jina.json
var jina_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Jina Embedding Function Schema",
    description: "Schema for the jina embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Parameter model_name for the jina embedding function"
        },
        api_key_env_var: {
            type: "string",
            description: "Parameter api_key_env_var for the jina embedding function"
        },
        task: {
            type: "string",
            description: "Parameter task for the jina embedding function"
        },
        late_chunking: {
            type: "boolean",
            description: "Parameter late_chunking for the jina embedding function"
        },
        truncate: {
            type: "boolean",
            description: "Parameter truncate for the jina embedding function"
        },
        dimensions: {
            type: "integer",
            description: "Parameter dimensions for the jina embedding function"
        },
        embedding_type: {
            type: "string",
            description: "Parameter embedding_type for the jina embedding function"
        },
        normalized: {
            type: "boolean",
            description: "Parameter normalized for the jina embedding function"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/ollama.json
var ollama_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Ollama Embedding Function Schema",
    description: "Schema for the Ollama embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        url: {
            type: "string",
            description: "The URL of the Ollama server"
        },
        model_name: {
            type: "string",
            description: "The name of the model to use for embeddings"
        },
        timeout: {
            type: "integer",
            description: "Timeout in seconds for the API request"
        }
    },
    required: [
        "url",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/onnx_mini_lm_l6_v2.json
var onnx_mini_lm_l6_v2_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Onnx_mini_lm_l6_v2 Embedding Function Schema",
    description: "Schema for the onnx_mini_lm_l6_v2 embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        preferred_providers: {
            type: "array",
            items: {
                type: "string"
            },
            description: "Parameter preferred_providers for the onnx_mini_lm_l6_v2 embedding function"
        }
    },
    required: [],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/open_clip.json
var open_clip_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Open_clip Embedding Function Schema",
    description: "Schema for the open_clip embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Parameter model_name for the open_clip embedding function"
        },
        checkpoint: {
            type: "string",
            description: "Parameter checkpoint for the open_clip embedding function"
        },
        device: {
            type: "string",
            description: "Parameter device for the open_clip embedding function"
        }
    },
    required: [
        "model_name",
        "checkpoint",
        "device"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/openai.json
var openai_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "OpenAI Embedding Function Schema",
    description: "Schema for the OpenAI embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        organization_id: {
            type: [
                "string",
                "null"
            ],
            description: "The OpenAI organization ID if applicable"
        },
        api_base: {
            type: [
                "string",
                "null"
            ],
            description: "The base path for the API"
        },
        api_type: {
            type: [
                "string",
                "null"
            ],
            description: "The type of the API deployment"
        },
        api_version: {
            type: [
                "string",
                "null"
            ],
            description: "The api version for the API"
        },
        deployment_id: {
            type: [
                "string",
                "null"
            ],
            description: "Deployment ID for Azure OpenAI"
        },
        default_headers: {
            type: [
                "object",
                "null"
            ],
            description: "A mapping of default headers to be sent with each API request"
        },
        dimensions: {
            type: [
                "integer",
                "null"
            ],
            description: "The number of dimensions for the embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the OpenAI API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/roboflow.json
var roboflow_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Roboflow Embedding Function Schema",
    description: "Schema for the roboflow embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        api_url: {
            type: "string",
            description: "Parameter api_url for the roboflow embedding function"
        },
        api_key_env_var: {
            type: "string",
            description: "Parameter api_key_env_var for the roboflow embedding function"
        }
    },
    required: [
        "api_key_env_var",
        "api_url"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/sentence_transformer.json
var sentence_transformer_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "SentenceTransformer Embedding Function Schema",
    description: "Schema for the SentenceTransformer embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Identifier of the SentenceTransformer model"
        },
        device: {
            type: "string",
            description: "Device used for computation"
        },
        normalize_embeddings: {
            type: "boolean",
            description: "Whether to normalize returned vectors"
        },
        kwargs: {
            type: "object",
            description: "Additional arguments to pass to the SentenceTransformer model",
            additionalProperties: {
                type: [
                    "string",
                    "integer",
                    "number",
                    "boolean",
                    "array",
                    "object"
                ]
            }
        }
    },
    required: [
        "model_name",
        "device",
        "normalize_embeddings"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/text2vec.json
var text2vec_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Text2vec Embedding Function Schema",
    description: "Schema for the text2vec embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Parameter model_name for the text2vec embedding function"
        }
    },
    required: [
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/transformers.json
var transformers_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Transformers Embedding Function Schema",
    description: "Schema for the Transformers embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model: {
            type: "string",
            description: "Identifier of the SentenceTransformer model"
        },
        revision: {
            type: "string",
            description: "Specific model version to use (can be a branch, tag name, or commit id)"
        },
        quantized: {
            type: "boolean",
            description: "Whether to load the 8-bit quantized version of the model"
        }
    },
    required: [
        "model",
        "revision",
        "quantized"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/voyageai.json
var voyageai_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Voyageai Embedding Function Schema",
    description: "Schema for the voyageai embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "Parameter model_name for the voyageai embedding function"
        },
        api_key_env_var: {
            type: "string",
            description: "Parameter api_key_env_var for the voyageai embedding function"
        },
        input_type: {
            type: "string",
            description: "Parameter input_type for the voyageai embedding function"
        },
        truncation: {
            type: "boolean",
            description: "Parameter truncation for the voyageai embedding function"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/cloudflare_workers_ai.json
var cloudflare_workers_ai_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Cloudflare Workers AI Embedding Function Schema",
    description: "Schema for the Cloudflare Workers AI embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        account_id: {
            type: "string",
            description: "The account ID for the Cloudflare Workers AI API"
        },
        api_key_env_var: {
            type: "string",
            description: "The environment variable name that contains your API key for the Cloudflare Workers AI API"
        },
        gateway_id: {
            type: "string",
            description: "The ID of the Cloudflare AI Gateway to use for a more customized solution"
        }
    },
    required: [
        "api_key_env_var",
        "model_name",
        "account_id"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/together_ai.json
var together_ai_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Together AI Embedding Function Schema",
    description: "Schema for the Together AI embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for text embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "The environment variable name that contains your API key for the Together AI API"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/mistral.json
var mistral_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Mistral Embedding Function Schema",
    description: "Schema for the Mistral embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model: {
            type: "string",
            description: "Parameter model for the Mistral embedding function"
        },
        api_key_env_var: {
            type: "string",
            description: "Parameter api_key_env_var for the Mistral embedding function"
        }
    },
    required: [
        "api_key_env_var",
        "model"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/morph.json
var morph_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Morph Embedding Function Schema",
    description: "Schema for the Morph embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model_name: {
            type: "string",
            description: "The name of the model to use for embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Morph API"
        },
        api_base: {
            type: [
                "string",
                "null"
            ],
            description: "The base URL for the Morph API"
        },
        encoding_format: {
            type: [
                "string",
                "null"
            ],
            description: "The format for embeddings (float or base64)"
        }
    },
    required: [
        "api_key_env_var",
        "model_name"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/chroma-cloud-qwen.json
var chroma_cloud_qwen_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Chroma Cloud Qwen Embedding Function Schema",
    description: "Schema for the Chroma Cloud Qwen embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model: {
            type: "string",
            enum: [
                "Qwen/Qwen3-Embedding-0.6B"
            ],
            description: "The specific Qwen model to use for embeddings"
        },
        task: {
            type: "string",
            enum: [
                "nl_to_code"
            ],
            description: "The task for which embeddings are being generated"
        },
        instructions: {
            type: "object",
            description: "A mapping of tasks to instructions for targets (documents/queries)",
            properties: {
                nl_to_code: {
                    type: "object",
                    properties: {
                        documents: {
                            type: "string",
                            description: "Instructions for embedding documents"
                        },
                        query: {
                            type: "string",
                            description: "Instructions for embedding queries"
                        }
                    },
                    required: [
                        "documents",
                        "query"
                    ],
                    additionalProperties: false
                }
            },
            required: [
                "nl_to_code"
            ],
            additionalProperties: false
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Chroma Embedding API",
            default: "CHROMA_API_KEY"
        }
    },
    required: [
        "model",
        "task"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/chroma-cloud-splade.json
var chroma_cloud_splade_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Chroma Cloud Splade Embedding Function Schema",
    description: "Schema for the Chroma Cloud Splade sparse embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        model: {
            type: "string",
            enum: [
                "prithivida/Splade_PP_en_v1"
            ],
            description: "The specific Splade model to use for sparse embeddings"
        },
        api_key_env_var: {
            type: "string",
            description: "Environment variable name that contains your API key for the Chroma Embedding API",
            default: "CHROMA_API_KEY"
        }
    },
    required: [
        "api_key_env_var",
        "model"
    ],
    additionalProperties: false
};
// ../../../../../schemas/embedding_functions/chroma_bm25.json
var chroma_bm25_default = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: "Chroma BM25 Embedding Function Schema",
    description: "Schema for the Chroma BM25 sparse embedding function configuration",
    version: "1.0.0",
    type: "object",
    properties: {
        k: {
            type: "number",
            description: "BM25 saturation parameter controlling term frequency scaling"
        },
        b: {
            type: "number",
            description: "BM25 length normalization parameter"
        },
        avg_doc_length: {
            type: "number",
            description: "Average document length in tokens used for normalization"
        },
        token_max_length: {
            type: "number",
            description: "Maximum token length allowed before filtering"
        },
        stopwords: {
            type: "array",
            description: "Optional custom stopword list (in lowercase) to override the defaults",
            items: {
                type: "string"
            }
        }
    },
    additionalProperties: false
};
// src/schema-utils.ts
var import_ajv = __toESM(__turbopack_context__.r("[project]/node_modules/@chroma-core/ai-embeddings-common/node_modules/ajv/dist/ajv.js [app-route] (ecmascript)"));
var ajv = new import_ajv.default({
    strict: false,
    // Allow unknown keywords
    allErrors: true
});
var schemaMap = {
    "amazon-bedrock": amazon_bedrock_default,
    "base-schema": base_schema_default,
    "chroma-langchain": chroma_langchain_default,
    cohere: cohere_default,
    default: default_default,
    "google-generative-ai": google_generative_ai_default,
    "google-palm": google_palm_default,
    "google-vertex": google_vertex_default,
    huggingface: huggingface_default,
    "huggingface-server": huggingface_server_default,
    instructor: instructor_default,
    jina: jina_default,
    ollama: ollama_default,
    "onnx-mini-lm-l6-v2": onnx_mini_lm_l6_v2_default,
    "open-clip": open_clip_default,
    openai: openai_default,
    roboflow: roboflow_default,
    "sentence-transformer": sentence_transformer_default,
    text2vec: text2vec_default,
    transformers: transformers_default,
    voyageai: voyageai_default,
    "cloudflare-worker-ai": cloudflare_workers_ai_default,
    "together-ai": together_ai_default,
    mistral: mistral_default,
    morph: morph_default,
    "chroma-cloud-qwen": chroma_cloud_qwen_default,
    "chroma-cloud-splade": chroma_cloud_splade_default,
    chroma_bm25: chroma_bm25_default
};
function loadSchema(schemaName) {
    if (!schemaMap[schemaName]) {
        throw new Error(`Schema '${schemaName}' not found`);
    }
    return schemaMap[schemaName];
}
function validateConfigSchema(config, schemaName) {
    const schema = loadSchema(schemaName);
    const validate = ajv.compile(schema);
    const valid = validate(config);
    if (!valid) {
        const errors = validate.errors || [];
        const errorPaths = errors.map((e)=>`${e.instancePath || "/"}: ${e.message}`).join(", ");
        throw new Error(`Config validation failed for schema '${schemaName}': ${errorPaths}`);
    }
}
function getSchemaVersion(schemaName) {
    const schema = loadSchema(schemaName);
    return schema.version || "1.0.0";
}
function getAvailableSchemas() {
    return Object.keys(schemaMap).filter((name)=>name !== "base_schema");
}
function getSchemaInfo() {
    const schemaInfo = {};
    for (const schemaName of getAvailableSchemas()){
        try {
            const schema = schemaMap[schemaName];
            schemaInfo[schemaName] = {
                version: schema.version || "1.0.0",
                title: schema.title || "",
                description: schema.description || ""
            };
        } catch (error) {
            console.error(`Failed to load schema '${schemaName}':`, error);
        }
    }
    return schemaInfo;
}
// src/index.ts
var camelToSnake = (str)=>{
    return str.replace(/([A-Z])/g, "_$1").toLowerCase();
};
var snakeCase = (input)=>{
    if (Array.isArray(input)) {
        return input.map(snakeCase);
    }
    if (input !== null && typeof input === "object") {
        return Object.fromEntries(Object.entries(input).map(([key, value])=>[
                camelToSnake(key),
                snakeCase(value)
            ]));
    }
    return input;
};
var isBrowser = ()=>{
    return ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof window.document !== "undefined";
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getAvailableSchemas,
    getSchemaInfo,
    getSchemaVersion,
    isBrowser,
    loadSchema,
    snakeCase,
    validateConfigSchema
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@chroma-core/openai/dist/cjs/openai.cjs [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var src_exports = {};
__export(src_exports, {
    OpenAIEmbeddingFunction: ()=>OpenAIEmbeddingFunction
});
module.exports = __toCommonJS(src_exports);
var import_chromadb = __turbopack_context__.r("[project]/node_modules/chromadb/dist/cjs/chromadb.cjs [app-route] (ecmascript)");
var import_openai = __toESM(__turbopack_context__.r("[project]/node_modules/@chroma-core/openai/node_modules/openai/index.js [app-route] (ecmascript)"), 1);
var import_ai_embeddings_common = __turbopack_context__.r("[project]/node_modules/@chroma-core/ai-embeddings-common/dist/index.js [app-route] (ecmascript)");
var NAME = "openai";
var OpenAIEmbeddingFunction = class _OpenAIEmbeddingFunction {
    constructor(args){
        this.name = NAME;
        const { apiKeyEnvVar = "OPENAI_API_KEY", modelName, dimensions, organizationId } = args;
        const apiKey = args.apiKey || process.env[apiKeyEnvVar];
        if (!apiKey) {
            throw new Error(`OpenAI API key is required. Please provide it in the constructor or set the environment variable ${apiKeyEnvVar}.`);
        }
        this.modelName = modelName;
        this.organizationId = organizationId;
        this.apiKeyEnvVar = apiKeyEnvVar;
        this.dimensions = dimensions;
        this.client = new import_openai.default({
            apiKey,
            organization: this.organizationId
        });
    }
    async generate(texts) {
        const response = await this.client.embeddings.create({
            input: texts,
            model: this.modelName,
            dimensions: this.dimensions
        });
        return response.data.map((e)=>e.embedding);
    }
    defaultSpace() {
        return "cosine";
    }
    supportedSpaces() {
        return [
            "cosine",
            "l2",
            "ip"
        ];
    }
    static buildFromConfig(config) {
        return new _OpenAIEmbeddingFunction({
            apiKeyEnvVar: config.api_key_env_var,
            modelName: config.model_name,
            organizationId: config.organization_id,
            dimensions: config.dimensions
        });
    }
    getConfig() {
        return {
            api_key_env_var: this.apiKeyEnvVar,
            model_name: this.modelName,
            organization_id: this.organizationId,
            dimensions: this.dimensions
        };
    }
    validateConfigUpdate(newConfig) {
        if (this.getConfig().model_name !== newConfig.model_name) {
            throw new import_chromadb.ChromaValueError("Model name cannot be updated");
        }
    }
    static validateConfig(config) {
        (0, import_ai_embeddings_common.validateConfigSchema)(config, NAME);
    }
};
(0, import_chromadb.registerEmbeddingFunction)(NAME, OpenAIEmbeddingFunction);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    OpenAIEmbeddingFunction
}); //# sourceMappingURL=openai.cjs.map
}),
];

//# sourceMappingURL=node_modules_0a764e50._.js.map
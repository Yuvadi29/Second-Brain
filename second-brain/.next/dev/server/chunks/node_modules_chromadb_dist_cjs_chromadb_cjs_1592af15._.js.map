{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/index.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/deno.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/types.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/.pnpm/%40hey-api%2Bclient-fetch%400.10.0_%40hey-api%2Bopenapi-ts%400.67.3_typescript%405.8.3_/node_modules/%40hey-api/client-core/src/auth.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/.pnpm/%40hey-api%2Bclient-fetch%400.10.0_%40hey-api%2Bopenapi-ts%400.67.3_typescript%405.8.3_/node_modules/%40hey-api/client-core/src/bodySerializer.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/.pnpm/%40hey-api%2Bclient-fetch%400.10.0_%40hey-api%2Bopenapi-ts%400.67.3_typescript%405.8.3_/node_modules/%40hey-api/client-core/src/pathSerializer.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/.pnpm/%40hey-api%2Bclient-fetch%400.10.0_%40hey-api%2Bopenapi-ts%400.67.3_typescript%405.8.3_/node_modules/%40hey-api/client-fetch/src/utils.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/.pnpm/%40hey-api%2Bclient-fetch%400.10.0_%40hey-api%2Bopenapi-ts%400.67.3_typescript%405.8.3_/node_modules/%40hey-api/client-fetch/src/client.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/api/client.gen.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/api/sdk.gen.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/errors.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/utils.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/embedding-function.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/collection-configuration.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/common.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/where.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/key.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/limit.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/select.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/rank.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/search.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/execution/expression/searchResult.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/schema.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/collection.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/next.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/chroma-fetch.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/admin-client.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/chroma-client.ts","file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/node_modules/chromadb/src/cloud-client.ts"],"sourcesContent":["/**\n * @fileoverview ChromaDB JavaScript client library entry point.\n * Provides access to all public APIs for interacting with ChromaDB.\n */\n\n// Apply Deno compatibility patch\nimport \"./deno\";\n\nexport { Collection } from \"./collection\";\nexport { withChroma } from \"./next\";\nexport * from \"./types\";\nexport * from \"./admin-client\";\nexport * from \"./chroma-client\";\nexport * from \"./embedding-function\";\nexport * from \"./cloud-client\";\nexport * from \"./errors\";\nexport * from \"./collection-configuration\";\nexport * from \"./execution\";\nexport * from \"./schema\";\n","// Deno compatibility patch for @hey-api/client-fetch\n// This must be imported before any @hey-api/client-fetch code\n\nif (typeof (globalThis as any).Deno !== \"undefined\") {\n  // Store the original Request constructor\n  const OriginalRequest = globalThis.Request;\n\n  // Create a patched Request constructor that strips Deno-incompatible properties\n  const PatchedRequest = function (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ) {\n    if (init && typeof init === \"object\") {\n      const cleanInit = { ...init };\n      if (\"client\" in cleanInit) {\n        delete (cleanInit as any).client;\n      }\n      return new OriginalRequest(input, cleanInit);\n    }\n    return new OriginalRequest(input, init);\n  } as any;\n\n  // Copy over static properties and prototype\n  Object.setPrototypeOf(PatchedRequest, OriginalRequest);\n  Object.defineProperty(PatchedRequest, \"prototype\", {\n    value: OriginalRequest.prototype,\n    writable: false,\n  });\n\n  // Replace the global Request constructor\n  globalThis.Request = PatchedRequest;\n}\n","import { GetUserIdentityResponse, Include, SparseVector } from \"./api\";\n\n/**\n * User identity information including tenant and database access.\n */\nexport type UserIdentity = GetUserIdentityResponse;\n\n/**\n * Re-export SparseVector type for external use\n */\nexport type { SparseVector };\n\n/**\n * Metadata that can be associated with a collection.\n * Values must be boolean, number, or string types.\n */\nexport type CollectionMetadata = Record<\n  string,\n  boolean | number | string | SparseVector | null\n>;\n\n/**\n * Metadata that can be associated with individual records.\n * Values must be boolean, number, or string types.\n */\nexport type Metadata = Record<\n  string,\n  boolean | number | string | SparseVector | null\n>;\n\n/**\n * Base interface for record sets containing optional fields.\n */\nexport interface BaseRecordSet {\n  /** Array of embedding vectors */\n  embeddings?: number[][];\n  /** Array of metadata objects */\n  metadatas?: Metadata[];\n  /** Array of document text content */\n  documents?: string[];\n  /** Array of URIs/URLs */\n  uris?: string[];\n}\n\nexport const baseRecordSetFields = [\n  \"ids\",\n  \"embeddings\",\n  \"metadatas\",\n  \"documents\",\n  \"uris\",\n];\n\n/**\n * Complete record set with required IDs for operations like add/update.\n */\nexport interface RecordSet extends BaseRecordSet {\n  /** Array of unique record identifiers */\n  ids: string[];\n}\n\nexport interface PreparedRecordSet extends Omit<RecordSet, \"embeddings\"> {\n  embeddings?: number[][] | string[];\n}\n\nexport interface PreparedInsertRecordSet extends PreparedRecordSet {\n  embeddings: number[][] | string[];\n}\n\nexport const recordSetFields = [...baseRecordSetFields, \"ids\"];\n\n/**\n * Record set for query operations with required embeddings.\n */\nexport interface QueryRecordSet extends BaseRecordSet {\n  /** Optional array of record IDs to filter by */\n  ids?: string[];\n  /** Array of query embedding vectors (required for queries) */\n  embeddings: number[][];\n}\n\ntype LiteralValue = string | number | boolean;\n\ntype LogicalOperator = \"$and\" | \"$or\";\n\ntype WhereOperator = \"$gt\" | \"$gte\" | \"$lt\" | \"$lte\" | \"$ne\" | \"$eq\";\n\ntype InclusionExclusionOperator = \"$in\" | \"$nin\";\n\ntype OperatorExpression =\n  | { $gt: LiteralValue }\n  | { $gte: LiteralValue }\n  | { $lt: LiteralValue }\n  | { $lte: LiteralValue }\n  | { $ne: LiteralValue }\n  | { $eq: LiteralValue }\n  | { $and: LiteralValue }\n  | { $or: LiteralValue }\n  | { $in: LiteralValue[] }\n  | { $nin: LiteralValue[] };\n\n/**\n * Where clause for filtering records based on metadata.\n * Supports field equality, comparison operators, and logical operators.\n */\nexport type Where =\n  | { [key: string]: LiteralValue | OperatorExpression }\n  | { $and: Where[] }\n  | { $or: Where[] };\n\ntype WhereDocumentOperator =\n  | \"$contains\"\n  | \"$not_contains\"\n  | \"$matches\"\n  | \"$not_matches\"\n  | \"$regex\"\n  | \"$not_regex\"\n  | LogicalOperator;\n\n/**\n * Where clause for filtering based on document content.\n * Supports text search operators and logical combinations.\n */\nexport type WhereDocument =\n  | { $contains: string }\n  | { $not_contains: string }\n  | { $matches: string }\n  | { $not_matches: string }\n  | { $regex: string }\n  | { $not_regex: string }\n  | { $and: WhereDocument[] }\n  | { $or: WhereDocument[] };\n\n/**\n * Enum specifying which fields to include in query results.\n */\nexport enum IncludeEnum {\n  /** Include similarity distances in results */\n  distances = \"distances\",\n  /** Include document text content in results */\n  documents = \"documents\",\n  /** Include embedding vectors in results */\n  embeddings = \"embeddings\",\n  /** Include metadata objects in results */\n  metadatas = \"metadatas\",\n  /** Include URIs in results */\n  uris = \"uris\",\n}\n\n/**\n * Result class for get operations, containing retrieved records.\n * @template TMeta - The type of metadata associated with records\n */\nexport class GetResult<TMeta extends Metadata = Metadata> {\n  public readonly documents: (string | null)[];\n  public readonly embeddings: number[][];\n  public readonly ids: string[];\n  public readonly include: Include[];\n  public readonly metadatas: (TMeta | null)[];\n  public readonly uris: (string | null)[];\n\n  /**\n   * Creates a new GetResult instance.\n   * @param data - The result data containing all fields\n   */\n  constructor({\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris,\n  }: {\n    documents: (string | null)[];\n    embeddings: number[][];\n    ids: string[];\n    include: Include[];\n    metadatas: (TMeta | null)[];\n    uris: (string | null)[];\n  }) {\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n\n  /**\n   * Converts the result to a row-based format for easier iteration.\n   * @returns Object containing include fields and array of record objects\n   */\n  public rows() {\n    return this.ids.map((id, index) => {\n      return {\n        id,\n        document: this.include.includes(\"documents\")\n          ? this.documents[index]\n          : undefined,\n        embedding: this.include.includes(\"embeddings\")\n          ? this.embeddings[index]\n          : undefined,\n        metadata: this.include.includes(\"metadatas\")\n          ? this.metadatas[index]\n          : undefined,\n        uri: this.include.includes(\"uris\") ? this.uris[index] : undefined,\n      };\n    });\n  }\n}\n\n/**\n * Interface for query results in row format.\n * @template TMeta - The type of metadata associated with records\n */\nexport interface QueryRowResult<TMeta extends Metadata = Metadata> {\n  /** Similarity distance to the query (if included) */\n  distance?: number | null;\n  /** Document text content (if included) */\n  document?: string | null;\n  /** Embedding vector (if included) */\n  embedding?: number[] | null;\n  /** Unique record identifier */\n  id: string;\n  /** Record metadata (if included) */\n  metadata?: TMeta | null;\n  /** Record URI (if included) */\n  uri?: string | null;\n}\n\n/**\n * Result class for query operations, containing search results.\n * @template TMeta - The type of metadata associated with records\n */\nexport class QueryResult<TMeta extends Metadata = Metadata> {\n  public readonly distances: (number | null)[][];\n  public readonly documents: (string | null)[][];\n  public readonly embeddings: (number[] | null)[][];\n  public readonly ids: string[][];\n  public readonly include: Include[];\n  public readonly metadatas: (TMeta | null)[][];\n  public readonly uris: (string | null)[][];\n\n  /**\n   * Creates a new QueryResult instance.\n   * @param data - The query result data containing all fields\n   */\n  constructor({\n    distances,\n    documents,\n    embeddings,\n    ids,\n    include,\n    metadatas,\n    uris,\n  }: {\n    distances: (number | null)[][];\n    documents: (string | null)[][];\n    embeddings: (number[] | null)[][];\n    ids: string[][];\n    include: Include[];\n    metadatas: (TMeta | null)[][];\n    uris: (string | null)[][];\n  }) {\n    this.distances = distances;\n    this.documents = documents;\n    this.embeddings = embeddings;\n    this.ids = ids;\n    this.include = include;\n    this.metadatas = metadatas;\n    this.uris = uris;\n  }\n\n  /**\n   * Converts the query result to a row-based format for easier iteration.\n   * @returns Object containing include fields and structured query results\n   */\n  public rows(): QueryRowResult<TMeta>[][] {\n    const queries: {\n      distance?: number | null;\n      document?: string | null;\n      embedding?: number[] | null;\n      id: string;\n      metadata?: TMeta | null;\n      uri?: string | null;\n    }[][] = [];\n\n    for (let q = 0; q < this.ids.length; q++) {\n      const records = this.ids[q].map((id, index) => {\n        return {\n          id,\n          document: this.include.includes(\"documents\")\n            ? this.documents[q][index]\n            : undefined,\n          embedding: this.include.includes(\"embeddings\")\n            ? this.embeddings[q][index]\n            : undefined,\n          metadata: this.include.includes(\"metadatas\")\n            ? this.metadatas[q][index]\n            : undefined,\n          uri: this.include.includes(\"uris\") ? this.uris[q][index] : undefined,\n          distance: this.include.includes(\"distances\")\n            ? this.distances[q][index]\n            : undefined,\n        };\n      });\n\n      queries.push(records);\n    }\n\n    return queries;\n  }\n}\n","export type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","import type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (data: FormData, key: string, value: unknown) => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n) => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T) =>\n    JSON.stringify(body, (key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n}) => {\n  if (value instanceof Date) {\n    return `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import type {\n  QuerySerializer,\n  QuerySerializerOptions,\n} from '@hey-api/client-core';\nimport {\n  getAuthToken,\n  jsonBodySerializer,\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '@hey-api/client-core';\n\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\ninterface PathSerializer {\n  path: Record<string, unknown>;\n  url: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style: ArraySeparatorStyle = 'simple';\n\n      if (name.endsWith('*')) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n\n      if (name.startsWith('.')) {\n        name = name.substring(1);\n        style = 'label';\n      } else if (name.startsWith(';')) {\n        name = name.substring(1);\n        style = 'matrix';\n      }\n\n      const value = path[name];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        url = url.replace(\n          match,\n          serializeArrayParam({ explode, name, style, value }),\n        );\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        url = url.replace(\n          match,\n          serializeObjectParam({\n            explode,\n            name,\n            style,\n            value: value as Record<string, unknown>,\n          }),\n        );\n        continue;\n      }\n\n      if (style === 'matrix') {\n        url = url.replace(\n          match,\n          `;${serializePrimitiveParam({\n            name,\n            value: value as string,\n          })}`,\n        );\n        continue;\n      }\n\n      const replaceValue = encodeURIComponent(\n        style === 'label' ? `.${value as string}` : (value as string),\n      );\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n  allowReserved,\n  array,\n  object,\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    let search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        if (Array.isArray(value)) {\n          search = [\n            ...search,\n            serializeArrayParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'form',\n              value,\n              ...array,\n            }),\n          ];\n          continue;\n        }\n\n        if (typeof value === 'object') {\n          search = [\n            ...search,\n            serializeObjectParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'deepObject',\n              value: value as Record<string, unknown>,\n              ...object,\n            }),\n          ];\n          continue;\n        }\n\n        search = [\n          ...search,\n          serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value as string,\n          }),\n        ];\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n\n    return;\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) => {\n  const url = getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n  return url;\n};\n\nexport const getUrl = ({\n  baseUrl,\n  path,\n  query,\n  querySerializer,\n  url: _url,\n}: {\n  baseUrl?: string;\n  path?: Record<string, unknown>;\n  query?: Record<string, unknown>;\n  querySerializer: QuerySerializer;\n  url: string;\n}) => {\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\n  let url = (baseUrl ?? '') + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({ path, url });\n  }\n  let search = query ? querySerializer(query) : '';\n  if (search.startsWith('?')) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += `?${search}`;\n  }\n  return url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header || typeof header !== 'object') {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers ? header.entries() : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  _fns: Interceptor[];\n\n  constructor() {\n    this._fns = [];\n  }\n\n  clear() {\n    this._fns = [];\n  }\n\n  exists(fn: Interceptor) {\n    return this._fns.indexOf(fn) !== -1;\n  }\n\n  eject(fn: Interceptor) {\n    const index = this._fns.indexOf(fn);\n    if (index !== -1) {\n      this._fns = [...this._fns.slice(0, index), ...this._fns.slice(index + 1)];\n    }\n  }\n\n  use(fn: Interceptor) {\n    this._fns = [...this._fns, fn];\n  }\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Pick<\n    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;\n  response: Pick<\n    Interceptors<ResInterceptor<Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import type { Client, Config, RequestOptions } from './types';\nimport {\n  buildUrl,\n  createConfig,\n  createInterceptors,\n  getParseAs,\n  mergeConfigs,\n  mergeHeaders,\n  setAuthParams,\n} from './utils';\n\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\n  body?: any;\n  headers: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n  let _config = mergeConfigs(createConfig(), config);\n\n  const getConfig = (): Config => ({ ..._config });\n\n  const setConfig = (config: Config): Config => {\n    _config = mergeConfigs(_config, config);\n    return getConfig();\n  };\n\n  const interceptors = createInterceptors<\n    Request,\n    Response,\n    unknown,\n    RequestOptions\n  >();\n\n  // @ts-expect-error\n  const request: Client['request'] = async (options) => {\n    const opts = {\n      ..._config,\n      ...options,\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n      headers: mergeHeaders(_config.headers, options.headers),\n    };\n\n    if (opts.security) {\n      await setAuthParams({\n        ...opts,\n        security: opts.security,\n      });\n    }\n\n    if (opts.body && opts.bodySerializer) {\n      opts.body = opts.bodySerializer(opts.body);\n    }\n\n    // remove Content-Type header if body is empty to avoid sending invalid requests\n    if (opts.body === undefined || opts.body === '') {\n      opts.headers.delete('Content-Type');\n    }\n\n    const url = buildUrl(opts);\n    const requestInit: ReqInit = {\n      redirect: 'follow',\n      ...opts,\n    };\n\n    let request = new Request(url, requestInit);\n\n    for (const fn of interceptors.request._fns) {\n      request = await fn(request, opts);\n    }\n\n    // fetch must be assigned here, otherwise it would throw the error:\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n    const _fetch = opts.fetch!;\n    let response = await _fetch(request);\n\n    for (const fn of interceptors.response._fns) {\n      response = await fn(response, request, opts);\n    }\n\n    const result = {\n      request,\n      response,\n    };\n\n    if (response.ok) {\n      if (\n        response.status === 204 ||\n        response.headers.get('Content-Length') === '0'\n      ) {\n        return {\n          data: {},\n          ...result,\n        };\n      }\n\n      const parseAs =\n        (opts.parseAs === 'auto'\n          ? getParseAs(response.headers.get('Content-Type'))\n          : opts.parseAs) ?? 'json';\n\n      if (parseAs === 'stream') {\n        return {\n          data: response.body,\n          ...result,\n        };\n      }\n\n      let data = await response[parseAs]();\n      if (parseAs === 'json') {\n        if (opts.responseValidator) {\n          await opts.responseValidator(data);\n        }\n\n        if (opts.responseTransformer) {\n          data = await opts.responseTransformer(data);\n        }\n      }\n\n      return {\n        data,\n        ...result,\n      };\n    }\n\n    let error = await response.text();\n\n    try {\n      error = JSON.parse(error);\n    } catch {\n      // noop\n    }\n\n    let finalError = error;\n\n    for (const fn of interceptors.error._fns) {\n      finalError = (await fn(error, response, request, opts)) as string;\n    }\n\n    finalError = finalError || ({} as string);\n\n    if (opts.throwOnError) {\n      throw finalError;\n    }\n\n    return {\n      error: finalError,\n      ...result,\n    };\n  };\n\n  return {\n    buildUrl,\n    connect: (options) => request({ ...options, method: 'CONNECT' }),\n    delete: (options) => request({ ...options, method: 'DELETE' }),\n    get: (options) => request({ ...options, method: 'GET' }),\n    getConfig,\n    head: (options) => request({ ...options, method: 'HEAD' }),\n    interceptors,\n    options: (options) => request({ ...options, method: 'OPTIONS' }),\n    patch: (options) => request({ ...options, method: 'PATCH' }),\n    post: (options) => request({ ...options, method: 'POST' }),\n    put: (options) => request({ ...options, method: 'PUT' }),\n    request,\n    setConfig,\n    trace: (options) => request({ ...options, method: 'TRACE' }),\n  };\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from './types.gen';\nimport { type Config, type ClientOptions as DefaultClientOptions, createClient, createConfig } from '@hey-api/client-fetch';\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(createConfig<ClientOptions>({\n    baseUrl: 'http://localhost:8000',\n    throwOnError: true\n}));","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';\nimport type { GetUserIdentityData, GetUserIdentityResponse2, GetUserIdentityError, GetCollectionByCrnData, GetCollectionByCrnResponse, GetCollectionByCrnError, HealthcheckData, HealthcheckResponse, HealthcheckError, HeartbeatData, HeartbeatResponse2, HeartbeatError, PreFlightChecksData, PreFlightChecksResponse, PreFlightChecksError, ResetData, ResetResponse, ResetError, CreateTenantData, CreateTenantResponse2, CreateTenantError, GetTenantData, GetTenantResponse2, GetTenantError, UpdateTenantData, UpdateTenantResponse2, UpdateTenantError, ListDatabasesData, ListDatabasesResponse, ListDatabasesError, CreateDatabaseData, CreateDatabaseResponse2, CreateDatabaseError, DeleteDatabaseData, DeleteDatabaseResponse2, DeleteDatabaseError, GetDatabaseData, GetDatabaseResponse, GetDatabaseError, DetachFunctionData, DetachFunctionResponse2, DetachFunctionError, ListCollectionsData, ListCollectionsResponse, ListCollectionsError, CreateCollectionData, CreateCollectionResponse, CreateCollectionError, DeleteCollectionData, DeleteCollectionResponse, DeleteCollectionError, GetCollectionData, GetCollectionResponse, GetCollectionError, UpdateCollectionData, UpdateCollectionResponse2, UpdateCollectionError, CollectionAddData, CollectionAddResponse, CollectionCountData, CollectionCountResponse, CollectionCountError, CollectionDeleteData, CollectionDeleteResponse, CollectionDeleteError, ForkCollectionData, ForkCollectionResponse, ForkCollectionError, AttachFunctionData, AttachFunctionResponse2, AttachFunctionError, CollectionGetData, CollectionGetResponse, CollectionGetError, CollectionQueryData, CollectionQueryResponse, CollectionQueryError, CollectionSearchData, CollectionSearchResponse, CollectionSearchError, CollectionUpdateData, CollectionUpdateResponse, CollectionUpsertData, CollectionUpsertResponse, CollectionUpsertError, CountCollectionsData, CountCollectionsResponse, CountCollectionsError, VersionData, VersionResponse } from './types.gen';\nimport { client as _heyApiClient } from './client.gen';\n\nexport type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {\n    /**\n     * You can provide a client instance returned by `createClient()` instead of\n     * individual options. This might be also useful if you want to implement a\n     * custom client.\n     */\n    client?: Client;\n    /**\n     * You can pass arbitrary values through the `meta` object. This can be\n     * used to access values that aren't defined as part of the SDK function.\n     */\n    meta?: Record<string, unknown>;\n};\n\nexport class DefaultService {\n    /**\n     * Retrieves the current user's identity, tenant, and databases.\n     */\n    public static getUserIdentity<ThrowOnError extends boolean = true>(options?: Options<GetUserIdentityData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<GetUserIdentityResponse2, GetUserIdentityError, ThrowOnError>({\n            url: '/api/v2/auth/identity',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a collection by Chroma Resource Name.\n     */\n    public static getCollectionByCrn<ThrowOnError extends boolean = true>(options: Options<GetCollectionByCrnData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetCollectionByCrnResponse, GetCollectionByCrnError, ThrowOnError>({\n            url: '/api/v2/collections/{crn}',\n            ...options\n        });\n    }\n    \n    /**\n     * Health check endpoint that returns 200 if the server and executor are ready\n     */\n    public static healthcheck<ThrowOnError extends boolean = true>(options?: Options<HealthcheckData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<HealthcheckResponse, HealthcheckError, ThrowOnError>({\n            url: '/api/v2/healthcheck',\n            ...options\n        });\n    }\n    \n    /**\n     * Heartbeat endpoint that returns a nanosecond timestamp of the current time.\n     */\n    public static heartbeat<ThrowOnError extends boolean = true>(options?: Options<HeartbeatData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<HeartbeatResponse2, HeartbeatError, ThrowOnError>({\n            url: '/api/v2/heartbeat',\n            ...options\n        });\n    }\n    \n    /**\n     * Pre-flight checks endpoint reporting basic readiness info.\n     */\n    public static preFlightChecks<ThrowOnError extends boolean = true>(options?: Options<PreFlightChecksData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<PreFlightChecksResponse, PreFlightChecksError, ThrowOnError>({\n            url: '/api/v2/pre-flight-checks',\n            ...options\n        });\n    }\n    \n    /**\n     * Reset endpoint allowing authorized users to reset the database.\n     */\n    public static reset<ThrowOnError extends boolean = true>(options?: Options<ResetData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).post<ResetResponse, ResetError, ThrowOnError>({\n            url: '/api/v2/reset',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new tenant.\n     */\n    public static createTenant<ThrowOnError extends boolean = true>(options: Options<CreateTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateTenantResponse2, CreateTenantError, ThrowOnError>({\n            url: '/api/v2/tenants',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Returns an existing tenant by name.\n     */\n    public static getTenant<ThrowOnError extends boolean = true>(options: Options<GetTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetTenantResponse2, GetTenantError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant_name}',\n            ...options\n        });\n    }\n    \n    /**\n     * Updates an existing tenant by name.\n     */\n    public static updateTenant<ThrowOnError extends boolean = true>(options: Options<UpdateTenantData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).patch<UpdateTenantResponse2, UpdateTenantError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant_name}',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Lists all databases for a given tenant.\n     */\n    public static listDatabases<ThrowOnError extends boolean = true>(options: Options<ListDatabasesData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<ListDatabasesResponse, ListDatabasesError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new database for a given tenant.\n     */\n    public static createDatabase<ThrowOnError extends boolean = true>(options: Options<CreateDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateDatabaseResponse2, CreateDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Deletes a specific database.\n     */\n    public static deleteDatabase<ThrowOnError extends boolean = true>(options: Options<DeleteDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).delete<DeleteDatabaseResponse2, DeleteDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a specific database by name.\n     */\n    public static getDatabase<ThrowOnError extends boolean = true>(options: Options<GetDatabaseData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetDatabaseResponse, GetDatabaseError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}',\n            ...options\n        });\n    }\n    \n    /**\n     * Detach a function\n     */\n    public static detachFunction<ThrowOnError extends boolean = true>(options: Options<DetachFunctionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<DetachFunctionResponse2, DetachFunctionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/attached_functions/{attached_function_id}/detach',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Lists all collections in the specified database.\n     */\n    public static listCollections<ThrowOnError extends boolean = true>(options: Options<ListCollectionsData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<ListCollectionsResponse, ListCollectionsError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections',\n            ...options\n        });\n    }\n    \n    /**\n     * Creates a new collection under the specified database.\n     */\n    public static createCollection<ThrowOnError extends boolean = true>(options: Options<CreateCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CreateCollectionResponse, CreateCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Deletes a collection in a given database.\n     */\n    public static deleteCollection<ThrowOnError extends boolean = true>(options: Options<DeleteCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).delete<DeleteCollectionResponse, DeleteCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options\n        });\n    }\n    \n    /**\n     * Retrieves a collection by ID or name.\n     */\n    public static getCollection<ThrowOnError extends boolean = true>(options: Options<GetCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<GetCollectionResponse, GetCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options\n        });\n    }\n    \n    /**\n     * Updates an existing collection's name or metadata.\n     */\n    public static updateCollection<ThrowOnError extends boolean = true>(options: Options<UpdateCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).put<UpdateCollectionResponse2, UpdateCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Adds records to a collection.\n     */\n    public static collectionAdd<ThrowOnError extends boolean = true>(options: Options<CollectionAddData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionAddResponse, unknown, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves the number of records in a collection.\n     */\n    public static collectionCount<ThrowOnError extends boolean = true>(options: Options<CollectionCountData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<CollectionCountResponse, CollectionCountError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/count',\n            ...options\n        });\n    }\n    \n    /**\n     * Deletes records in a collection. Can filter by IDs or metadata.\n     */\n    public static collectionDelete<ThrowOnError extends boolean = true>(options: Options<CollectionDeleteData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionDeleteResponse, CollectionDeleteError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Forks an existing collection.\n     */\n    public static forkCollection<ThrowOnError extends boolean = true>(options: Options<ForkCollectionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<ForkCollectionResponse, ForkCollectionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/fork',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Attach a function to a collection\n     */\n    public static attachFunction<ThrowOnError extends boolean = true>(options: Options<AttachFunctionData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<AttachFunctionResponse2, AttachFunctionError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/functions/attach',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves records from a collection by ID or metadata filter.\n     */\n    public static collectionGet<ThrowOnError extends boolean = true>(options: Options<CollectionGetData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionGetResponse, CollectionGetError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search\n     */\n    public static collectionQuery<ThrowOnError extends boolean = true>(options: Options<CollectionQueryData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionQueryResponse, CollectionQueryError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Search records from a collection with hybrid criterias.\n     */\n    public static collectionSearch<ThrowOnError extends boolean = true>(options: Options<CollectionSearchData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionSearchResponse, CollectionSearchError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/search',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Updates records in a collection by ID.\n     */\n    public static collectionUpdate<ThrowOnError extends boolean = true>(options: Options<CollectionUpdateData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionUpdateResponse, unknown, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/update',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Upserts records in a collection (create if not exists, otherwise update).\n     */\n    public static collectionUpsert<ThrowOnError extends boolean = true>(options: Options<CollectionUpsertData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).post<CollectionUpsertResponse, CollectionUpsertError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/upsert',\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options?.headers\n            }\n        });\n    }\n    \n    /**\n     * Retrieves the total number of collections in a given database.\n     */\n    public static countCollections<ThrowOnError extends boolean = true>(options: Options<CountCollectionsData, ThrowOnError>) {\n        return (options.client ?? _heyApiClient).get<CountCollectionsResponse, CountCollectionsError, ThrowOnError>({\n            url: '/api/v2/tenants/{tenant}/databases/{database}/collections_count',\n            ...options\n        });\n    }\n    \n    /**\n     * Returns the version of the server.\n     */\n    public static version<ThrowOnError extends boolean = true>(options?: Options<VersionData, ThrowOnError>) {\n        return (options?.client ?? _heyApiClient).get<VersionResponse, unknown, ThrowOnError>({\n            url: '/api/v2/version',\n            ...options\n        });\n    }\n    \n}","/**\n * This is a generic Chroma error.\n */\nexport class ChromaError extends Error {\n  constructor(name: string, message: string, public readonly cause?: unknown) {\n    super(message);\n    this.name = name;\n  }\n}\n\n/**\n * Indicates that there was a problem with the connection to the Chroma server (e.g. the server is down or the client is not connected to the internet)\n */\nexport class ChromaConnectionError extends Error {\n  name = \"ChromaConnectionError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** Indicates that the server encountered an error while handling the request. */\nexport class ChromaServerError extends Error {\n  name = \"ChromaServerError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** Indicate that there was an issue with the request that the client made. */\nexport class ChromaClientError extends Error {\n  name = \"ChromaClientError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** The request lacked valid authentication. */\nexport class ChromaUnauthorizedError extends Error {\n  name = \"ChromaAuthError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\n/** The user does not have permission to access the requested resource. */\nexport class ChromaForbiddenError extends Error {\n  name = \"ChromaForbiddenError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaNotFoundError extends Error {\n  name = \"ChromaNotFoundError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaValueError extends Error {\n  name = \"ChromaValueError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class InvalidCollectionError extends Error {\n  name = \"InvalidCollectionError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class InvalidArgumentError extends Error {\n  name = \"InvalidArgumentError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaUniqueError extends Error {\n  name = \"ChromaUniqueError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaQuotaExceededError extends Error {\n  name = \"ChromaQuotaExceededError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport class ChromaRateLimitError extends Error {\n  name = \"ChromaRateLimitError\";\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n  }\n}\n\nexport function createErrorByType(type: string, message: string) {\n  switch (type) {\n    case \"InvalidCollection\":\n      return new InvalidCollectionError(message);\n    case \"InvalidArgumentError\":\n      return new InvalidArgumentError(message);\n    default:\n      return undefined;\n  }\n}\n","import { AdminClientArgs } from \"./admin-client\";\nimport { ChromaClientArgs } from \"./chroma-client\";\nimport {\n  BaseRecordSet,\n  IncludeEnum,\n  Metadata,\n  RecordSet,\n  recordSetFields,\n  Where,\n  WhereDocument,\n} from \"./types\";\nimport { Include, SparseVector } from \"./api\";\nimport { ChromaValueError } from \"./errors\";\n\n/** Default tenant name used when none is specified */\nexport const DEFAULT_TENANT = \"default_tenant\";\n/** Default database name used when none is specified */\nexport const DEFAULT_DATABASE = \"default_database\";\n\n/** Default configuration for AdminClient connections */\nexport const defaultAdminClientArgs: AdminClientArgs = {\n  host: \"localhost\",\n  port: 8000,\n  ssl: false,\n};\n\n/** Default configuration for ChromaClient connections */\nexport const defaultChromaClientArgs: ChromaClientArgs = {\n  ...defaultAdminClientArgs,\n  tenant: DEFAULT_TENANT,\n  database: DEFAULT_DATABASE,\n};\n\n/**\n * Supported HTTP methods for API requests.\n */\nexport type HttpMethod =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"HEAD\"\n  | \"CONNECT\"\n  | \"OPTIONS\"\n  | \"PATCH\"\n  | \"TRACE\"\n  | undefined;\n\n/**\n * Normalizes HTTP method strings to standard uppercase format.\n * @param method - HTTP method string to normalize\n * @returns Normalized HttpMethod or undefined if invalid\n */\nexport const normalizeMethod = (method?: string): HttpMethod => {\n  if (method) {\n    switch (method.toUpperCase()) {\n      case \"GET\":\n        return \"GET\";\n      case \"POST\":\n        return \"POST\";\n      case \"PUT\":\n        return \"PUT\";\n      case \"DELETE\":\n        return \"DELETE\";\n      case \"HEAD\":\n        return \"HEAD\";\n      case \"CONNECT\":\n        return \"CONNECT\";\n      case \"OPTIONS\":\n        return \"OPTIONS\";\n      case \"PATCH\":\n        return \"PATCH\";\n      case \"TRACE\":\n        return \"TRACE\";\n      default:\n        return undefined;\n    }\n  }\n  return undefined;\n};\n\n/**\n * Validates that all arrays in a RecordSet have consistent lengths.\n * @param recordSet - The record set to validate\n * @throws ChromaValueError if arrays have inconsistent lengths or are empty\n */\nexport const validateRecordSetLengthConsistency = (recordSet: RecordSet) => {\n  const lengths: [string, number][] = Object.entries(recordSet)\n    .filter(\n      ([field, value]) =>\n        recordSetFields.includes(field) && value !== undefined,\n    )\n    .map(([field, value]) => [field, value.length]);\n\n  if (lengths.length === 0) {\n    throw new ChromaValueError(\n      `At least one of ${recordSetFields.join(\", \")} must be provided`,\n    );\n  }\n\n  const zeroLength = lengths\n    .filter(([_, length]) => length === 0)\n    .map(([field, _]) => field);\n  if (zeroLength.length > 0) {\n    throw new ChromaValueError(\n      `Non-empty lists are required for ${zeroLength.join(\", \")}`,\n    );\n  }\n\n  if (new Set(lengths.map(([_, length]) => length)).size > 1) {\n    throw new ChromaValueError(\n      `Unequal lengths for fields ${lengths\n        .map(([field, _]) => field)\n        .join(\", \")}`,\n    );\n  }\n};\n\nconst validateEmbeddings = ({\n  embeddings,\n  fieldName = \"embeddings\",\n}: {\n  embeddings: number[][];\n  fieldName: string;\n}) => {\n  if (!Array.isArray(embeddings)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof embeddings}`,\n    );\n  }\n\n  if (embeddings.length === 0) {\n    throw new ChromaValueError(\n      \"Expected embeddings to be an array with at least one item\",\n    );\n  }\n\n  if (!embeddings.filter((e) => e.every((n: any) => typeof n === \"number\"))) {\n    throw new ChromaValueError(\n      \"Expected each embedding to be an array of numbers\",\n    );\n  }\n\n  embeddings.forEach((embedding, i) => {\n    if (embedding.length === 0) {\n      throw new ChromaValueError(\n        `Expected each embedding to be a non-empty array of numbers, but got an empty array at index ${i}`,\n      );\n    }\n  });\n};\n\nconst validateDocuments = ({\n  documents,\n  nullable = false,\n  fieldName = \"documents\",\n}: {\n  documents: (string | null | undefined)[];\n  fieldName: string;\n  nullable?: boolean;\n}) => {\n  if (!Array.isArray(documents)) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be an array, but got ${typeof documents}`,\n    );\n  }\n\n  if (documents.length === 0) {\n    throw new ChromaValueError(\n      `Expected '${fieldName}' to be a non-empty list`,\n    );\n  }\n\n  documents.forEach((document) => {\n    if (!nullable && typeof document !== \"string\" && !document) {\n      throw new ChromaValueError(\n        `Expected each document to be a string, but got ${typeof document}`,\n      );\n    }\n  });\n};\n\n/**\n * Validates an array of IDs for type correctness and uniqueness.\n * @param ids - Array of ID strings to validate\n * @throws ChromaValueError if IDs are not strings, empty, or contain duplicates\n */\nexport const validateIDs = (ids: string[]) => {\n  if (!Array.isArray(ids)) {\n    throw new ChromaValueError(\n      `Expected 'ids' to be an array, but got ${typeof ids}`,\n    );\n  }\n\n  if (ids.length === 0) {\n    throw new ChromaValueError(\"Expected 'ids' to be a non-empty list\");\n  }\n\n  const nonStrings = ids\n    .map((id, i) => [id, i] as [any, number])\n    .filter(([id, _]) => typeof id !== \"string\")\n    .map(([_, i]) => i);\n\n  if (nonStrings.length > 0) {\n    throw new ChromaValueError(\n      `Found non-string IDs at ${nonStrings.join(\", \")}`,\n    );\n  }\n\n  const seen = new Set();\n  const duplicates = ids.filter((id) => {\n    if (seen.has(id)) {\n      return id;\n    }\n    seen.add(id);\n  });\n  let message = \"Expected IDs to be unique, but found duplicates of\";\n  if (duplicates.length > 0 && duplicates.length <= 5) {\n    throw new ChromaValueError(`${message} ${duplicates.join(\", \")}`);\n  }\n  if (duplicates.length > 0) {\n    throw new ChromaValueError(\n      `${message} ${duplicates.slice(0, 5).join(\", \")}, ..., ${duplicates\n        .slice(duplicates.length - 5)\n        .join(\", \")}`,\n    );\n  }\n};\n\nexport const validateSparseVector = (v: unknown): v is SparseVector => {\n  if (typeof v !== \"object\" || v === null) {\n    return false;\n  }\n\n  const candidate = v as Record<string, unknown>;\n  const indices = candidate.indices;\n  const values = candidate.values;\n\n  if (!Array.isArray(indices) || !Array.isArray(values)) {\n    return false;\n  }\n\n  return (\n    indices.every((e) => typeof e === \"number\") &&\n    values.every((e) => typeof e === \"number\")\n  );\n};\n\n/**\n * Validates metadata object for correct types and non-emptiness.\n * @param metadata - Metadata object to validate\n * @throws ChromaValueError if metadata is invalid\n */\nexport const validateMetadata = (metadata?: Metadata) => {\n  if (!metadata) {\n    return;\n  }\n\n  if (Object.keys(metadata).length === 0) {\n    throw new ChromaValueError(\"Expected metadata to be non-empty\");\n  }\n\n  if (\n    !Object.values(metadata).every(\n      (v: any) =>\n        v === null ||\n        v === undefined ||\n        typeof v === \"string\" ||\n        typeof v === \"number\" ||\n        typeof v === \"boolean\" ||\n        validateSparseVector(v),\n    )\n  ) {\n    throw new ChromaValueError(\n      \"Expected metadata to be a string, number, boolean, SparseVector, or nullable\",\n    );\n  }\n};\n\nconst SPARSE_VECTOR_TYPE = \"sparse_vector\" as const;\n\ntype SerializedSparseVector = SparseVector & { \"#type\": typeof SPARSE_VECTOR_TYPE };\n\ntype SerializedMetadataValue =\n  | boolean\n  | number\n  | string\n  | SerializedSparseVector\n  | SparseVector\n  | null;\n\nexport type SerializedMetadata = Record<string, SerializedMetadataValue>;\n\nconst toSerializedSparseVector = (vector: SparseVector): SerializedSparseVector => ({\n  \"#type\": SPARSE_VECTOR_TYPE,\n  indices: vector.indices,\n  values: vector.values,\n});\n\nexport const serializeMetadata = (\n  metadata?: Metadata | null,\n): SerializedMetadata | null | undefined => {\n  if (metadata === undefined) {\n    return undefined;\n  }\n\n  if (metadata === null) {\n    return null;\n  }\n\n  const result: SerializedMetadata = {};\n\n  Object.entries(metadata).forEach(([key, value]) => {\n    if (validateSparseVector(value)) {\n      result[key] = toSerializedSparseVector(value);\n    } else {\n      result[key] = value ?? null;\n    }\n  });\n\n  return result;\n};\n\nexport const serializeMetadatas = (\n  metadatas?: Metadata[] | null,\n): (SerializedMetadata | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadata) => serializeMetadata(metadata) ?? null);\n};\n\nconst isSerializedSparseVector = (value: unknown): value is SerializedSparseVector => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n\n  const candidate = value as Record<string, unknown>;\n  if (candidate[\"#type\"] !== SPARSE_VECTOR_TYPE) {\n    return false;\n  }\n\n  return validateSparseVector(candidate);\n};\n\nconst deserializeMetadataValue = (\n  value: SerializedMetadataValue | undefined,\n): Metadata[keyof Metadata] | null => {\n  if (isSerializedSparseVector(value)) {\n    return {\n      indices: value.indices,\n      values: value.values,\n    };\n  }\n\n  return value as Metadata[keyof Metadata] | null;\n};\n\nexport const deserializeMetadata = (\n  metadata?: SerializedMetadata | null,\n): Metadata | null | undefined => {\n  if (metadata === undefined) {\n    return undefined;\n  }\n\n  if (metadata === null) {\n    return null;\n  }\n\n  const result: Metadata = {};\n\n  Object.entries(metadata).forEach(([key, value]) => {\n    result[key] = deserializeMetadataValue(value);\n  });\n\n  return result;\n};\n\nexport const deserializeMetadatas = (\n  metadatas?: (SerializedMetadata | null)[] | null,\n): (Metadata | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadata) => deserializeMetadata(metadata) ?? null);\n};\n\nexport const deserializeMetadataMatrix = (\n  metadatas?: (Array<SerializedMetadata | null> | null)[] | null,\n): (Array<Metadata | null> | null)[] | null | undefined => {\n  if (metadatas === undefined) {\n    return undefined;\n  }\n\n  if (metadatas === null) {\n    return null;\n  }\n\n  return metadatas.map((metadataArray) => {\n    if (metadataArray === null) {\n      return null;\n    }\n\n    const deserialized = deserializeMetadatas(metadataArray);\n    return deserialized ?? [];\n  });\n};\n\nconst validateMetadatas = (metadatas: Metadata[]) => {\n  if (!Array.isArray(metadatas)) {\n    throw new ChromaValueError(\n      `Expected metadatas to be an array, but got ${typeof metadatas}`,\n    );\n  }\n\n  metadatas.forEach((metadata) => validateMetadata(metadata));\n};\n\n/**\n * Validates a base record set for required fields and data consistency.\n * @param options - Validation options\n * @param options.recordSet - The record set to validate\n * @param options.update - Whether this is for an update operation (relaxes requirements)\n * @param options.embeddingsField - Name of the embeddings field for error messages\n * @param options.documentsField - Name of the documents field for error messages\n * @throws ChromaValueError if validation fails\n */\nexport const validateBaseRecordSet = ({\n  recordSet,\n  update = false,\n  embeddingsField = \"embeddings\",\n  documentsField = \"documents\",\n}: {\n  recordSet: BaseRecordSet;\n  update?: boolean;\n  embeddingsField?: string;\n  documentsField?: string;\n}) => {\n  if (!recordSet.embeddings && !recordSet.documents && !update) {\n    throw new ChromaValueError(\n      `At least one of '${embeddingsField}' and '${documentsField}' must be provided`,\n    );\n  }\n\n  if (recordSet.embeddings) {\n    validateEmbeddings({\n      embeddings: recordSet.embeddings,\n      fieldName: embeddingsField,\n    });\n  }\n\n  if (recordSet.documents) {\n    validateDocuments({\n      documents: recordSet.documents,\n      fieldName: documentsField,\n    });\n  }\n\n  if (recordSet.metadatas) {\n    validateMetadatas(recordSet.metadatas);\n  }\n};\n\nexport const validateMaxBatchSize = (\n  recordSetLength: number,\n  maxBatchSize: number,\n) => {\n  if (recordSetLength > maxBatchSize) {\n    throw new ChromaValueError(\n      `Record set length ${recordSetLength} exceeds max batch size ${maxBatchSize}`,\n    );\n  }\n};\n\n/**\n * Validates a where clause for metadata filtering.\n * @param where - Where clause object to validate\n * @throws ChromaValueError if the where clause is malformed\n */\nexport const validateWhere = (where: Where) => {\n  if (typeof where !== \"object\") {\n    throw new ChromaValueError(\"Expected where to be a non-empty object\");\n  }\n\n  if (Object.keys(where).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'where' to have exactly one operator, but got ${\n        Object.keys(where).length\n      }`,\n    );\n  }\n\n  Object.entries(where).forEach(([key, value]) => {\n    if (\n      key !== \"$and\" &&\n      key !== \"$or\" &&\n      key !== \"$in\" &&\n      key !== \"$nin\" &&\n      ![\"string\", \"number\", \"boolean\", \"object\"].includes(typeof value)\n    ) {\n      throw new ChromaValueError(\n        `Expected 'where' value to be a string, number, boolean, or an operator expression, but got ${value}`,\n      );\n    }\n\n    if (key === \"$and\" || key === \"$or\") {\n      if (Object.keys(value).length <= 1) {\n        throw new ChromaValueError(\n          `Expected 'where' value for $and or $or to be a list of 'where' expressions, but got ${value}`,\n        );\n      }\n\n      value.forEach((w: Where) => validateWhere(w));\n      return;\n    }\n\n    if (typeof value === \"object\") {\n      if (Object.keys(value).length != 1) {\n        throw new ChromaValueError(\n          `Expected operator expression to have one operator, but got ${value}`,\n        );\n      }\n\n      const [operator, operand] = Object.entries(value)[0];\n\n      if (\n        [\"$gt\", \"$gte\", \"$lt\", \"$lte\"].includes(operator) &&\n        typeof operand !== \"number\"\n      ) {\n        throw new ChromaValueError(\n          `Expected operand value to be a number for ${operator}, but got ${typeof operand}`,\n        );\n      }\n\n      if ([\"$in\", \"$nin\"].includes(operator) && !Array.isArray(operand)) {\n        throw new ChromaValueError(\n          `Expected operand value to be an array for ${operator}, but got ${operand}`,\n        );\n      }\n\n      if (\n        ![\"$gt\", \"$gte\", \"$lt\", \"$lte\", \"$ne\", \"$eq\", \"$in\", \"$nin\"].includes(\n          operator,\n        )\n      ) {\n        throw new ChromaValueError(\n          `Expected operator to be one of $gt, $gte, $lt, $lte, $ne, $eq, $in, $nin, but got ${operator}`,\n        );\n      }\n\n      if (\n        ![\"string\", \"number\", \"boolean\"].includes(typeof operand) &&\n        !Array.isArray(operand)\n      ) {\n        throw new ChromaValueError(\n          \"Expected operand value to be a string, number, boolean, or a list of those types\",\n        );\n      }\n\n      if (\n        Array.isArray(operand) &&\n        (operand.length === 0 ||\n          !operand.every((item) => typeof item === typeof operand[0]))\n      ) {\n        throw new ChromaValueError(\n          \"Expected 'where' operand value to be a non-empty list and all values to be of the same type\",\n        );\n      }\n    }\n  });\n};\n\n/**\n * Validates a where document clause for document content filtering.\n * @param whereDocument - Where document clause to validate\n * @throws ChromaValueError if the clause is malformed\n */\nexport const validateWhereDocument = (whereDocument: WhereDocument) => {\n  if (typeof whereDocument !== \"object\") {\n    throw new ChromaValueError(\n      \"Expected 'whereDocument' to be a non-empty object\",\n    );\n  }\n\n  if (Object.keys(whereDocument).length != 1) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' to have exactly one operator, but got ${whereDocument}`,\n    );\n  }\n\n  const [operator, operand] = Object.entries(whereDocument)[0];\n  if (\n    ![\n      \"$contains\",\n      \"$not_contains\",\n      \"$matches\",\n      \"$not_matches\",\n      \"$regex\",\n      \"$not_regex\",\n      \"$and\",\n      \"$or\",\n    ].includes(operator)\n  ) {\n    throw new ChromaValueError(\n      `Expected 'whereDocument' operator to be one of $contains, $not_contains, $matches, $not_matches, $regex, $not_regex, $and, or $or, but got ${operator}`,\n    );\n  }\n\n  if (operator === \"$and\" || operator === \"$or\") {\n    if (!Array.isArray(operand)) {\n      throw new ChromaValueError(\n        `Expected operand for ${operator} to be a list of 'whereDocument' expressions, but got ${operand}`,\n      );\n    }\n\n    if (operand.length <= 1) {\n      throw new ChromaValueError(\n        `Expected 'whereDocument' operand for ${operator} to be a list with at least two 'whereDocument' expressions`,\n      );\n    }\n\n    operand.forEach((item) => validateWhereDocument(item));\n  }\n\n  if (\n    (operand === \"$contains\" ||\n      operand === \"$not_contains\" ||\n      operand === \"$regex\" ||\n      operand === \"$not_regex\") &&\n    (typeof (operator as any) !== \"string\" || operator.length === 0)\n  ) {\n    throw new ChromaValueError(\n      `Expected operand for ${operator} to be a non empty string, but got ${operand}`,\n    );\n  }\n};\n\n/**\n * Validates include fields for query operations.\n * @param options - Validation options\n * @param options.include - Array of fields to include in results\n * @param options.exclude - Optional array of fields that should not be included\n * @throws ChromaValueError if include fields are invalid\n */\nexport const validateInclude = ({\n  include,\n  exclude,\n}: {\n  include: Include[];\n  exclude?: Include[];\n}) => {\n  if (!Array.isArray(include)) {\n    throw new ChromaValueError(\"Expected 'include' to be a non-empty array\");\n  }\n\n  const validValues = Object.keys(IncludeEnum);\n  include.forEach((item) => {\n    if (typeof (item as any) !== \"string\") {\n      throw new ChromaValueError(\"Expected 'include' items to be strings\");\n    }\n\n    if (!validValues.includes(item)) {\n      throw new ChromaValueError(\n        `Expected 'include' items to be one of ${validValues.join(\n          \", \",\n        )}, but got ${item}`,\n      );\n    }\n\n    if (exclude?.includes(item)) {\n      throw new ChromaValueError(`${item} is not allowed for this operation`);\n    }\n  });\n};\n\n/**\n * Validates the number of results parameter for queries.\n * @param nResults - Number of results to validate\n * @throws ChromaValueError if nResults is not a positive number\n */\nexport const validateNResults = (nResults: number) => {\n  if (typeof (nResults as any) !== \"number\") {\n    throw new ChromaValueError(\n      `Expected 'nResults' to be a number, but got ${typeof nResults}`,\n    );\n  }\n\n  if (nResults <= 0) {\n    throw new ChromaValueError(\"Number of requested results has to positive\");\n  }\n};\n\nexport const parseConnectionPath = (path: string) => {\n  try {\n    const url = new URL(path);\n\n    const ssl = url.protocol === \"https:\";\n    const host = url.hostname;\n    const port = url.port;\n\n    return {\n      ssl,\n      host,\n      port: Number(port),\n    };\n  } catch {\n    throw new ChromaValueError(`Invalid URL: ${path}`);\n  }\n};\nconst packEmbedding = (embedding: number[]): ArrayBuffer => {\n  const buffer = new ArrayBuffer(embedding.length * 4);\n  const view = new Float32Array(buffer);\n  for (let i = 0; i < embedding.length; i++) {\n    view[i] = embedding[i];\n  }\n  return buffer;\n};\n\nexport const embeddingsToBase64Bytes = (embeddings: number[][]) => {\n  return embeddings.map((embedding) => {\n    const buffer = packEmbedding(embedding);\n\n    const uint8Array = new Uint8Array(buffer);\n    const binaryString = Array.from(uint8Array, (byte) =>\n      String.fromCharCode(byte),\n    ).join(\"\");\n    return btoa(binaryString);\n  });\n};\n","import { EmbeddingFunctionConfiguration, SparseVector } from \"./api\";\nimport { ChromaValueError } from \"./errors\";\nimport { DefaultEmbeddingFunction } from \"@chroma-core/default-embed\";\nimport { ChromaClient } from \"./chroma-client\";\n\n/**\n * Supported vector space types.\n */\nexport type EmbeddingFunctionSpace = \"cosine\" | \"l2\" | \"ip\";\n\n/**\n * Interface for embedding functions.\n * Embedding functions transform text documents into numerical representations\n * that can be used for similarity search and other vector operations.\n */\nexport interface EmbeddingFunction {\n  /**\n   * Generates embeddings for the given texts.\n   * @param texts - Array of text strings to embed\n   * @returns Promise resolving to array of embedding vectors\n   */\n  generate(texts: string[]): Promise<number[][]>;\n  /**\n   * Generates embeddings specifically for query texts.\n   * The client will fall back to using the implementation of `generate`\n   * if this function is not provided.\n   * @param texts - Array of query text strings to embed\n   * @returns Promise resolving to array of embedding vectors\n   */\n  generateForQueries?(texts: string[]): Promise<number[][]>;\n  /** Optional name identifier for the embedding function */\n  name?: string;\n  /** Returns the default vector space for this embedding function */\n  defaultSpace?(): EmbeddingFunctionSpace;\n  /** Returns all supported vector spaces for this embedding function */\n  supportedSpaces?(): EmbeddingFunctionSpace[];\n  /** Creates an instance from configuration object */\n  buildFromConfig?(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): EmbeddingFunction;\n  /** Returns the current configuration as an object */\n  getConfig?(): Record<string, any>;\n  /**\n   * Validates that a configuration update is allowed.\n   * @param newConfig - New configuration to validate\n   */\n  validateConfigUpdate?(newConfig: Record<string, any>): void;\n  /**\n   * Validates that a configuration object is valid.\n   * @param config - Configuration to validate\n   */\n  validateConfig?(config: Record<string, any>): void;\n}\n\n/**\n * Interface for sparse embedding functions.\n * Sparse embedding functions transform text documents into sparse numerical representations\n * where only non-zero values are stored, making them efficient for high-dimensional spaces.\n */\nexport interface SparseEmbeddingFunction {\n  /**\n   * Generates sparse embeddings for the given texts.\n   * @param texts - Array of text strings to embed\n   * @returns Promise resolving to array of sparse vectors\n   */\n  generate(texts: string[]): Promise<SparseVector[]>;\n  /**\n   * Generates sparse embeddings specifically for query texts.\n   * The client will fall back to using the implementation of `generate`\n   * if this function is not provided.\n   * @param texts - Array of query text strings to embed\n   * @returns Promise resolving to array of sparse vectors\n   */\n  generateForQueries?(texts: string[]): Promise<SparseVector[]>;\n  /** Optional name identifier for the embedding function */\n  name?: string;\n  /** Creates an instance from configuration object */\n  buildFromConfig?(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): SparseEmbeddingFunction;\n  /** Returns the current configuration as an object */\n  getConfig?(): Record<string, any>;\n  /**\n   * Validates that a configuration update is allowed.\n   * @param newConfig - New configuration to validate\n   */\n  validateConfigUpdate?(newConfig: Record<string, any>): void;\n  /**\n   * Validates that a configuration object is valid.\n   * @param config - Configuration to validate\n   */\n  validateConfig?(config: Record<string, any>): void;\n}\n\n/**\n * Interface for embedding function constructor classes.\n * Used for registering and instantiating embedding functions.\n */\nexport interface EmbeddingFunctionClass {\n  /** Constructor for creating new instances */\n  new (...args: any[]): EmbeddingFunction;\n  /** Name identifier for the embedding function */\n  name: string;\n  /** Static method to build instance from configuration */\n  buildFromConfig(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): EmbeddingFunction;\n}\n\n/**\n * Interface for sparse embedding function constructor classes.\n * Used for registering and instantiating sparse embedding functions.\n */\nexport interface SparseEmbeddingFunctionClass {\n  /** Constructor for creating new instances */\n  new (...args: any[]): SparseEmbeddingFunction;\n  /** Name identifier for the embedding function */\n  name: string;\n  /** Static method to build instance from configuration */\n  buildFromConfig(\n    config: Record<string, any>,\n    client?: ChromaClient,\n  ): SparseEmbeddingFunction;\n}\n\n/**\n * Registry of available embedding functions.\n * Maps function names to their constructor classes.\n */\nexport const knownEmbeddingFunctions = new Map<\n  string,\n  EmbeddingFunctionClass\n>();\n\nconst pythonEmbeddingFunctions: Record<string, string> = {\n  onnx_mini_lm_l6_v2: \"default-embed\",\n  default: \"default-embed\",\n  together_ai: \"together-ai\",\n  sentence_transformer: \"sentence-transformer\",\n};\n\nconst unsupportedEmbeddingFunctions: Set<string> = new Set([\n  \"amazon_bedrock\",\n  \"baseten\",\n  \"langchain\",\n  \"google_palm\",\n  \"huggingface\",\n  \"instructor\",\n  \"open_clip\",\n  \"roboflow\",\n  \"text2vec\",\n]);\n\nconst chromaCloudEmbeddingFunctions: Set<string> = new Set([\n  \"chroma-cloud-splade\",\n  \"chroma-cloud-qwen\",\n]);\n\n/**\n * Registry of available sparse embedding functions.\n * Maps function names to their constructor classes.\n */\nexport const knownSparseEmbeddingFunctions = new Map<\n  string,\n  SparseEmbeddingFunctionClass\n>();\n\nconst pythonSparseEmbeddingFunctions: Record<string, string> = {\n  chroma_bm25: \"chroma-bm25\",\n};\n\nconst unsupportedSparseEmbeddingFunctions: Set<string> = new Set([\n  \"bm25\",\n  \"fastembed_sparse\",\n  \"huggingface_sparse\",\n]);\n\n/**\n * Union type covering both dense and sparse embedding functions.\n */\nexport type AnyEmbeddingFunction = EmbeddingFunction | SparseEmbeddingFunction;\n\n/**\n * Registers an embedding function in the global registry.\n * @param name - Unique name for the embedding function\n * @param fn - Embedding function class to register\n * @throws ChromaValueError if name is already registered\n */\nexport const registerEmbeddingFunction = (\n  name: string,\n  fn: EmbeddingFunctionClass,\n) => {\n  if (knownEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Embedding function with name ${name} is already registered.`,\n    );\n  }\n  knownEmbeddingFunctions.set(name, fn);\n};\n\n/**\n * Registers a sparse embedding function in the global registry.\n * @param name - Unique name for the sparse embedding function\n * @param fn - Sparse embedding function class to register\n * @throws ChromaValueError if name is already registered\n */\nexport const registerSparseEmbeddingFunction = (\n  name: string,\n  fn: SparseEmbeddingFunctionClass,\n) => {\n  if (knownSparseEmbeddingFunctions.has(name)) {\n    throw new ChromaValueError(\n      `Sparse embedding function with name ${name} is already registered.`,\n    );\n  }\n  knownSparseEmbeddingFunctions.set(name, fn);\n};\n\n/**\n * Retrieves and instantiates an embedding function from configuration.\n * @returns EmbeddingFunction instance or undefined if it cannot be constructed\n */\nexport const getEmbeddingFunction = async (args: {\n  collectionName: string;\n  client: ChromaClient;\n  efConfig?: EmbeddingFunctionConfiguration;\n}) => {\n  const { collectionName, client, efConfig } = args;\n\n  if (!efConfig) {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type === \"legacy\") {\n    console.warn(\n      `No embedding function configuration found for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type === \"unknown\") {\n    console.warn(\n      `Unknown embedding function configuration for collection ${collectionName}. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  if (efConfig.type !== \"known\") {\n    return undefined;\n  }\n\n  if (unsupportedEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      `Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  }\n\n  const packageName = pythonEmbeddingFunctions[efConfig.name] || efConfig.name;\n\n  if (packageName === \"default-embed\") {\n    await getDefaultEFConfig();\n  }\n\n  let embeddingFunction = knownEmbeddingFunctions.get(packageName);\n  if (!embeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await import(fullPackageName);\n      embeddingFunction = knownEmbeddingFunctions.get(packageName);\n    } catch (error) {\n      // Dynamic loading failed, proceed with warning\n    }\n\n    if (!embeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} embedding function. However, the @chroma-core/${packageName} package is not installed. 'add' and 'query' will fail unless you provide them embeddings directly, or install the @chroma-core/${packageName} package.`,\n      );\n      return undefined;\n    }\n  }\n\n  let constructorConfig: Record<string, any> =\n    efConfig.type === \"known\" ? (efConfig.config as Record<string, any>) : {};\n\n  try {\n    if (embeddingFunction.buildFromConfig) {\n      return embeddingFunction.buildFromConfig(constructorConfig, client);\n    }\n\n    console.warn(\n      `Embedding function ${packageName} does not define a 'buildFromConfig' function. 'add' and 'query' will fail unless you provide them embeddings directly.`,\n    );\n    return undefined;\n  } catch (e) {\n    console.warn(\n      `Embedding function ${packageName} failed to build with config: ${constructorConfig}. 'add' and 'query' will fail unless you provide them embeddings directly. Error: ${e}`,\n    );\n    return undefined;\n  }\n};\n\n/**\n * Retrieves and instantiates a sparse embedding function from configuration.\n * @returns SparseEmbeddingFunction instance or undefined if it cannot be constructed\n */\nexport const getSparseEmbeddingFunction = async (\n  collectionName: string,\n  client: ChromaClient,\n  efConfig?: EmbeddingFunctionConfiguration,\n) => {\n  if (!efConfig) {\n    return undefined;\n  }\n\n  if (efConfig.type === \"legacy\") {\n    return undefined;\n  }\n\n  if (efConfig.type !== \"known\") {\n    return undefined;\n  }\n\n  if (unsupportedSparseEmbeddingFunctions.has(efConfig.name)) {\n    console.warn(\n      \"Embedding function ${efConfig.name} is not supported in the JS/TS SDK. 'add' and 'query' will fail unless you provide them embeddings directly.\",\n    );\n    return undefined;\n  }\n\n  const packageName =\n    pythonSparseEmbeddingFunctions[efConfig.name] || efConfig.name;\n\n  let sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n  if (!sparseEmbeddingFunction) {\n    try {\n      const fullPackageName = `@chroma-core/${packageName}`;\n      await import(fullPackageName);\n      sparseEmbeddingFunction = knownSparseEmbeddingFunctions.get(packageName);\n    } catch (error) {\n      // Dynamic loading failed, proceed with warning\n    }\n\n    if (!sparseEmbeddingFunction) {\n      console.warn(\n        `Collection ${collectionName} was created with the ${packageName} sparse embedding function. However, the @chroma-core/${packageName} package is not installed.`,\n      );\n      return undefined;\n    }\n  }\n\n  let constructorConfig: Record<string, any> =\n    efConfig.type === \"known\" ? (efConfig.config as Record<string, any>) : {};\n\n  try {\n    if (sparseEmbeddingFunction.buildFromConfig) {\n      return sparseEmbeddingFunction.buildFromConfig(constructorConfig, client);\n    }\n\n    console.warn(\n      `Sparse embedding function ${packageName} does not define a 'buildFromConfig' function.`,\n    );\n    return undefined;\n  } catch (e) {\n    console.warn(\n      `Sparse embedding function ${packageName} failed to build with config: ${constructorConfig}. Error: ${e}`,\n    );\n    return undefined;\n  }\n};\n\n/**\n * Serializes an embedding function to configuration format.\n * @param embeddingFunction - User provided embedding function\n * @param configEmbeddingFunction - Collection config embedding function\n * @returns Configuration object that can recreate the function\n */\nexport const serializeEmbeddingFunction = ({\n  embeddingFunction,\n  configEmbeddingFunction,\n}: {\n  embeddingFunction?: EmbeddingFunction;\n  configEmbeddingFunction?: EmbeddingFunction;\n}): EmbeddingFunctionConfiguration | undefined => {\n  if (embeddingFunction && configEmbeddingFunction) {\n    throw new ChromaValueError(\n      \"Embedding function provided when already defined in the collection configuration\",\n    );\n  }\n\n  if (!embeddingFunction && !configEmbeddingFunction) {\n    return undefined;\n  }\n\n  const ef = embeddingFunction || configEmbeddingFunction!;\n  if (\n    !ef.getConfig ||\n    !ef.name ||\n    !(ef.constructor as EmbeddingFunctionClass).buildFromConfig\n  ) {\n    return { type: \"legacy\" };\n  }\n\n  if (ef.validateConfig) ef.validateConfig(ef.getConfig());\n  return {\n    name: ef.name,\n    type: \"known\",\n    config: ef.getConfig(),\n  };\n};\n\n/**\n * Gets the configuration for the default embedding function.\n * Dynamically imports and registers the default embedding function if needed.\n * @returns Promise resolving to default embedding function configuration\n * @throws Error if default embedding function cannot be loaded\n */\nexport const getDefaultEFConfig =\n  async (): Promise<EmbeddingFunctionConfiguration> => {\n    try {\n      const { DefaultEmbeddingFunction } = await import(\n        \"@chroma-core/default-embed\"\n      );\n      if (!knownEmbeddingFunctions.has(\"default-embed\")) {\n        registerEmbeddingFunction(\"default-embed\", DefaultEmbeddingFunction);\n      }\n    } catch (e) {\n      console.warn(\n        \"Cannot instantiate a collection with the DefaultEmbeddingFunction. Please install @chroma-core/default-embed, or provide a different embedding function\",\n      );\n    }\n    return {\n      name: \"default\",\n      type: \"known\",\n      config: {},\n    };\n  };\n","import { ChromaValueError } from \"./errors\";\nimport {\n  EmbeddingFunctionConfiguration,\n  HnswConfiguration as ApiHnswConfiguration,\n  SpannConfiguration,\n  UpdateCollectionConfiguration as ApiUpdateCollectionConfiguration,\n} from \"./api\";\nimport {\n  EmbeddingFunction,\n  EmbeddingFunctionSpace,\n  getDefaultEFConfig,\n  getEmbeddingFunction,\n  serializeEmbeddingFunction,\n} from \"./embedding-function\";\nimport { CollectionMetadata } from \"./types\";\nimport { Schema } from \"./schema\";\nimport { ChromaClient } from \"./chroma-client\";\n\nexport interface CollectionConfiguration {\n  embeddingFunction?: EmbeddingFunctionConfiguration | null;\n  hnsw?: HNSWConfiguration | null;\n  spann?: SpannConfiguration | null;\n}\n\nexport type HNSWConfiguration = ApiHnswConfiguration & {\n  batch_size?: number | null;\n  num_threads?: number | null;\n};\n\nexport type CreateCollectionConfiguration = Omit<\n  CollectionConfiguration,\n  \"embeddingFunction\"\n> & { embeddingFunction?: EmbeddingFunction };\n\nexport interface UpdateCollectionConfiguration {\n  embeddingFunction?: EmbeddingFunction;\n  hnsw?: UpdateHNSWConfiguration;\n  spann?: UpdateSPANNConfiguration;\n}\n\nexport interface UpdateHNSWConfiguration {\n  batch_size?: number;\n  ef_search?: number;\n  num_threads?: number;\n  resize_factor?: number;\n  sync_threshold?: number;\n}\n\nexport interface UpdateSPANNConfiguration {\n  search_nprobe?: number;\n  ef_search?: number;\n}\n\n/**\n * Validate user provided collection configuration and embedding function. Returns a\n * CollectionConfiguration to be used in collection creation.\n */\nexport const processCreateCollectionConfig = async ({\n  configuration,\n  embeddingFunction,\n  metadata,\n  schema,\n}: {\n  configuration?: CreateCollectionConfiguration;\n  embeddingFunction?: EmbeddingFunction | null;\n  metadata?: CollectionMetadata;\n  schema?: Schema;\n}) => {\n  let schemaEmbeddingFunction: EmbeddingFunction | null | undefined = undefined;\n  if (schema) {\n    schemaEmbeddingFunction = schema.resolveEmbeddingFunction();\n  }\n  if (configuration?.hnsw && configuration?.spann) {\n    throw new ChromaValueError(\n      \"Cannot specify both HNSW and SPANN configurations\",\n    );\n  }\n\n  let embeddingFunctionConfiguration = serializeEmbeddingFunction({\n    embeddingFunction: embeddingFunction ?? undefined,\n    configEmbeddingFunction: configuration?.embeddingFunction,\n  });\n\n  if (\n    !embeddingFunctionConfiguration &&\n    embeddingFunction !== null &&\n    schemaEmbeddingFunction === undefined\n  ) {\n    embeddingFunctionConfiguration = await getDefaultEFConfig();\n  }\n\n  const overallEf = embeddingFunction || configuration?.embeddingFunction;\n\n  if (overallEf && overallEf.defaultSpace && overallEf.supportedSpaces) {\n    if (\n      configuration?.hnsw === undefined &&\n      configuration?.spann === undefined\n    ) {\n      if (metadata === undefined || metadata?.[\"hnsw:space\"] === undefined) {\n        if (!configuration) configuration = {};\n        configuration.hnsw = { space: overallEf.defaultSpace() };\n      }\n    }\n\n    if (\n      configuration?.hnsw &&\n      !configuration.hnsw.space &&\n      overallEf.defaultSpace\n    ) {\n      configuration.hnsw.space = overallEf.defaultSpace();\n    }\n\n    if (\n      configuration?.spann &&\n      !configuration.spann.space &&\n      overallEf.defaultSpace\n    ) {\n      configuration.spann.space = overallEf.defaultSpace();\n    }\n\n    if (overallEf.supportedSpaces) {\n      const supportedSpaces = overallEf.supportedSpaces();\n\n      if (\n        configuration?.hnsw?.space &&\n        !supportedSpaces.includes(configuration.hnsw.space)\n      ) {\n        console.warn(\n          `Space '${configuration.hnsw.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. ` +\n            `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n\n      if (\n        configuration?.spann?.space &&\n        !supportedSpaces.includes(configuration.spann.space)\n      ) {\n        console.warn(\n          `Space '${configuration.spann.space}' is not supported by embedding function '${overallEf.name || \"unknown\"}'. ` +\n            `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n\n      if (\n        !configuration?.hnsw &&\n        !configuration?.spann &&\n        metadata &&\n        typeof metadata[\"hnsw:space\"] === \"string\" &&\n        !supportedSpaces.includes(\n          metadata[\"hnsw:space\"] as EmbeddingFunctionSpace,\n        )\n      ) {\n        console.warn(\n          `Space '${metadata[\"hnsw:space\"]}' from metadata is not supported by embedding function '${overallEf.name || \"unknown\"}'. ` +\n            `Supported spaces: ${supportedSpaces.join(\", \")}`,\n        );\n      }\n    }\n  }\n\n  return {\n    ...(configuration || {}),\n    embedding_function: embeddingFunctionConfiguration,\n  } as CollectionConfiguration;\n};\n\n/**\n *\n */\nexport const processUpdateCollectionConfig = async ({\n  collectionName,\n  currentConfiguration,\n  currentEmbeddingFunction,\n  newConfiguration,\n  client,\n}: {\n  collectionName: string;\n  currentConfiguration: CollectionConfiguration;\n  currentEmbeddingFunction?: EmbeddingFunction;\n  newConfiguration: UpdateCollectionConfiguration;\n  client: ChromaClient;\n}): Promise<{\n  updateConfiguration?: ApiUpdateCollectionConfiguration;\n  updateEmbeddingFunction?: EmbeddingFunction;\n}> => {\n  if (newConfiguration.hnsw && typeof newConfiguration.hnsw !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid HNSW config provided in UpdateCollectionConfiguration\",\n    );\n  }\n\n  if (newConfiguration.spann && typeof newConfiguration.spann !== \"object\") {\n    throw new ChromaValueError(\n      \"Invalid SPANN config provided in UpdateCollectionConfiguration\",\n    );\n  }\n\n  const embeddingFunction =\n    currentEmbeddingFunction ||\n    (await getEmbeddingFunction({\n      collectionName: collectionName,\n      client,\n      efConfig: currentConfiguration.embeddingFunction ?? undefined,\n    }));\n\n  const newEmbeddingFunction = newConfiguration.embeddingFunction;\n\n  if (\n    embeddingFunction &&\n    embeddingFunction.validateConfigUpdate &&\n    newEmbeddingFunction &&\n    newEmbeddingFunction.getConfig\n  ) {\n    embeddingFunction.validateConfigUpdate(newEmbeddingFunction.getConfig());\n  }\n\n  return {\n    updateConfiguration: {\n      hnsw: newConfiguration.hnsw,\n      spann: newConfiguration.spann,\n      embedding_function:\n        newEmbeddingFunction &&\n        serializeEmbeddingFunction({ embeddingFunction: newEmbeddingFunction }),\n    },\n    updateEmbeddingFunction: newEmbeddingFunction,\n  };\n};\n","export type IterableInput<T> = Iterable<T> | ArrayLike<T>;\n\nexport const isPlainObject = (value: unknown): value is Record<string, unknown> => {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === Object.prototype || prototype === null;\n};\n\nexport const deepClone = <T>(value: T): T =>\n  JSON.parse(JSON.stringify(value)) as T;\n\nexport const iterableToArray = <T>(values: IterableInput<T>): T[] => {\n  if (Array.isArray(values)) {\n    return values.slice();\n  }\n  return Array.from(values as Iterable<T>);\n};\n\nexport const assertNonEmptyArray = (values: unknown[], message: string) => {\n  if (values.length === 0) {\n    throw new Error(message);\n  }\n};\n","import { isPlainObject } from \"./common\";\n\nexport type WhereJSON = Record<string, unknown>;\nexport type WhereInput = WhereExpression | WhereJSON | null | undefined;\n\nabstract class WhereExpressionBase {\n  public abstract toJSON(): WhereJSON;\n\n  public and(other: WhereInput): WhereExpression {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this as unknown as WhereExpression;\n    }\n    return AndWhere.combine(this as unknown as WhereExpression, target);\n  }\n\n  public or(other: WhereInput): WhereExpression {\n    const target = WhereExpression.from(other);\n    if (!target) {\n      return this as unknown as WhereExpression;\n    }\n    return OrWhere.combine(this as unknown as WhereExpression, target);\n  }\n}\n\nexport abstract class WhereExpression extends WhereExpressionBase {\n  public static from(input: WhereInput): WhereExpression | undefined {\n    if (input instanceof WhereExpression) {\n      return input;\n    }\n    if (input === null || input === undefined) {\n      return undefined;\n    }\n    if (!isPlainObject(input)) {\n      throw new TypeError(\"Where input must be a WhereExpression or plain object\");\n    }\n    return parseWhereDict(input);\n  }\n}\n\nclass AndWhere extends WhereExpression {\n  constructor(private readonly conditions: WhereExpression[]) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return { $and: this.conditions.map((condition) => condition.toJSON()) };\n  }\n\n  public get operands(): WhereExpression[] {\n    return this.conditions.slice();\n  }\n\n  public static combine(left: WhereExpression, right: WhereExpression): WhereExpression {\n    const flattened: WhereExpression[] = [];\n\n    const add = (expr: WhereExpression) => {\n      if (expr instanceof AndWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n\n    add(left);\n    add(right);\n\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n\n    return new AndWhere(flattened);\n  }\n}\n\nclass OrWhere extends WhereExpression {\n  constructor(private readonly conditions: WhereExpression[]) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return { $or: this.conditions.map((condition) => condition.toJSON()) };\n  }\n\n  public get operands(): WhereExpression[] {\n    return this.conditions.slice();\n  }\n\n  public static combine(left: WhereExpression, right: WhereExpression): WhereExpression {\n    const flattened: WhereExpression[] = [];\n\n    const add = (expr: WhereExpression) => {\n      if (expr instanceof OrWhere) {\n        flattened.push(...expr.operands);\n      } else {\n        flattened.push(expr);\n      }\n    };\n\n    add(left);\n    add(right);\n\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n\n    return new OrWhere(flattened);\n  }\n}\n\nclass ComparisonWhere extends WhereExpression {\n  constructor(\n    private readonly key: string,\n    private readonly operator: string,\n    private readonly value: unknown,\n  ) {\n    super();\n  }\n\n  public toJSON(): WhereJSON {\n    return {\n      [this.key]: {\n        [this.operator]: this.value,\n      },\n    };\n  }\n}\n\nconst comparisonOperatorMap = new Map<string, (key: string, value: unknown) => WhereExpression>([\n  [\"$eq\", (key, value) => new ComparisonWhere(key, \"$eq\", value)],\n  [\"$ne\", (key, value) => new ComparisonWhere(key, \"$ne\", value)],\n  [\"$gt\", (key, value) => new ComparisonWhere(key, \"$gt\", value)],\n  [\"$gte\", (key, value) => new ComparisonWhere(key, \"$gte\", value)],\n  [\"$lt\", (key, value) => new ComparisonWhere(key, \"$lt\", value)],\n  [\"$lte\", (key, value) => new ComparisonWhere(key, \"$lte\", value)],\n  [\"$in\", (key, value) => new ComparisonWhere(key, \"$in\", value)],\n  [\"$nin\", (key, value) => new ComparisonWhere(key, \"$nin\", value)],\n  [\"$contains\", (key, value) => new ComparisonWhere(key, \"$contains\", value)],\n  [\"$not_contains\", (key, value) => new ComparisonWhere(key, \"$not_contains\", value)],\n  [\"$regex\", (key, value) => new ComparisonWhere(key, \"$regex\", value)],\n  [\"$not_regex\", (key, value) => new ComparisonWhere(key, \"$not_regex\", value)],\n]);\n\nconst parseWhereDict = (data: Record<string, unknown>): WhereExpression => {\n  if (\"$and\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$and cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$and\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$and must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item as WhereInput);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions.slice(1).reduce((acc, condition) => AndWhere.combine(acc, condition), conditions[0]);\n  }\n\n  if (\"$or\" in data) {\n    if (Object.keys(data).length !== 1) {\n      throw new Error(\"$or cannot be combined with other keys\");\n    }\n    const rawConditions = data[\"$or\"];\n    if (!Array.isArray(rawConditions) || rawConditions.length === 0) {\n      throw new TypeError(\"$or must be a non-empty array\");\n    }\n    const conditions = rawConditions.map((item, index) => {\n      const expr = WhereExpression.from(item as WhereInput);\n      if (!expr) {\n        throw new TypeError(`Invalid where clause at index ${index}`);\n      }\n      return expr;\n    });\n    if (conditions.length === 1) {\n      return conditions[0];\n    }\n    return conditions.slice(1).reduce((acc, condition) => OrWhere.combine(acc, condition), conditions[0]);\n  }\n\n  const entries = Object.entries(data);\n  if (entries.length !== 1) {\n    throw new Error(\"Where dictionary must contain exactly one field\");\n  }\n\n  const [field, value] = entries[0];\n  if (!isPlainObject(value)) {\n    return new ComparisonWhere(field, \"$eq\", value);\n  }\n\n  const operatorEntries = Object.entries(value);\n  if (operatorEntries.length !== 1) {\n    throw new Error(`Operator dictionary for field \"${field}\" must contain exactly one operator`);\n  }\n\n  const [operator, operand] = operatorEntries[0];\n  const factory = comparisonOperatorMap.get(operator);\n  if (!factory) {\n    throw new Error(`Unsupported where operator: ${operator}`);\n  }\n\n  return factory(field, operand);\n};\n\nexport const createComparisonWhere = (\n  key: string,\n  operator: string,\n  value: unknown,\n): WhereExpression => new ComparisonWhere(key, operator, value);\n","import { assertNonEmptyArray, iterableToArray, IterableInput } from \"./common\";\nimport { createComparisonWhere, WhereExpression } from \"./where\";\n\nexport class Key {\n  public static readonly ID = new Key(\"#id\");\n  public static readonly DOCUMENT = new Key(\"#document\");\n  public static readonly EMBEDDING = new Key(\"#embedding\");\n  public static readonly METADATA = new Key(\"#metadata\");\n  public static readonly SCORE = new Key(\"#score\");\n\n  constructor(public readonly name: string) {}\n\n  public eq(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$eq\", value);\n  }\n\n  public ne(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$ne\", value);\n  }\n\n  public gt(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$gt\", value);\n  }\n\n  public gte(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$gte\", value);\n  }\n\n  public lt(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$lt\", value);\n  }\n\n  public lte(value: unknown): WhereExpression {\n    return createComparisonWhere(this.name, \"$lte\", value);\n  }\n\n  public isIn(values: IterableInput<unknown>): WhereExpression {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$in requires at least one value\");\n    return createComparisonWhere(this.name, \"$in\", array);\n  }\n\n  public notIn(values: IterableInput<unknown>): WhereExpression {\n    const array = iterableToArray(values);\n    assertNonEmptyArray(array, \"$nin requires at least one value\");\n    return createComparisonWhere(this.name, \"$nin\", array);\n  }\n\n  public contains(value: string): WhereExpression {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$contains\", value);\n  }\n\n  public notContains(value: string): WhereExpression {\n    if (typeof value !== \"string\") {\n      throw new TypeError(\"$not_contains requires a string value\");\n    }\n    return createComparisonWhere(this.name, \"$not_contains\", value);\n  }\n\n  public regex(pattern: string): WhereExpression {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$regex\", pattern);\n  }\n\n  public notRegex(pattern: string): WhereExpression {\n    if (typeof pattern !== \"string\") {\n      throw new TypeError(\"$not_regex requires a string pattern\");\n    }\n    return createComparisonWhere(this.name, \"$not_regex\", pattern);\n  }\n}\n\nexport interface KeyFactory {\n  (name: string): Key;\n  ID: Key;\n  DOCUMENT: Key;\n  EMBEDDING: Key;\n  METADATA: Key;\n  SCORE: Key;\n}\n\nconst createKeyFactory = (): KeyFactory => {\n  const factory = ((name: string) => new Key(name)) as KeyFactory;\n  factory.ID = Key.ID;\n  factory.DOCUMENT = Key.DOCUMENT;\n  factory.EMBEDDING = Key.EMBEDDING;\n  factory.METADATA = Key.METADATA;\n  factory.SCORE = Key.SCORE;\n  return factory;\n};\n\nexport const K: KeyFactory = createKeyFactory();\n","export interface LimitOptions {\n  offset?: number;\n  limit?: number | null | undefined;\n}\n\nexport type LimitInput = Limit | number | LimitOptions | null | undefined;\n\nexport class Limit {\n  public readonly offset: number;\n  public readonly limit?: number;\n\n  constructor(options: LimitOptions = {}) {\n    const { offset = 0, limit } = options;\n\n    if (!Number.isInteger(offset) || offset < 0) {\n      throw new TypeError(\"Limit offset must be a non-negative integer\");\n    }\n\n    if (limit !== null && limit !== undefined) {\n      if (!Number.isInteger(limit) || limit <= 0) {\n        throw new TypeError(\"Limit must be a positive integer when provided\");\n      }\n      this.limit = limit;\n    }\n\n    this.offset = offset;\n  }\n\n  public static from(input: LimitInput, offsetOverride?: number): Limit {\n    if (input instanceof Limit) {\n      return new Limit({ offset: input.offset, limit: input.limit });\n    }\n\n    if (typeof input === \"number\") {\n      return new Limit({ limit: input, offset: offsetOverride ?? 0 });\n    }\n\n    if (input === null || input === undefined) {\n      return new Limit();\n    }\n\n    if (typeof input === \"object\") {\n      return new Limit(input as LimitOptions);\n    }\n\n    throw new TypeError(\"Invalid limit input\");\n  }\n\n  public toJSON(): { offset: number; limit?: number } {\n    const result: { offset: number; limit?: number } = { offset: this.offset };\n    if (this.limit !== undefined) {\n      result.limit = this.limit;\n    }\n    return result;\n  }\n}\n","import { Key } from \"./key\";\n\nexport type SelectKeyInput = string | Key;\n\nexport type SelectInput =\n  | Select\n  | Iterable<SelectKeyInput>\n  | { keys?: Iterable<SelectKeyInput> }\n  | null\n  | undefined;\n\nexport class Select {\n  private readonly keys: string[];\n\n  constructor(keys: Iterable<SelectKeyInput> = []) {\n    const unique = new Set<string>();\n    for (const key of keys) {\n      const normalized = key instanceof Key ? key.name : key;\n      if (typeof normalized !== \"string\") {\n        throw new TypeError(\"Select keys must be strings or Key instances\");\n      }\n      unique.add(normalized);\n    }\n    this.keys = Array.from(unique);\n  }\n\n  public static from(input: SelectInput): Select {\n    if (input instanceof Select) {\n      return new Select(input.keys);\n    }\n\n    if (input === null || input === undefined) {\n      return new Select();\n    }\n\n    if (Symbol.iterator in Object(input)) {\n      return new Select(input as Iterable<SelectKeyInput>);\n    }\n\n    if (typeof input === \"object\" && \"keys\" in (input as Record<string, unknown>)) {\n      const { keys } = input as { keys?: Iterable<SelectKeyInput> };\n      return new Select(keys ?? []);\n    }\n\n    throw new TypeError(\"Unsupported select input\");\n  }\n\n  public static all(): Select {\n    return new Select([Key.DOCUMENT, Key.EMBEDDING, Key.METADATA, Key.SCORE]);\n  }\n\n  public get values(): string[] {\n    return this.keys.slice();\n  }\n\n  public toJSON(): { keys: string[] } {\n    return { keys: this.values };\n  }\n}\n","import type { SparseVector } from \"../../api\";\nimport { deepClone, isPlainObject, IterableInput } from \"./common\";\nimport { Key } from \"./key\";\n\nexport type RankLiteral = Record<string, unknown>;\nexport type RankInput = RankExpression | RankLiteral | number | null | undefined;\n\nconst requireNumber = (value: unknown, message: string): number => {\n  if (typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)) {\n    throw new TypeError(message);\n  }\n  return value;\n};\n\nabstract class RankExpressionBase {\n  public abstract toJSON(): Record<string, unknown>;\n\n  public add(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `add operand ${index}`)),\n    ];\n    return SumRankExpression.create(expressions);\n  }\n\n  public subtract(other: RankInput): RankExpression {\n    return new SubRankExpression(\n      this as unknown as RankExpression,\n      requireRank(other, \"subtract operand\"),\n    );\n  }\n\n  public multiply(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `multiply operand ${index}`)),\n    ];\n    return MulRankExpression.create(expressions);\n  }\n\n  public divide(other: RankInput): RankExpression {\n    return new DivRankExpression(\n      this as unknown as RankExpression,\n      requireRank(other, \"divide operand\"),\n    );\n  }\n\n  public negate(): RankExpression {\n    return this.multiply(-1);\n  }\n\n  public abs(): RankExpression {\n    return new AbsRankExpression(this as unknown as RankExpression);\n  }\n\n  public exp(): RankExpression {\n    return new ExpRankExpression(this as unknown as RankExpression);\n  }\n\n  public log(): RankExpression {\n    return new LogRankExpression(this as unknown as RankExpression);\n  }\n\n  public max(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `max operand ${index}`)),\n    ];\n    return MaxRankExpression.create(expressions);\n  }\n\n  public min(...others: RankInput[]): RankExpression {\n    if (others.length === 0) {\n      return this as unknown as RankExpression;\n    }\n    const expressions = [\n      this as unknown as RankExpression,\n      ...others.map((item, index) => requireRank(item, `min operand ${index}`)),\n    ];\n    return MinRankExpression.create(expressions);\n  }\n}\n\nexport abstract class RankExpression extends RankExpressionBase {\n  public static from(input: RankInput): RankExpression | undefined {\n    if (input instanceof RankExpression) {\n      return input;\n    }\n    if (input === null || input === undefined) {\n      return undefined;\n    }\n    if (typeof input === \"number\") {\n      return new ValueRankExpression(input);\n    }\n    if (isPlainObject(input)) {\n      return new RawRankExpression(input);\n    }\n    throw new TypeError(\"Rank input must be a RankExpression, number, or plain object\");\n  }\n}\n\nclass RawRankExpression extends RankExpression {\n  constructor(private readonly raw: RankLiteral) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return deepClone(this.raw);\n  }\n}\n\nclass ValueRankExpression extends RankExpression {\n  constructor(private readonly value: number) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $val: this.value };\n  }\n}\n\nclass SumRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof SumRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new SumRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $sum: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass SubRankExpression extends RankExpression {\n  constructor(\n    private readonly left: RankExpression,\n    private readonly right: RankExpression,\n  ) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return {\n      $sub: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON(),\n      },\n    };\n  }\n}\n\nclass MulRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MulRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MulRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $mul: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass DivRankExpression extends RankExpression {\n  constructor(\n    private readonly left: RankExpression,\n    private readonly right: RankExpression,\n  ) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return {\n      $div: {\n        left: this.left.toJSON(),\n        right: this.right.toJSON(),\n      },\n    };\n  }\n}\n\nclass AbsRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $abs: this.operand.toJSON() };\n  }\n}\n\nclass ExpRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $exp: this.operand.toJSON() };\n  }\n}\n\nclass LogRankExpression extends RankExpression {\n  constructor(private readonly operand: RankExpression) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $log: this.operand.toJSON() };\n  }\n}\n\nclass MaxRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MaxRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MaxRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $max: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass MinRankExpression extends RankExpression {\n  constructor(private readonly ranks: RankExpression[]) {\n    super();\n  }\n\n  public static create(ranks: RankExpression[]): RankExpression {\n    const flattened: RankExpression[] = [];\n    for (const rank of ranks) {\n      if (rank instanceof MinRankExpression) {\n        flattened.push(...rank.operands);\n      } else {\n        flattened.push(rank);\n      }\n    }\n    if (flattened.length === 1) {\n      return flattened[0];\n    }\n    return new MinRankExpression(flattened);\n  }\n\n  public get operands(): RankExpression[] {\n    return this.ranks.slice();\n  }\n\n  public toJSON(): RankLiteral {\n    return { $min: this.ranks.map((rank) => rank.toJSON()) };\n  }\n}\n\nclass KnnRankExpression extends RankExpression {\n  constructor(private readonly config: KnnOptionsNormalized) {\n    super();\n  }\n\n  public toJSON(): RankLiteral {\n    const base: Record<string, unknown> = {\n      query: this.config.query,\n      key: this.config.key,\n      limit: this.config.limit,\n    };\n\n    if (this.config.defaultValue !== undefined) {\n      base.default = this.config.defaultValue;\n    }\n\n    if (this.config.returnRank) {\n      base.return_rank = true;\n    }\n\n    return { $knn: base };\n  }\n}\n\ninterface KnnOptionsNormalized {\n  query: number[] | SparseVector | string;\n  key: string;\n  limit: number;\n  defaultValue?: number;\n  returnRank: boolean;\n}\n\nexport interface KnnOptions {\n  query: IterableInput<number> | SparseVector | string;\n  key?: string | Key;\n  limit?: number;\n  default?: number | null;\n  returnRank?: boolean;\n}\n\nconst normalizeDenseVector = (vector: IterableInput<number>): number[] => {\n  if (Array.isArray(vector)) {\n    return vector.slice();\n  }\n  return Array.from(vector as Iterable<number>, (value) => {\n    if (typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)) {\n      throw new TypeError(\"Dense query vector values must be finite numbers\");\n    }\n    return value;\n  });\n};\n\nconst normalizeKnnOptions = (options: KnnOptions): KnnOptionsNormalized => {\n  const limit = options.limit ?? 128;\n  if (!Number.isInteger(limit) || limit <= 0) {\n    throw new TypeError(\"Knn limit must be a positive integer\");\n  }\n\n  const queryInput = options.query;\n\n  let query: number[] | SparseVector | string;\n  if (typeof queryInput === \"string\") {\n    query = queryInput;\n  } else if (\n    isPlainObject(queryInput) &&\n    Array.isArray((queryInput as SparseVector).indices) &&\n    Array.isArray((queryInput as SparseVector).values)\n  ) {\n    const sparse = queryInput as SparseVector;\n    query = {\n      indices: sparse.indices.slice(),\n      values: sparse.values.slice(),\n    };\n  } else {\n    query = normalizeDenseVector(queryInput as IterableInput<number>);\n  }\n\n  const key = options.key instanceof Key ? options.key.name : options.key ?? \"#embedding\";\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"Knn key must be a string or Key instance\");\n  }\n\n  const defaultValue =\n    options.default === null || options.default === undefined\n      ? undefined\n      : requireNumber(options.default, \"Knn default must be a number\");\n\n  if (defaultValue !== undefined && !Number.isFinite(defaultValue)) {\n    throw new TypeError(\"Knn default must be a finite number\");\n  }\n\n  return {\n    query: Array.isArray(query) || typeof query === \"string\" ? query : deepClone(query),\n    key,\n    limit,\n    defaultValue,\n    returnRank: options.returnRank ?? false,\n  };\n};\n\nconst requireRank = (input: RankInput, context: string): RankExpression => {\n  const result = RankExpression.from(input);\n  if (!result) {\n    throw new TypeError(`${context} must be a rank expression`);\n  }\n  return result;\n};\n\nexport const Val = (value: number): RankExpression =>\n  new ValueRankExpression(requireNumber(value, \"Val requires a numeric value\"));\n\nexport const Knn = (options: KnnOptions): RankExpression =>\n  new KnnRankExpression(normalizeKnnOptions(options));\n\nexport interface RrfOptions {\n  ranks: RankInput[];\n  k?: number;\n  weights?: number[];\n  normalize?: boolean;\n}\n\nexport const Rrf = ({ ranks, k = 60, weights, normalize = false }: RrfOptions): RankExpression => {\n  if (!Number.isInteger(k) || k <= 0) {\n    throw new TypeError(\"Rrf k must be a positive integer\");\n  }\n  if (!Array.isArray(ranks) || ranks.length === 0) {\n    throw new TypeError(\"Rrf requires at least one rank expression\");\n  }\n\n  const expressions = ranks.map((rank, index) => requireRank(rank, `ranks[${index}]`));\n\n  let weightValues = weights ? weights.slice() : new Array(expressions.length).fill(1);\n  if (weightValues.length !== expressions.length) {\n    throw new Error(\"Number of weights must match number of ranks\");\n  }\n  if (weightValues.some((value) => typeof value !== \"number\" || value < 0)) {\n    throw new TypeError(\"Weights must be non-negative numbers\");\n  }\n\n  if (normalize) {\n    const total = weightValues.reduce((sum, value) => sum + value, 0);\n    if (total <= 0) {\n      throw new Error(\"Weights must sum to a positive value when normalize=true\");\n    }\n    weightValues = weightValues.map((value) => value / total);\n  }\n\n  const terms = expressions.map((rank, index) => {\n    const weight = weightValues[index];\n    const numerator = Val(weight);\n    const denominator = rank.add(k);\n    return numerator.divide(denominator);\n  });\n\n  const fused = terms.reduce((acc, term) => acc.add(term));\n  return fused.negate();\n};\n\nexport const Sum = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Sum requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Sum operand ${index}`));\n  return SumRankExpression.create(expressions);\n};\n\nexport const Sub = (left: RankInput, right: RankInput): RankExpression =>\n  new SubRankExpression(requireRank(left, \"Sub left\"), requireRank(right, \"Sub right\"));\n\nexport const Mul = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Mul requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Mul operand ${index}`));\n  return MulRankExpression.create(expressions);\n};\n\nexport const Div = (left: RankInput, right: RankInput): RankExpression =>\n  new DivRankExpression(requireRank(left, \"Div left\"), requireRank(right, \"Div right\"));\n\nexport const Abs = (input: RankInput): RankExpression => requireRank(input, \"Abs\").abs();\n\nexport const Exp = (input: RankInput): RankExpression => requireRank(input, \"Exp\").exp();\n\nexport const Log = (input: RankInput): RankExpression => requireRank(input, \"Log\").log();\n\nexport const Max = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Max requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Max operand ${index}`));\n  return MaxRankExpression.create(expressions);\n};\n\nexport const Min = (...inputs: RankInput[]): RankExpression => {\n  if (inputs.length === 0) {\n    throw new Error(\"Min requires at least one rank expression\");\n  }\n  const expressions = inputs.map((rank, index) => requireRank(rank, `Min operand ${index}`));\n  return MinRankExpression.create(expressions);\n};\n","import type { SearchPayload } from \"../../api\";\nimport type { LimitInput } from \"./limit\";\nimport { Limit } from \"./limit\";\nimport type { RankInput } from \"./rank\";\nimport { RankExpression } from \"./rank\";\nimport type { SelectInput, SelectKeyInput } from \"./select\";\nimport { Select } from \"./select\";\nimport type { WhereInput } from \"./where\";\nimport { WhereExpression } from \"./where\";\n\ninterface SearchParts {\n  where?: WhereExpression;\n  rank?: RankExpression;\n  limit: Limit;\n  select: Select;\n}\n\nexport interface SearchInit {\n  where?: WhereInput;\n  rank?: RankInput;\n  limit?: LimitInput;\n  select?: SelectInput;\n}\n\nexport class Search {\n  private _where?: WhereExpression;\n  private _rank?: RankExpression;\n  private _limit: Limit;\n  private _select: Select;\n\n  constructor(init: SearchInit = {}) {\n    this._where = init.where ? WhereExpression.from(init.where) : undefined;\n    this._rank = init.rank ? RankExpression.from(init.rank) : undefined;\n    this._limit = Limit.from(init.limit ?? undefined);\n    this._select = Select.from(init.select ?? undefined);\n  }\n\n  private clone(overrides: Partial<SearchParts>): Search {\n    const next = Object.create(Search.prototype) as Search;\n    next._where = overrides.where ?? this._where;\n    next._rank = overrides.rank ?? this._rank;\n    next._limit = overrides.limit ?? this._limit;\n    next._select = overrides.select ?? this._select;\n    return next;\n  }\n\n  public where(where?: WhereInput): Search {\n    return this.clone({ where: WhereExpression.from(where) });\n  }\n\n  public rank(rank?: RankInput): Search {\n    return this.clone({ rank: RankExpression.from(rank ?? undefined) });\n  }\n\n  public limit(limit?: LimitInput, offset?: number): Search {\n    if (typeof limit === \"number\") {\n      return this.clone({ limit: Limit.from(limit, offset) });\n    }\n    return this.clone({ limit: Limit.from(limit ?? undefined) });\n  }\n\n  public select(keys?: SelectInput): Search;\n  public select(...keys: SelectKeyInput[]): Search;\n  public select(\n    first?: SelectInput | SelectKeyInput,\n    ...rest: SelectKeyInput[]\n  ): Search {\n    if (Array.isArray(first) || first instanceof Set) {\n      return this.clone({\n        select: Select.from(first as Iterable<SelectKeyInput>),\n      });\n    }\n\n    if (first instanceof Select) {\n      return this.clone({ select: Select.from(first) });\n    }\n\n    if (typeof first === \"object\" && first !== null && \"keys\" in first) {\n      return this.clone({ select: Select.from(first as SelectInput) });\n    }\n\n    const allKeys: SelectKeyInput[] = [];\n    if (first !== undefined) {\n      allKeys.push(first as SelectKeyInput);\n    }\n    if (rest.length) {\n      allKeys.push(...rest);\n    }\n\n    return this.clone({ select: Select.from(allKeys) });\n  }\n\n  public selectAll(): Search {\n    return this.clone({ select: Select.all() });\n  }\n\n  public get whereClause(): WhereExpression | undefined {\n    return this._where;\n  }\n\n  public get rankExpression(): RankExpression | undefined {\n    return this._rank;\n  }\n\n  public get limitConfig(): Limit {\n    return this._limit;\n  }\n\n  public get selectConfig(): Select {\n    return this._select;\n  }\n\n  public toPayload(): SearchPayload {\n    const payload: SearchPayload = {\n      limit: this._limit.toJSON(),\n      select: this._select.toJSON(),\n    };\n\n    if (this._where) {\n      // toJSON returns the plain where-clause structure the service expects (no wrapper).\n      // The generated SearchPayload type still says filter must look like { where_clause: â€¦ }.\n      payload.filter =\n        this._where.toJSON() as unknown as SearchPayload[\"filter\"];\n    }\n\n    if (this._rank) {\n      payload.rank = this._rank.toJSON();\n    }\n\n    return payload;\n  }\n}\n\nexport type SearchLike = Search | SearchInit;\n\nexport const toSearch = (input: SearchLike): Search =>\n  input instanceof Search ? input : new Search(input);\n","import type { SearchResponse } from \"../../api\";\nimport type { Metadata } from \"../../types\";\nimport { deserializeMetadatas } from \"../../utils\";\n\nexport interface SearchResultRow {\n  id: string;\n  document?: string | null;\n  embedding?: number[] | null;\n  metadata?: Metadata | null;\n  score?: number | null;\n}\n\nconst normalizePayloadArray = <T>(\n  payload: Array<T[] | null> | null | undefined,\n  count: number,\n): Array<T[] | null> => {\n  if (!payload) {\n    return Array(count).fill(null);\n  }\n  if (payload.length === count) {\n    return payload.map((item) => (item ? item.slice() : null));\n  }\n  const result: Array<T[] | null> = payload.map((item) => (item ? item.slice() : null));\n  while (result.length < count) {\n    result.push(null);\n  }\n  return result;\n};\n\nexport class SearchResult {\n  public readonly ids: string[][];\n  public readonly documents: Array<Array<string | null> | null>;\n  public readonly embeddings: Array<Array<Array<number> | null> | null>;\n  public readonly metadatas: Array<Array<Metadata | null> | null>;\n  public readonly scores: Array<Array<number | null> | null>;\n  public readonly select: SearchResponse[\"select\"];\n\n  constructor(response: SearchResponse) {\n    this.ids = response.ids;\n    const payloadCount = this.ids.length;\n    this.documents = normalizePayloadArray(response.documents, payloadCount);\n    this.embeddings = normalizePayloadArray(response.embeddings, payloadCount);\n    const rawMetadatas = normalizePayloadArray(response.metadatas, payloadCount);\n    this.metadatas = rawMetadatas.map((payload) => {\n      if (!payload) {\n        return null;\n      }\n      return deserializeMetadatas(payload) ?? [];\n    });\n    this.scores = normalizePayloadArray(response.scores, payloadCount);\n    this.select = response.select ?? [];\n  }\n\n  public rows(): SearchResultRow[][] {\n    const results: SearchResultRow[][] = [];\n\n    for (let payloadIndex = 0; payloadIndex < this.ids.length; payloadIndex += 1) {\n      const ids = this.ids[payloadIndex];\n      const docPayload = this.documents[payloadIndex] ?? [];\n      const embedPayload = this.embeddings[payloadIndex] ?? [];\n      const metaPayload = this.metadatas[payloadIndex] ?? [];\n      const scorePayload = this.scores[payloadIndex] ?? [];\n\n      const rows: SearchResultRow[] = ids.map((id, rowIndex) => {\n        const row: SearchResultRow = { id };\n\n        const document = docPayload[rowIndex];\n        if (document !== undefined && document !== null) {\n          row.document = document;\n        }\n\n        const embedding = embedPayload[rowIndex];\n        if (embedding !== undefined && embedding !== null) {\n          row.embedding = embedding;\n        }\n\n        const metadata = metaPayload[rowIndex];\n        if (metadata !== undefined && metadata !== null) {\n          row.metadata = metadata;\n        }\n\n        const score = scorePayload[rowIndex];\n        if (score !== undefined && score !== null) {\n          row.score = score;\n        }\n\n        return row;\n      });\n\n      results.push(rows);\n    }\n\n    return results;\n  }\n}\n","import type {\n  EmbeddingFunctionConfiguration,\n  HnswIndexConfig as ApiHnswIndexConfig,\n  Schema as InternalSchema,\n  Space,\n  SpannIndexConfig as ApiSpannIndexConfig,\n  ValueTypes as ApiValueTypes,\n} from \"./api\";\nimport {\n  AnyEmbeddingFunction,\n  EmbeddingFunction,\n  getEmbeddingFunction,\n  getSparseEmbeddingFunction,\n  SparseEmbeddingFunction,\n} from \"./embedding-function\";\nimport { Key } from \"./execution\";\nimport { ChromaClient } from \"./chroma-client\";\n\nexport const DOCUMENT_KEY = \"#document\";\nexport const EMBEDDING_KEY = \"#embedding\";\n\nconst STRING_VALUE_NAME = \"string\";\nconst FLOAT_LIST_VALUE_NAME = \"float_list\";\nconst SPARSE_VECTOR_VALUE_NAME = \"sparse_vector\";\nconst INT_VALUE_NAME = \"int\";\nconst FLOAT_VALUE_NAME = \"float\";\nconst BOOL_VALUE_NAME = \"bool\";\n\nconst FTS_INDEX_NAME = \"fts_index\";\nconst STRING_INVERTED_INDEX_NAME = \"string_inverted_index\";\nconst VECTOR_INDEX_NAME = \"vector_index\";\nconst SPARSE_VECTOR_INDEX_NAME = \"sparse_vector_index\";\nconst INT_INVERTED_INDEX_NAME = \"int_inverted_index\";\nconst FLOAT_INVERTED_INDEX_NAME = \"float_inverted_index\";\nconst BOOL_INVERTED_INDEX_NAME = \"bool_inverted_index\";\n\nexport class FtsIndexConfig {\n  readonly type = \"FtsIndexConfig\";\n}\n\nexport class StringInvertedIndexConfig {\n  readonly type = \"StringInvertedIndexConfig\";\n}\n\nexport class IntInvertedIndexConfig {\n  readonly type = \"IntInvertedIndexConfig\";\n}\n\nexport class FloatInvertedIndexConfig {\n  readonly type = \"FloatInvertedIndexConfig\";\n}\n\nexport class BoolInvertedIndexConfig {\n  readonly type = \"BoolInvertedIndexConfig\";\n}\n\nexport interface VectorIndexConfigOptions {\n  space?: Space | null;\n  embeddingFunction?: EmbeddingFunction | null;\n  sourceKey?: string | Key | null;\n  hnsw?: ApiHnswIndexConfig | null;\n  spann?: ApiSpannIndexConfig | null;\n}\n\nexport class VectorIndexConfig {\n  readonly type = \"VectorIndexConfig\";\n  space: Space | null;\n  embeddingFunction?: EmbeddingFunction | null;\n  sourceKey: string | null;\n  hnsw: ApiHnswIndexConfig | null;\n  spann: ApiSpannIndexConfig | null;\n\n  constructor(options: VectorIndexConfigOptions = {}) {\n    this.space = options.space ?? null;\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey =\n      options.sourceKey instanceof Key\n        ? options.sourceKey.name\n        : (options.sourceKey ?? null);\n    this.hnsw = options.hnsw ?? null;\n    this.spann = options.spann ?? null;\n  }\n}\n\nexport interface SparseVectorIndexConfigOptions {\n  embeddingFunction?: SparseEmbeddingFunction | null;\n  sourceKey?: string | Key | null;\n  bm25?: boolean | null;\n}\n\nexport class SparseVectorIndexConfig {\n  readonly type = \"SparseVectorIndexConfig\";\n  embeddingFunction?: SparseEmbeddingFunction | null;\n  sourceKey: string | null;\n  bm25: boolean | null;\n\n  constructor(options: SparseVectorIndexConfigOptions = {}) {\n    this.embeddingFunction = options.embeddingFunction;\n    this.sourceKey =\n      options.sourceKey instanceof Key\n        ? options.sourceKey.name\n        : (options.sourceKey ?? null);\n    this.bm25 = options.bm25 ?? null;\n  }\n}\n\nexport class FtsIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: FtsIndexConfig,\n  ) {}\n}\n\nexport class StringInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: StringInvertedIndexConfig,\n  ) {}\n}\n\nexport class VectorIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: VectorIndexConfig,\n  ) {}\n}\n\nexport class SparseVectorIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: SparseVectorIndexConfig,\n  ) {}\n}\n\nexport class IntInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: IntInvertedIndexConfig,\n  ) {}\n}\n\nexport class FloatInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: FloatInvertedIndexConfig,\n  ) {}\n}\n\nexport class BoolInvertedIndexType {\n  constructor(\n    public enabled: boolean,\n    public config: BoolInvertedIndexConfig,\n  ) {}\n}\n\nexport class StringValueType {\n  constructor(\n    public ftsIndex: FtsIndexType | null = null,\n    public stringInvertedIndex: StringInvertedIndexType | null = null,\n  ) {}\n}\n\nexport class FloatListValueType {\n  constructor(public vectorIndex: VectorIndexType | null = null) {}\n}\n\nexport class SparseVectorValueType {\n  constructor(public sparseVectorIndex: SparseVectorIndexType | null = null) {}\n}\n\nexport class IntValueType {\n  constructor(public intInvertedIndex: IntInvertedIndexType | null = null) {}\n}\n\nexport class FloatValueType {\n  constructor(\n    public floatInvertedIndex: FloatInvertedIndexType | null = null,\n  ) {}\n}\n\nexport class BoolValueType {\n  constructor(public boolInvertedIndex: BoolInvertedIndexType | null = null) {}\n}\n\nexport class ValueTypes {\n  string: StringValueType | null = null;\n  floatList: FloatListValueType | null = null;\n  sparseVector: SparseVectorValueType | null = null;\n  intValue: IntValueType | null = null;\n  floatValue: FloatValueType | null = null;\n  boolean: BoolValueType | null = null;\n}\n\nexport type IndexConfig =\n  | FtsIndexConfig\n  | VectorIndexConfig\n  | SparseVectorIndexConfig\n  | StringInvertedIndexConfig\n  | IntInvertedIndexConfig\n  | FloatInvertedIndexConfig\n  | BoolInvertedIndexConfig;\n\ntype ValueTypesJson = ApiValueTypes;\n\ntype JsonDict = Record<string, any>;\n\nconst cloneObject = <T>(value: T): T => {\n  if (value === null || value === undefined) {\n    return value;\n  }\n  if (typeof value !== \"object\") {\n    return value;\n  }\n  return Array.isArray(value)\n    ? (value.map((item) => cloneObject(item)) as T)\n    : (Object.fromEntries(\n        Object.entries(value as Record<string, unknown>).map(([k, v]) => [\n          k,\n          cloneObject(v),\n        ]),\n      ) as T);\n};\n\nconst resolveEmbeddingFunctionName = (\n  fn: AnyEmbeddingFunction | null | undefined,\n): string | undefined => {\n  if (!fn) return undefined;\n  if (typeof (fn as any).name === \"function\") {\n    try {\n      const value = (fn as any).name();\n      return typeof value === \"string\" ? value : undefined;\n    } catch (_err) {\n      return undefined;\n    }\n  }\n  if (typeof (fn as any).name === \"string\") {\n    return (fn as any).name;\n  }\n  return undefined;\n};\n\nconst prepareEmbeddingFunctionConfig = (\n  fn: AnyEmbeddingFunction | null | undefined,\n): EmbeddingFunctionConfiguration => {\n  if (!fn) {\n    return { type: \"legacy\" };\n  }\n\n  const name = resolveEmbeddingFunctionName(fn);\n  const getConfig =\n    typeof fn.getConfig === \"function\" ? fn.getConfig.bind(fn) : undefined;\n  const buildFromConfig = (fn.constructor as any)?.buildFromConfig;\n\n  if (!name || !getConfig || typeof buildFromConfig !== \"function\") {\n    return { type: \"legacy\" };\n  }\n\n  const config = getConfig();\n  if (typeof fn.validateConfig === \"function\") {\n    fn.validateConfig(config);\n  }\n\n  return {\n    type: \"known\",\n    name,\n    config,\n  };\n};\n\nconst ensureValueTypes = (\n  valueTypes: ValueTypes | null | undefined,\n): ValueTypes => valueTypes ?? new ValueTypes();\n\nconst ensureStringValueType = (valueTypes: ValueTypes): StringValueType => {\n  if (!valueTypes.string) {\n    valueTypes.string = new StringValueType();\n  }\n  return valueTypes.string;\n};\n\nconst ensureFloatListValueType = (\n  valueTypes: ValueTypes,\n): FloatListValueType => {\n  if (!valueTypes.floatList) {\n    valueTypes.floatList = new FloatListValueType();\n  }\n  return valueTypes.floatList;\n};\n\nconst ensureSparseVectorValueType = (\n  valueTypes: ValueTypes,\n): SparseVectorValueType => {\n  if (!valueTypes.sparseVector) {\n    valueTypes.sparseVector = new SparseVectorValueType();\n  }\n  return valueTypes.sparseVector;\n};\n\nconst ensureIntValueType = (valueTypes: ValueTypes): IntValueType => {\n  if (!valueTypes.intValue) {\n    valueTypes.intValue = new IntValueType();\n  }\n  return valueTypes.intValue;\n};\n\nconst ensureFloatValueType = (valueTypes: ValueTypes): FloatValueType => {\n  if (!valueTypes.floatValue) {\n    valueTypes.floatValue = new FloatValueType();\n  }\n  return valueTypes.floatValue;\n};\n\nconst ensureBoolValueType = (valueTypes: ValueTypes): BoolValueType => {\n  if (!valueTypes.boolean) {\n    valueTypes.boolean = new BoolValueType();\n  }\n  return valueTypes.boolean;\n};\n\nexport class Schema {\n  defaults: ValueTypes;\n  keys: Record<string, ValueTypes>;\n\n  constructor() {\n    this.defaults = new ValueTypes();\n    this.keys = {};\n    this.initializeDefaults();\n    this.initializeKeys();\n  }\n\n  createIndex(config?: IndexConfig, key?: string): this {\n    const configProvided = config !== undefined && config !== null;\n    const keyProvided = key !== undefined && key !== null;\n\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot enable all index types globally. Must specify either config or key.\",\n      );\n    }\n\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot create index on special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    if (config instanceof VectorIndexConfig) {\n      if (!keyProvided) {\n        this.setVectorIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"Vector index cannot be enabled on specific keys. Use createIndex(config=VectorIndexConfig(...)) without specifying a key to configure the vector index globally.\",\n      );\n    }\n\n    if (config instanceof FtsIndexConfig) {\n      if (!keyProvided) {\n        this.setFtsIndexConfig(config);\n        return this;\n      }\n      throw new Error(\n        \"FTS index cannot be enabled on specific keys. Use createIndex(config=FtsIndexConfig(...)) without specifying a key to configure the FTS index globally.\",\n      );\n    }\n\n    if (config instanceof SparseVectorIndexConfig && !keyProvided) {\n      throw new Error(\n        \"Sparse vector index must be created on a specific key. Please specify a key using: createIndex(config=SparseVectorIndexConfig(...), key='your_key')\",\n      );\n    }\n\n    // TODO: Consider removing this check in the future to allow enabling all indexes for a key\n    // Disallow enabling all index types for a key (config=undefined, key=\"some_key\")\n    if (!configProvided && keyProvided && key) {\n      throw new Error(\n        `Cannot enable all index types for key '${key}'. Please specify a specific index configuration.`,\n      );\n    }\n\n    if (configProvided && !keyProvided) {\n      this.setIndexInDefaults(config as IndexConfig, true);\n    } else if (configProvided && keyProvided && key) {\n      this.setIndexForKey(key, config as IndexConfig, true);\n    }\n\n    return this;\n  }\n\n  deleteIndex(config?: IndexConfig, key?: string): this {\n    const configProvided = config !== undefined && config !== null;\n    const keyProvided = key !== undefined && key !== null;\n\n    if (!configProvided && !keyProvided) {\n      throw new Error(\n        \"Cannot disable all indexes. Must specify either config or key.\",\n      );\n    }\n\n    if (keyProvided && key && (key === EMBEDDING_KEY || key === DOCUMENT_KEY)) {\n      throw new Error(\n        `Cannot delete index on special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    if (config instanceof VectorIndexConfig) {\n      throw new Error(\"Deleting vector index is not currently supported.\");\n    }\n\n    if (config instanceof FtsIndexConfig) {\n      throw new Error(\"Deleting FTS index is not currently supported.\");\n    }\n\n    if (config instanceof SparseVectorIndexConfig) {\n      throw new Error(\n        \"Deleting sparse vector index is not currently supported.\",\n      );\n    }\n\n    // TODO: Consider removing this check in the future to allow disabling all indexes for a key\n    // Disallow disabling all index types for a key (config=undefined, key=\"some_key\")\n    if (keyProvided && !configProvided && key) {\n      throw new Error(\n        `Cannot disable all index types for key '${key}'. Please specify a specific index configuration.`,\n      );\n    }\n\n    if (keyProvided && configProvided && key) {\n      this.setIndexForKey(key, config as IndexConfig, false);\n    } else if (!keyProvided && configProvided) {\n      this.setIndexInDefaults(config as IndexConfig, false);\n    }\n\n    return this;\n  }\n\n  serializeToJSON(): InternalSchema {\n    const defaults = this.serializeValueTypes(this.defaults);\n\n    const keys: Record<string, ValueTypesJson> = {};\n    for (const [keyName, valueTypes] of Object.entries(this.keys)) {\n      keys[keyName] = this.serializeValueTypes(valueTypes);\n    }\n\n    return {\n      defaults,\n      keys,\n    };\n  }\n\n  static async deserializeFromJSON(\n    json: InternalSchema | JsonDict | null,\n    client: ChromaClient,\n  ): Promise<Schema | undefined> {\n    if (json == null) {\n      return undefined;\n    }\n\n    const data = json as JsonDict;\n    const instance = Object.create(Schema.prototype) as Schema;\n    instance.defaults = await Schema.deserializeValueTypes(\n      (data.defaults ?? {}) as Record<string, any>,\n      client,\n    );\n    instance.keys = {};\n    const keys = (data.keys ?? {}) as Record<string, Record<string, any>>;\n    for (const [keyName, value] of Object.entries(keys)) {\n      instance.keys[keyName] = await Schema.deserializeValueTypes(\n        value,\n        client,\n      );\n    }\n    return instance;\n  }\n\n  private setVectorIndexConfig(config: VectorIndexConfig): void {\n    const defaultsFloatList = ensureFloatListValueType(this.defaults);\n    const currentDefaultsVector =\n      defaultsFloatList.vectorIndex ??\n      new VectorIndexType(false, new VectorIndexConfig());\n    defaultsFloatList.vectorIndex = new VectorIndexType(\n      currentDefaultsVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: config.sourceKey ?? null,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null,\n      }),\n    );\n\n    const embeddingValueTypes = ensureValueTypes(this.keys[EMBEDDING_KEY]);\n    this.keys[EMBEDDING_KEY] = embeddingValueTypes;\n    const overrideFloatList = ensureFloatListValueType(embeddingValueTypes);\n    const currentOverrideVector =\n      overrideFloatList.vectorIndex ??\n      new VectorIndexType(\n        true,\n        new VectorIndexConfig({ sourceKey: DOCUMENT_KEY }),\n      );\n    const preservedSourceKey =\n      currentOverrideVector.config.sourceKey ?? DOCUMENT_KEY;\n    overrideFloatList.vectorIndex = new VectorIndexType(\n      currentOverrideVector.enabled,\n      new VectorIndexConfig({\n        space: config.space ?? null,\n        embeddingFunction: config.embeddingFunction,\n        sourceKey: preservedSourceKey,\n        hnsw: config.hnsw ? cloneObject(config.hnsw) : null,\n        spann: config.spann ? cloneObject(config.spann) : null,\n      }),\n    );\n  }\n\n  private setFtsIndexConfig(config: FtsIndexConfig): void {\n    const defaultsString = ensureStringValueType(this.defaults);\n    const currentDefaultsFts =\n      defaultsString.ftsIndex ?? new FtsIndexType(false, new FtsIndexConfig());\n    defaultsString.ftsIndex = new FtsIndexType(\n      currentDefaultsFts.enabled,\n      config,\n    );\n\n    const documentValueTypes = ensureValueTypes(this.keys[DOCUMENT_KEY]);\n    this.keys[DOCUMENT_KEY] = documentValueTypes;\n    const overrideString = ensureStringValueType(documentValueTypes);\n    const currentOverrideFts =\n      overrideString.ftsIndex ?? new FtsIndexType(true, new FtsIndexConfig());\n    overrideString.ftsIndex = new FtsIndexType(\n      currentOverrideFts.enabled,\n      config,\n    );\n  }\n\n  private setIndexInDefaults(config: IndexConfig, enabled: boolean): void {\n    if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(this.defaults);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(this.defaults);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(this.defaults);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(this.defaults);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(this.defaults);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(this.defaults);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n\n  private setIndexForKey(\n    key: string,\n    config: IndexConfig,\n    enabled: boolean,\n  ): void {\n    if (config instanceof SparseVectorIndexConfig && enabled) {\n      this.validateSingleSparseVectorIndex(key);\n      this.validateSparseVectorConfig(config);\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n\n    if (config instanceof StringInvertedIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.stringInvertedIndex = new StringInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof FtsIndexConfig) {\n      const valueType = ensureStringValueType(current);\n      valueType.ftsIndex = new FtsIndexType(enabled, config);\n    } else if (config instanceof SparseVectorIndexConfig) {\n      const valueType = ensureSparseVectorValueType(current);\n      valueType.sparseVectorIndex = new SparseVectorIndexType(enabled, config);\n    } else if (config instanceof VectorIndexConfig) {\n      const valueType = ensureFloatListValueType(current);\n      valueType.vectorIndex = new VectorIndexType(enabled, config);\n    } else if (config instanceof IntInvertedIndexConfig) {\n      const valueType = ensureIntValueType(current);\n      valueType.intInvertedIndex = new IntInvertedIndexType(enabled, config);\n    } else if (config instanceof FloatInvertedIndexConfig) {\n      const valueType = ensureFloatValueType(current);\n      valueType.floatInvertedIndex = new FloatInvertedIndexType(\n        enabled,\n        config,\n      );\n    } else if (config instanceof BoolInvertedIndexConfig) {\n      const valueType = ensureBoolValueType(current);\n      valueType.boolInvertedIndex = new BoolInvertedIndexType(enabled, config);\n    }\n  }\n\n  private enableAllIndexesForKey(key: string): void {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot enable all indexes for special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n    current.string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig()),\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(true, new VectorIndexConfig()),\n    );\n    // Sparse vector indexes require both sourceKey and embeddingFunction,\n    // so they cannot be auto-enabled and must be configured explicitly\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig()),\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()),\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private disableAllIndexesForKey(key: string): void {\n    if (key === EMBEDDING_KEY || key === DOCUMENT_KEY) {\n      throw new Error(\n        `Cannot disable all indexes for special key '${key}'. These keys are managed automatically by the system.`,\n      );\n    }\n\n    const current = (this.keys[key] = ensureValueTypes(this.keys[key]));\n    current.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig()),\n    );\n    current.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig()),\n    );\n    current.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n    current.intValue = new IntValueType(\n      new IntInvertedIndexType(false, new IntInvertedIndexConfig()),\n    );\n    current.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(false, new FloatInvertedIndexConfig()),\n    );\n    current.boolean = new BoolValueType(\n      new BoolInvertedIndexType(false, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private validateSingleSparseVectorIndex(targetKey: string): void {\n    for (const [existingKey, valueTypes] of Object.entries(this.keys)) {\n      if (existingKey === targetKey) continue;\n      const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n      if (sparseIndex?.enabled) {\n        throw new Error(\n          `Cannot enable sparse vector index on key '${targetKey}'. A sparse vector index is already enabled on key '${existingKey}'. Only one sparse vector index is allowed per collection.`,\n        );\n      }\n    }\n  }\n\n  private validateSparseVectorConfig(config: SparseVectorIndexConfig): void {\n    // Validate that if source_key is provided then embedding_function is also provided\n    // since there is no default embedding function\n    if (\n      config.sourceKey !== null &&\n      config.sourceKey !== undefined &&\n      !config.embeddingFunction\n    ) {\n      throw new Error(\n        `If sourceKey is provided then embeddingFunction must also be provided since there is no default embedding function. Config: ${JSON.stringify(config)}`,\n      );\n    }\n  }\n\n  private initializeDefaults(): void {\n    this.defaults.string = new StringValueType(\n      new FtsIndexType(false, new FtsIndexConfig()),\n      new StringInvertedIndexType(true, new StringInvertedIndexConfig()),\n    );\n\n    this.defaults.floatList = new FloatListValueType(\n      new VectorIndexType(false, new VectorIndexConfig()),\n    );\n\n    this.defaults.sparseVector = new SparseVectorValueType(\n      new SparseVectorIndexType(false, new SparseVectorIndexConfig()),\n    );\n\n    this.defaults.intValue = new IntValueType(\n      new IntInvertedIndexType(true, new IntInvertedIndexConfig()),\n    );\n\n    this.defaults.floatValue = new FloatValueType(\n      new FloatInvertedIndexType(true, new FloatInvertedIndexConfig()),\n    );\n\n    this.defaults.boolean = new BoolValueType(\n      new BoolInvertedIndexType(true, new BoolInvertedIndexConfig()),\n    );\n  }\n\n  private initializeKeys(): void {\n    this.keys[DOCUMENT_KEY] = new ValueTypes();\n    this.keys[DOCUMENT_KEY].string = new StringValueType(\n      new FtsIndexType(true, new FtsIndexConfig()),\n      new StringInvertedIndexType(false, new StringInvertedIndexConfig()),\n    );\n\n    this.keys[EMBEDDING_KEY] = new ValueTypes();\n    this.keys[EMBEDDING_KEY].floatList = new FloatListValueType(\n      new VectorIndexType(\n        true,\n        new VectorIndexConfig({ sourceKey: DOCUMENT_KEY }),\n      ),\n    );\n  }\n\n  private serializeValueTypes(valueTypes: ValueTypes): ValueTypesJson {\n    const result: ValueTypesJson = {};\n\n    if (valueTypes.string) {\n      const serialized = this.serializeStringValueType(valueTypes.string);\n      if (Object.keys(serialized).length > 0) {\n        result[STRING_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.floatList) {\n      const serialized = this.serializeFloatListValueType(valueTypes.floatList);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_LIST_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.sparseVector) {\n      const serialized = this.serializeSparseVectorValueType(\n        valueTypes.sparseVector,\n      );\n      if (Object.keys(serialized).length > 0) {\n        result[SPARSE_VECTOR_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.intValue) {\n      const serialized = this.serializeIntValueType(valueTypes.intValue);\n      if (Object.keys(serialized).length > 0) {\n        result[INT_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.floatValue) {\n      const serialized = this.serializeFloatValueType(valueTypes.floatValue);\n      if (Object.keys(serialized).length > 0) {\n        result[FLOAT_VALUE_NAME] = serialized;\n      }\n    }\n\n    if (valueTypes.boolean) {\n      const serialized = this.serializeBoolValueType(valueTypes.boolean);\n      if (Object.keys(serialized).length > 0) {\n        result[BOOL_VALUE_NAME] = serialized;\n      }\n    }\n\n    return result;\n  }\n\n  private serializeStringValueType(valueType: StringValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.ftsIndex) {\n      result[FTS_INDEX_NAME] = {\n        enabled: valueType.ftsIndex.enabled,\n        config: this.serializeConfig(valueType.ftsIndex.config),\n      };\n    }\n    if (valueType.stringInvertedIndex) {\n      result[STRING_INVERTED_INDEX_NAME] = {\n        enabled: valueType.stringInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.stringInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeFloatListValueType(valueType: FloatListValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.vectorIndex) {\n      result[VECTOR_INDEX_NAME] = {\n        enabled: valueType.vectorIndex.enabled,\n        config: this.serializeConfig(valueType.vectorIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeSparseVectorValueType(\n    valueType: SparseVectorValueType,\n  ): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.sparseVectorIndex) {\n      result[SPARSE_VECTOR_INDEX_NAME] = {\n        enabled: valueType.sparseVectorIndex.enabled,\n        config: this.serializeConfig(valueType.sparseVectorIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeIntValueType(valueType: IntValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.intInvertedIndex) {\n      result[INT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.intInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.intInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeFloatValueType(valueType: FloatValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.floatInvertedIndex) {\n      result[FLOAT_INVERTED_INDEX_NAME] = {\n        enabled: valueType.floatInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.floatInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeBoolValueType(valueType: BoolValueType): JsonDict {\n    const result: JsonDict = {};\n    if (valueType.boolInvertedIndex) {\n      result[BOOL_INVERTED_INDEX_NAME] = {\n        enabled: valueType.boolInvertedIndex.enabled,\n        config: this.serializeConfig(valueType.boolInvertedIndex.config),\n      };\n    }\n    return result;\n  }\n\n  private serializeConfig(config: IndexConfig): JsonDict {\n    if (config instanceof VectorIndexConfig) {\n      return this.serializeVectorConfig(config);\n    }\n    if (config instanceof SparseVectorIndexConfig) {\n      return this.serializeSparseVectorConfig(config);\n    }\n    return {};\n  }\n\n  private serializeVectorConfig(config: VectorIndexConfig): JsonDict {\n    const serialized: JsonDict = {};\n    const embeddingFunction = config.embeddingFunction;\n    const efConfig = prepareEmbeddingFunctionConfig(embeddingFunction);\n    serialized[\"embedding_function\"] = efConfig;\n\n    let resolvedSpace = config.space ?? null;\n    if (!resolvedSpace && embeddingFunction?.defaultSpace) {\n      resolvedSpace = embeddingFunction.defaultSpace();\n    }\n\n    if (\n      resolvedSpace &&\n      embeddingFunction?.supportedSpaces &&\n      !embeddingFunction.supportedSpaces().includes(resolvedSpace)\n    ) {\n      console.warn(\n        `Space '${resolvedSpace}' is not supported by embedding function '${resolveEmbeddingFunctionName(embeddingFunction) ?? \"unknown\"}'. Supported spaces: ${embeddingFunction\n          .supportedSpaces()\n          .join(\", \")}`,\n      );\n    }\n\n    if (resolvedSpace) {\n      serialized.space = resolvedSpace;\n    }\n\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n\n    if (config.hnsw) {\n      serialized.hnsw = cloneObject(config.hnsw);\n    }\n\n    if (config.spann) {\n      serialized.spann = cloneObject(config.spann);\n    }\n\n    return serialized;\n  }\n\n  private serializeSparseVectorConfig(\n    config: SparseVectorIndexConfig,\n  ): JsonDict {\n    const serialized: JsonDict = {};\n    const embeddingFunction = config.embeddingFunction;\n    serialized[\"embedding_function\"] =\n      prepareEmbeddingFunctionConfig(embeddingFunction);\n\n    if (config.sourceKey) {\n      serialized.source_key = config.sourceKey;\n    }\n\n    if (typeof config.bm25 === \"boolean\") {\n      serialized.bm25 = config.bm25;\n    }\n\n    return serialized;\n  }\n\n  private static async deserializeValueTypes(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<ValueTypes> {\n    const result = new ValueTypes();\n\n    if (json[STRING_VALUE_NAME]) {\n      result.string = Schema.deserializeStringValueType(\n        json[STRING_VALUE_NAME],\n      );\n    }\n\n    if (json[FLOAT_LIST_VALUE_NAME]) {\n      result.floatList = await Schema.deserializeFloatListValueType(\n        json[FLOAT_LIST_VALUE_NAME],\n        client,\n      );\n    }\n\n    if (json[SPARSE_VECTOR_VALUE_NAME]) {\n      result.sparseVector = await Schema.deserializeSparseVectorValueType(\n        json[SPARSE_VECTOR_VALUE_NAME],\n        client,\n      );\n    }\n\n    if (json[INT_VALUE_NAME]) {\n      result.intValue = Schema.deserializeIntValueType(json[INT_VALUE_NAME]);\n    }\n\n    if (json[FLOAT_VALUE_NAME]) {\n      result.floatValue = Schema.deserializeFloatValueType(\n        json[FLOAT_VALUE_NAME],\n      );\n    }\n\n    if (json[BOOL_VALUE_NAME]) {\n      result.boolean = Schema.deserializeBoolValueType(json[BOOL_VALUE_NAME]);\n    }\n\n    return result;\n  }\n\n  private static deserializeStringValueType(\n    json: Record<string, any>,\n  ): StringValueType {\n    let ftsIndex: FtsIndexType | null = null;\n    let stringIndex: StringInvertedIndexType | null = null;\n\n    if (json[FTS_INDEX_NAME]) {\n      const data = json[FTS_INDEX_NAME];\n      ftsIndex = new FtsIndexType(Boolean(data.enabled), new FtsIndexConfig());\n    }\n\n    if (json[STRING_INVERTED_INDEX_NAME]) {\n      const data = json[STRING_INVERTED_INDEX_NAME];\n      stringIndex = new StringInvertedIndexType(\n        Boolean(data.enabled),\n        new StringInvertedIndexConfig(),\n      );\n    }\n\n    return new StringValueType(ftsIndex, stringIndex);\n  }\n\n  private static async deserializeFloatListValueType(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<FloatListValueType> {\n    let vectorIndex: VectorIndexType | null = null;\n    if (json[VECTOR_INDEX_NAME]) {\n      const data = json[VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await Schema.deserializeVectorConfig(\n        data.config ?? {},\n        client,\n      );\n      vectorIndex = new VectorIndexType(enabled, config);\n    }\n    return new FloatListValueType(vectorIndex);\n  }\n\n  private static async deserializeSparseVectorValueType(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<SparseVectorValueType> {\n    let sparseIndex: SparseVectorIndexType | null = null;\n    if (json[SPARSE_VECTOR_INDEX_NAME]) {\n      const data = json[SPARSE_VECTOR_INDEX_NAME];\n      const enabled = Boolean(data.enabled);\n      const config = await Schema.deserializeSparseVectorConfig(\n        data.config ?? {},\n        client,\n      );\n      sparseIndex = new SparseVectorIndexType(enabled, config);\n    }\n    return new SparseVectorValueType(sparseIndex);\n  }\n\n  private static deserializeIntValueType(\n    json: Record<string, any>,\n  ): IntValueType {\n    let index: IntInvertedIndexType | null = null;\n    if (json[INT_INVERTED_INDEX_NAME]) {\n      const data = json[INT_INVERTED_INDEX_NAME];\n      index = new IntInvertedIndexType(\n        Boolean(data.enabled),\n        new IntInvertedIndexConfig(),\n      );\n    }\n    return new IntValueType(index);\n  }\n\n  private static deserializeFloatValueType(\n    json: Record<string, any>,\n  ): FloatValueType {\n    let index: FloatInvertedIndexType | null = null;\n    if (json[FLOAT_INVERTED_INDEX_NAME]) {\n      const data = json[FLOAT_INVERTED_INDEX_NAME];\n      index = new FloatInvertedIndexType(\n        Boolean(data.enabled),\n        new FloatInvertedIndexConfig(),\n      );\n    }\n    return new FloatValueType(index);\n  }\n\n  private static deserializeBoolValueType(\n    json: Record<string, any>,\n  ): BoolValueType {\n    let index: BoolInvertedIndexType | null = null;\n    if (json[BOOL_INVERTED_INDEX_NAME]) {\n      const data = json[BOOL_INVERTED_INDEX_NAME];\n      index = new BoolInvertedIndexType(\n        Boolean(data.enabled),\n        new BoolInvertedIndexConfig(),\n      );\n    }\n    return new BoolValueType(index);\n  }\n\n  private static async deserializeVectorConfig(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<VectorIndexConfig> {\n    const config = new VectorIndexConfig({\n      space: (json.space as Space | null | undefined) ?? null,\n      sourceKey: (json.source_key as string | null | undefined) ?? null,\n      hnsw: json.hnsw ? cloneObject(json.hnsw) : null,\n      spann: json.spann ? cloneObject(json.spann) : null,\n    });\n\n    config.embeddingFunction = await getEmbeddingFunction({\n      collectionName: \"schema deserialization\",\n      client,\n      efConfig: json.embedding_function as EmbeddingFunctionConfiguration,\n    });\n    if (!config.space && config.embeddingFunction?.defaultSpace) {\n      config.space = config.embeddingFunction.defaultSpace();\n    }\n\n    return config;\n  }\n\n  private static async deserializeSparseVectorConfig(\n    json: Record<string, any>,\n    client: ChromaClient,\n  ): Promise<SparseVectorIndexConfig> {\n    const config = new SparseVectorIndexConfig({\n      sourceKey: (json.source_key as string | null | undefined) ?? null,\n      bm25: typeof json.bm25 === \"boolean\" ? json.bm25 : null,\n    });\n\n    const embeddingFunction =\n      (await getSparseEmbeddingFunction(\n        \"schema deserialization\",\n        client,\n        json.embedding_function as EmbeddingFunctionConfiguration,\n      )) ??\n      (config.embeddingFunction as\n        | SparseEmbeddingFunction\n        | null\n        | undefined) ??\n      undefined;\n\n    config.embeddingFunction = embeddingFunction ?? null;\n    return config;\n  }\n\n  public resolveEmbeddingFunction(): EmbeddingFunction | null | undefined {\n    const embeddingOverride =\n      this.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config\n        .embeddingFunction;\n    if (embeddingOverride !== undefined) {\n      return embeddingOverride;\n    }\n    return this.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n  }\n}\n","import { ChromaClient } from \"./chroma-client\";\nimport {\n  EmbeddingFunction,\n  SparseEmbeddingFunction,\n} from \"./embedding-function\";\nimport {\n  BaseRecordSet,\n  CollectionMetadata,\n  GetResult,\n  Metadata,\n  PreparedRecordSet,\n  PreparedInsertRecordSet,\n  QueryRecordSet,\n  QueryResult,\n  RecordSet,\n  Where,\n  WhereDocument,\n} from \"./types\";\nimport { Include, SparseVector, SearchPayload } from \"./api\";\nimport { DefaultService as Api } from \"./api\";\nimport {\n  validateRecordSetLengthConsistency,\n  validateIDs,\n  validateInclude,\n  validateBaseRecordSet,\n  validateWhere,\n  validateWhereDocument,\n  validateNResults,\n  validateMetadata,\n  validateMaxBatchSize,\n  embeddingsToBase64Bytes,\n  serializeMetadatas,\n  serializeMetadata,\n  deserializeMetadatas,\n  deserializeMetadataMatrix,\n  deserializeMetadata,\n} from \"./utils\";\nimport { createClient } from \"@hey-api/client-fetch\";\nimport { ChromaValueError } from \"./errors\";\nimport {\n  CollectionConfiguration,\n  processUpdateCollectionConfig,\n  UpdateCollectionConfiguration,\n} from \"./collection-configuration\";\nimport { SearchLike, SearchResult, toSearch } from \"./execution/expression\";\nimport { isPlainObject } from \"./execution/expression/common\";\nimport { Schema, EMBEDDING_KEY, DOCUMENT_KEY } from \"./schema\";\nimport type { SparseVectorIndexConfig } from \"./schema\";\n\n/**\n * Interface for collection operations using collection ID.\n * Provides methods for adding, querying, updating, and deleting records.\n */\nexport interface Collection {\n  /** Tenant name */\n  tenant: string;\n  /** Database name */\n  database: string;\n  /** Unique identifier for the collection */\n  id: string;\n  /** Name of the collection */\n  name: string;\n  /** Collection-level metadata */\n  metadata: CollectionMetadata | undefined;\n  /** Collection configuration settings */\n  configuration: CollectionConfiguration;\n  /** Optional embedding function. Must match the one used to create the collection. */\n  embeddingFunction?: EmbeddingFunction;\n  /** Collection schema describing index configuration */\n  schema?: Schema;\n  /** Gets the total number of records in the collection */\n  count(): Promise<number>;\n  /**\n   * Adds new records to the collection.\n   * @param args - Record data to add\n   */\n  add(args: {\n    /** Unique identifiers for the records */\n    ids: string[];\n    /** Optional pre-computed embeddings */\n    embeddings?: number[][];\n    /** Optional metadata for each record */\n    metadatas?: Metadata[];\n    /** Optional document text (will be embedded if embeddings not provided) */\n    documents?: string[];\n    /** Optional URIs for the records */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Retrieves records from the collection based on filters.\n   * @template TMeta - Type of metadata for type safety\n   * @param args - Query parameters for filtering records\n   * @returns Promise resolving to matching records\n   */\n  get<TMeta extends Metadata = Metadata>(args?: {\n    /** Specific record IDs to retrieve */\n    ids?: string[];\n    /** Metadata-based filtering conditions */\n    where?: Where;\n    /** Maximum number of records to return */\n    limit?: number;\n    /** Number of records to skip */\n    offset?: number;\n    /** Document content-based filtering conditions */\n    whereDocument?: WhereDocument;\n    /** Fields to include in the response */\n    include?: Include[];\n  }): Promise<GetResult<TMeta>>;\n  /**\n   * Retrieves a preview of records from the collection.\n   * @param args - Preview options\n   * @returns Promise resolving to a sample of records\n   */\n  peek(args: { limit?: number }): Promise<GetResult>;\n  /**\n   * Performs similarity search on the collection.\n   * @template TMeta - Type of metadata for type safety\n   * @param args - Query parameters for similarity search\n   * @returns Promise resolving to similar records ranked by distance\n   */\n  query<TMeta extends Metadata = Metadata>(args: {\n    /** Pre-computed query embedding vectors */\n    queryEmbeddings?: number[][];\n    /** Query text to be embedded and searched */\n    queryTexts?: string[];\n    /** Query URIs to be processed */\n    queryURIs?: string[];\n    /** Filter to specific record IDs */\n    ids?: string[];\n    /** Maximum number of results per query (default: 10) */\n    nResults?: number;\n    /** Metadata-based filtering conditions */\n    where?: Where;\n    /** Full-text search conditions */\n    whereDocument?: WhereDocument;\n    /** Fields to include in the response */\n    include?: Include[];\n  }): Promise<QueryResult<TMeta>>;\n  /**\n   * Modifies collection properties like name, metadata, or configuration.\n   * @param args - Properties to update\n   */\n  modify(args: {\n    /** New name for the collection */\n    name?: string;\n    /** New metadata for the collection */\n    metadata?: CollectionMetadata;\n    /** New configuration settings */\n    configuration?: UpdateCollectionConfiguration;\n  }): Promise<void>;\n  /**\n   * Creates a copy of the collection with a new name.\n   * @param args - Fork options\n   * @returns Promise resolving to the new Collection instance\n   */\n  fork({ name }: { name: string }): Promise<Collection>;\n  /**\n   * Updates existing records in the collection.\n   * @param args - Record data to update\n   */\n  update(args: {\n    /** IDs of records to update */\n    ids: string[];\n    /** New embedding vectors */\n    embeddings?: number[][];\n    /** New metadata */\n    metadatas?: Metadata[];\n    /** New document text */\n    documents?: string[];\n    /** New URIs */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Inserts new records or updates existing ones (upsert operation).\n   * @param args - Record data to upsert\n   */\n  upsert(args: {\n    /** IDs of records to upsert */\n    ids: string[];\n    /** Embedding vectors */\n    embeddings?: number[][];\n    /** Metadata */\n    metadatas?: Metadata[];\n    /** Document text */\n    documents?: string[];\n    /** URIs */\n    uris?: string[];\n  }): Promise<void>;\n  /**\n   * Deletes records from the collection based on filters.\n   * @param args - Deletion criteria\n   */\n  delete(args: {\n    /** Specific record IDs to delete */\n    ids?: string[];\n    /** Metadata-based filtering for deletion */\n    where?: Where;\n    /** Document content-based filtering for deletion */\n    whereDocument?: WhereDocument;\n  }): Promise<void>;\n  /**\n   * Performs hybrid search on the collection using expression builders.\n   * @param searches - Single search payload or array of payloads\n   * @returns Promise resolving to column-major search results\n   */\n  search(searches: SearchLike | SearchLike[]): Promise<SearchResult>;\n}\n\n/**\n * Arguments for creating a Collection instance.\n */\nexport interface CollectionArgs {\n  /** ChromaDB client instance */\n  chromaClient: ChromaClient;\n  /** HTTP API client */\n  apiClient: ReturnType<typeof createClient>;\n  /** Collection name */\n  name: string;\n  /** Collection ID */\n  id: string;\n  /** Tenant name */\n  tenant: string;\n  /** Database name */\n  database: string;\n  /** Embedding function for the collection */\n  embeddingFunction?: EmbeddingFunction;\n  /** Collection configuration */\n  configuration: CollectionConfiguration;\n  /** Optional collection metadata */\n  metadata?: CollectionMetadata;\n  /** Optional schema returned by the server */\n  schema?: Schema;\n}\n\n/**\n * Implementation of CollectionAPI for ID-based collection operations.\n * Provides core functionality for interacting with collections using their ID.\n */\nexport class CollectionImpl implements Collection {\n  protected readonly chromaClient: ChromaClient;\n  protected readonly apiClient: ReturnType<typeof createClient>;\n  public readonly id: string;\n  public readonly tenant: string;\n  public readonly database: string;\n  private _name: string;\n  private _metadata: CollectionMetadata | undefined;\n  private _configuration: CollectionConfiguration;\n  protected _embeddingFunction: EmbeddingFunction | undefined;\n  protected _schema: Schema | undefined;\n\n  /**\n   * Creates a new CollectionAPIImpl instance.\n   * @param options - Configuration for the collection API\n   */\n  constructor({\n    chromaClient,\n    apiClient,\n    id,\n    tenant,\n    database,\n    name,\n    metadata,\n    configuration,\n    embeddingFunction,\n    schema,\n  }: CollectionArgs) {\n    this.chromaClient = chromaClient;\n    this.apiClient = apiClient;\n    this.id = id;\n    this.tenant = tenant;\n    this.database = database;\n    this._name = name;\n    this._metadata = metadata;\n    this._configuration = configuration;\n    this._embeddingFunction = embeddingFunction;\n    this._schema = schema;\n  }\n\n  public get name(): string {\n    return this._name;\n  }\n\n  private set name(name: string) {\n    this._name = name;\n  }\n\n  public get configuration(): CollectionConfiguration {\n    return this._configuration;\n  }\n\n  private set configuration(configuration: CollectionConfiguration) {\n    this._configuration = configuration;\n  }\n\n  public get metadata(): CollectionMetadata | undefined {\n    return this._metadata;\n  }\n\n  private set metadata(metadata: CollectionMetadata | undefined) {\n    this._metadata = metadata;\n  }\n\n  public get embeddingFunction(): EmbeddingFunction | undefined {\n    return this._embeddingFunction;\n  }\n\n  protected set embeddingFunction(\n    embeddingFunction: EmbeddingFunction | undefined,\n  ) {\n    this._embeddingFunction = embeddingFunction;\n  }\n\n  public get schema(): Schema | undefined {\n    return this._schema;\n  }\n\n  protected set schema(schema: Schema | undefined) {\n    this._schema = schema;\n  }\n\n  protected async path(): Promise<{\n    tenant: string;\n    database: string;\n    collection_id: string;\n  }> {\n    return {\n      tenant: this.tenant,\n      database: this.database,\n      collection_id: this.id,\n    };\n  }\n\n  private async embed(inputs: string[], isQuery: boolean): Promise<number[][]> {\n    const embeddingFunction =\n      this._embeddingFunction ?? this.getSchemaEmbeddingFunction();\n\n    if (!embeddingFunction) {\n      throw new ChromaValueError(\n        \"Embedding function must be defined for operations requiring embeddings.\",\n      );\n    }\n\n    if (isQuery && embeddingFunction.generateForQueries) {\n      return await embeddingFunction.generateForQueries(inputs);\n    }\n\n    return await embeddingFunction.generate(inputs);\n  }\n\n  private async sparseEmbed(\n    sparseEmbeddingFunction: SparseEmbeddingFunction,\n    inputs: string[],\n    isQuery: boolean,\n  ): Promise<SparseVector[]> {\n    if (isQuery && sparseEmbeddingFunction.generateForQueries) {\n      return await sparseEmbeddingFunction.generateForQueries(inputs);\n    }\n\n    return await sparseEmbeddingFunction.generate(inputs);\n  }\n\n  private getSparseEmbeddingTargets(): Record<string, SparseVectorIndexConfig> {\n    const schema = this._schema;\n    if (!schema) return {};\n\n    const targets: Record<string, SparseVectorIndexConfig> = {};\n    for (const [key, valueTypes] of Object.entries(schema.keys)) {\n      const sparseVector = valueTypes.sparseVector;\n      const sparseIndex = sparseVector?.sparseVectorIndex;\n      if (!sparseIndex?.enabled) continue;\n\n      const config = sparseIndex.config;\n      if (!config.embeddingFunction || !config.sourceKey) continue;\n\n      targets[key] = config;\n    }\n\n    return targets;\n  }\n\n  private async applySparseEmbeddingsToMetadatas(\n    metadatas?: Metadata[],\n    documents?: string[],\n  ): Promise<Metadata[] | undefined> {\n    const sparseTargets = this.getSparseEmbeddingTargets();\n    if (Object.keys(sparseTargets).length === 0) {\n      return metadatas;\n    }\n\n    // If no metadatas provided, create empty objects based on documents length\n    if (!metadatas) {\n      if (!documents) {\n        return undefined;\n      }\n      metadatas = Array(documents.length)\n        .fill(null)\n        .map(() => ({}));\n    }\n\n    // Create copies, converting null to empty object\n    const updatedMetadatas = metadatas.map((metadata) =>\n      metadata !== null && metadata !== undefined ? { ...metadata } : {},\n    );\n    const documentsList = documents ? [...documents] : undefined;\n\n    for (const [targetKey, config] of Object.entries(sparseTargets)) {\n      const sourceKey = config.sourceKey;\n      const embeddingFunction = config.embeddingFunction;\n      if (!sourceKey || !embeddingFunction) {\n        continue;\n      }\n\n      const inputs: string[] = [];\n      const positions: number[] = [];\n\n      // Handle special case: source_key is \"#document\"\n      if (sourceKey === DOCUMENT_KEY) {\n        if (!documentsList) {\n          continue;\n        }\n\n        // Collect documents that need embedding\n        updatedMetadatas.forEach((metadata, index) => {\n          // Skip if target already exists in metadata\n          if (targetKey in metadata) {\n            return;\n          }\n\n          // Get document at this position\n          if (index < documentsList.length) {\n            const doc = documentsList[index];\n            if (typeof doc === \"string\") {\n              inputs.push(doc);\n              positions.push(index);\n            }\n          }\n        });\n\n        // Generate embeddings for all collected documents\n        if (inputs.length === 0) {\n          continue;\n        }\n\n        const sparseEmbeddings = await this.sparseEmbed(\n          embeddingFunction,\n          inputs,\n          false,\n        );\n        if (sparseEmbeddings.length !== positions.length) {\n          throw new ChromaValueError(\n            \"Sparse embedding function returned unexpected number of embeddings.\",\n          );\n        }\n\n        positions.forEach((position, idx) => {\n          updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];\n        });\n\n        continue; // Skip the metadata-based logic below\n      }\n\n      // Handle normal case: source_key is a metadata field\n      updatedMetadatas.forEach((metadata, index) => {\n        if (targetKey in metadata) {\n          return;\n        }\n\n        const sourceValue = metadata[sourceKey];\n        if (typeof sourceValue !== \"string\") {\n          return;\n        }\n\n        inputs.push(sourceValue);\n        positions.push(index);\n      });\n\n      if (inputs.length === 0) {\n        continue;\n      }\n\n      const sparseEmbeddings = await this.sparseEmbed(\n        embeddingFunction,\n        inputs,\n        false,\n      );\n      if (sparseEmbeddings.length !== positions.length) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\",\n        );\n      }\n\n      positions.forEach((position, idx) => {\n        updatedMetadatas[position][targetKey] = sparseEmbeddings[idx];\n      });\n    }\n\n    // Convert empty objects back to null\n    const resultMetadatas = updatedMetadatas.map((metadata) =>\n      Object.keys(metadata).length === 0 ? null : metadata,\n    );\n\n    return resultMetadatas as Metadata[];\n  }\n\n  private async embedKnnLiteral(\n    knn: Record<string, unknown>,\n  ): Promise<Record<string, unknown>> {\n    const queryValue = knn.query as unknown;\n    if (typeof queryValue !== \"string\") {\n      return { ...knn };\n    }\n\n    const keyValue = knn.key as unknown;\n    const key = typeof keyValue === \"string\" ? keyValue : EMBEDDING_KEY;\n\n    if (key === EMBEDDING_KEY) {\n      const embeddings = await this.embed([queryValue], true);\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\",\n        );\n      }\n      return { ...knn, query: embeddings[0] };\n    }\n\n    const schema = this._schema;\n    if (!schema) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': schema is not available. Provide an embedded vector or configure an embedding function.`,\n      );\n    }\n\n    const valueTypes = schema.keys[key];\n    if (!valueTypes) {\n      throw new ChromaValueError(\n        `Cannot embed string query for key '${key}': key not found in schema. Provide an embedded vector or configure an embedding function.`,\n      );\n    }\n\n    const sparseIndex = valueTypes.sparseVector?.sparseVectorIndex;\n    if (sparseIndex?.enabled && sparseIndex.config.embeddingFunction) {\n      const sparseEmbeddingFunction = sparseIndex.config.embeddingFunction;\n      const sparseEmbeddings = await this.sparseEmbed(\n        sparseEmbeddingFunction,\n        [queryValue],\n        true,\n      );\n      if (!sparseEmbeddings || sparseEmbeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Sparse embedding function returned unexpected number of embeddings.\",\n        );\n      }\n      return { ...knn, query: sparseEmbeddings[0] };\n    }\n\n    const vectorIndex = valueTypes.floatList?.vectorIndex;\n    if (vectorIndex?.enabled && vectorIndex.config.embeddingFunction) {\n      const embeddingFunction = vectorIndex.config.embeddingFunction;\n      const embeddings = embeddingFunction.generateForQueries\n        ? await embeddingFunction.generateForQueries([queryValue])\n        : await embeddingFunction.generate([queryValue]);\n\n      if (!embeddings || embeddings.length !== 1) {\n        throw new ChromaValueError(\n          \"Embedding function returned unexpected number of embeddings.\",\n        );\n      }\n\n      return { ...knn, query: embeddings[0] };\n    }\n\n    throw new ChromaValueError(\n      `Cannot embed string query for key '${key}': no embedding function configured. Provide an embedded vector or configure an embedding function.`,\n    );\n  }\n\n  private async embedRankLiteral(rank: unknown): Promise<unknown> {\n    if (rank === null || rank === undefined) {\n      return rank;\n    }\n\n    if (Array.isArray(rank)) {\n      return Promise.all(rank.map((item) => this.embedRankLiteral(item)));\n    }\n\n    if (!isPlainObject(rank)) {\n      return rank;\n    }\n\n    const entries = await Promise.all(\n      Object.entries(rank).map(async ([key, value]) => {\n        if (key === \"$knn\" && isPlainObject(value)) {\n          return [key, await this.embedKnnLiteral(value)];\n        }\n        return [key, await this.embedRankLiteral(value)];\n      }),\n    );\n\n    return Object.fromEntries(entries);\n  }\n\n  private async embedSearchPayload(\n    payload: SearchPayload,\n  ): Promise<SearchPayload> {\n    if (!payload.rank) {\n      return payload;\n    }\n\n    const embeddedRank = await this.embedRankLiteral(payload.rank);\n    if (!isPlainObject(embeddedRank)) {\n      return payload;\n    }\n\n    return {\n      ...payload,\n      rank: embeddedRank as SearchPayload[\"rank\"],\n    };\n  }\n\n  private getSchemaEmbeddingFunction(): EmbeddingFunction | undefined {\n    const schema = this._schema;\n    if (!schema) return undefined;\n\n    const schemaOverride = schema.keys[EMBEDDING_KEY];\n    const overrideFunction =\n      schemaOverride?.floatList?.vectorIndex?.config.embeddingFunction;\n    if (overrideFunction) {\n      return overrideFunction;\n    }\n\n    const defaultFunction =\n      schema.defaults.floatList?.vectorIndex?.config.embeddingFunction;\n    return defaultFunction ?? undefined;\n  }\n\n  private async prepareRecords<T extends boolean = false>({\n    recordSet,\n    update = false as T,\n  }: {\n    recordSet: RecordSet;\n    update?: T;\n  }): Promise<T extends true ? PreparedRecordSet : PreparedInsertRecordSet> {\n    const maxBatchSize = await this.chromaClient.getMaxBatchSize();\n\n    validateRecordSetLengthConsistency(recordSet);\n    validateIDs(recordSet.ids);\n    validateBaseRecordSet({ recordSet, update });\n    validateMaxBatchSize(recordSet.ids.length, maxBatchSize);\n\n    if (!recordSet.embeddings && recordSet.documents) {\n      recordSet.embeddings = await this.embed(recordSet.documents, false);\n    }\n\n    const metadatasWithSparse = await this.applySparseEmbeddingsToMetadatas(\n      recordSet.metadatas,\n      recordSet.documents,\n    );\n\n    const preparedRecordSet: PreparedRecordSet = {\n      ...recordSet,\n      metadatas: metadatasWithSparse,\n    };\n\n    const base64Supported = await this.chromaClient.supportsBase64Encoding();\n    if (base64Supported && recordSet.embeddings) {\n      preparedRecordSet.embeddings = embeddingsToBase64Bytes(\n        recordSet.embeddings,\n      );\n    }\n\n    return preparedRecordSet as T extends true\n      ? PreparedRecordSet\n      : PreparedInsertRecordSet;\n  }\n\n  private validateGet(\n    include: Include[],\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n  ) {\n    validateInclude({ include, exclude: [\"distances\"] });\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n\n  private async prepareQuery(\n    recordSet: BaseRecordSet,\n    include: Include[],\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n    nResults?: number,\n  ): Promise<QueryRecordSet> {\n    validateBaseRecordSet({\n      recordSet,\n      embeddingsField: \"queryEmbeddings\",\n      documentsField: \"queryTexts\",\n    });\n    validateInclude({ include });\n\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n    if (nResults) validateNResults(nResults);\n\n    let embeddings: number[][];\n    if (!recordSet.embeddings) {\n      embeddings = await this.embed(recordSet.documents!, true);\n    } else {\n      embeddings = recordSet.embeddings;\n    }\n\n    return {\n      ...recordSet,\n      ids,\n      embeddings,\n    };\n  }\n\n  private validateDelete(\n    ids?: string[],\n    where?: Where,\n    whereDocument?: WhereDocument,\n  ) {\n    if (ids) validateIDs(ids);\n    if (where) validateWhere(where);\n    if (whereDocument) validateWhereDocument(whereDocument);\n  }\n\n  public async count(): Promise<number> {\n    const { data } = await Api.collectionCount({\n      client: this.apiClient,\n      path: await this.path(),\n    });\n\n    return data;\n  }\n\n  public async add({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }) {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({ recordSet });\n\n    await Api.collectionAdd({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        documents: preparedRecordSet.documents,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n      },\n    });\n  }\n\n  public async get<TMeta extends Metadata = Metadata>(\n    args: Partial<{\n      ids?: string[];\n      where?: Where;\n      limit?: number;\n      offset?: number;\n      whereDocument?: WhereDocument;\n      include?: Include[];\n    }> = {},\n  ): Promise<GetResult<TMeta>> {\n    const {\n      ids,\n      where,\n      limit,\n      offset,\n      whereDocument,\n      include = [\"documents\", \"metadatas\"],\n    } = args;\n\n    this.validateGet(include, ids, where, whereDocument);\n\n    const { data } = await Api.collectionGet({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        limit,\n        offset,\n        where_document: whereDocument,\n        include,\n      },\n    });\n\n    const deserializedMetadatas = deserializeMetadatas(data.metadatas) ?? [];\n\n    return new GetResult<TMeta>({\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids,\n      include: data.include,\n      metadatas: deserializedMetadatas as (TMeta | null)[],\n      uris: data.uris ?? [],\n    });\n  }\n\n  public async peek({ limit = 10 }: { limit?: number }): Promise<GetResult> {\n    return this.get({ limit });\n  }\n\n  public async query<TMeta extends Metadata = Metadata>({\n    queryEmbeddings,\n    queryTexts,\n    queryURIs,\n    ids,\n    nResults = 10,\n    where,\n    whereDocument,\n    include = [\"metadatas\", \"documents\", \"distances\"],\n  }: {\n    queryEmbeddings?: number[][];\n    queryTexts?: string[];\n    queryURIs?: string[];\n    ids?: string[];\n    nResults?: number;\n    where?: Where;\n    whereDocument?: WhereDocument;\n    include?: Include[];\n  }): Promise<QueryResult<TMeta>> {\n    const recordSet: BaseRecordSet = {\n      embeddings: queryEmbeddings,\n      documents: queryTexts,\n      uris: queryURIs,\n    };\n\n    const queryRecordSet = await this.prepareQuery(\n      recordSet,\n      include,\n      ids,\n      where,\n      whereDocument,\n      nResults,\n    );\n\n    const { data } = await Api.collectionQuery({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: queryRecordSet.ids,\n        include,\n        n_results: nResults,\n        query_embeddings: queryRecordSet.embeddings,\n        where,\n        where_document: whereDocument,\n      },\n    });\n\n    const deserializedMetadatas =\n      deserializeMetadataMatrix(data.metadatas) ?? [];\n\n    return new QueryResult({\n      distances: data.distances ?? [],\n      documents: data.documents ?? [],\n      embeddings: data.embeddings ?? [],\n      ids: data.ids ?? [],\n      include: data.include,\n      metadatas: deserializedMetadatas as (TMeta | null)[][],\n      uris: data.uris ?? [],\n    });\n  }\n\n  public async search(\n    searches: SearchLike | SearchLike[],\n  ): Promise<SearchResult> {\n    const items = Array.isArray(searches) ? searches : [searches];\n\n    if (items.length === 0) {\n      throw new ChromaValueError(\n        \"At least one search payload must be provided.\",\n      );\n    }\n\n    const payloads = await Promise.all(\n      items.map(async (search) => {\n        const payload = toSearch(search).toPayload();\n        return this.embedSearchPayload(payload);\n      }),\n    );\n\n    const { data } = await Api.collectionSearch({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { searches: payloads },\n    });\n\n    return new SearchResult(data);\n  }\n\n  public async modify({\n    name,\n    metadata,\n    configuration,\n  }: {\n    name?: string;\n    metadata?: CollectionMetadata;\n    configuration?: UpdateCollectionConfiguration;\n  }): Promise<void> {\n    if (name) this.name = name;\n\n    if (metadata) {\n      validateMetadata(metadata);\n      this.metadata = metadata;\n    }\n\n    const { updateConfiguration, updateEmbeddingFunction } = configuration\n      ? await processUpdateCollectionConfig({\n          collectionName: this.name,\n          currentConfiguration: this.configuration,\n          newConfiguration: configuration,\n          currentEmbeddingFunction: this.embeddingFunction,\n          client: this.chromaClient,\n        })\n      : {};\n\n    if (updateEmbeddingFunction) {\n      this.embeddingFunction = updateEmbeddingFunction;\n    }\n\n    if (updateConfiguration) {\n      this.configuration = {\n        hnsw: { ...this.configuration.hnsw, ...updateConfiguration.hnsw },\n        spann: { ...this.configuration.spann, ...updateConfiguration.spann },\n        embeddingFunction: updateConfiguration.embedding_function,\n      };\n    }\n\n    await Api.updateCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        new_name: name,\n        new_metadata: serializeMetadata(metadata),\n        new_configuration: updateConfiguration,\n      },\n    });\n  }\n\n  public async fork({ name }: { name: string }): Promise<Collection> {\n    const { data } = await Api.forkCollection({\n      client: this.apiClient,\n      path: await this.path(),\n      body: { new_name: name },\n    });\n\n    return new CollectionImpl({\n      chromaClient: this.chromaClient,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: this.tenant,\n      database: this.database,\n      id: data.id,\n      embeddingFunction: this._embeddingFunction,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      configuration: data.configuration_json,\n    });\n  }\n\n  public async update({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }): Promise<void> {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n      update: true,\n    });\n\n    await Api.collectionUpdate({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents,\n      },\n    });\n  }\n\n  public async upsert({\n    ids,\n    embeddings,\n    metadatas,\n    documents,\n    uris,\n  }: {\n    ids: string[];\n    embeddings?: number[][];\n    metadatas?: Metadata[];\n    documents?: string[];\n    uris?: string[];\n  }): Promise<void> {\n    const recordSet: RecordSet = {\n      ids,\n      embeddings,\n      documents,\n      metadatas,\n      uris,\n    };\n\n    const preparedRecordSet = await this.prepareRecords({\n      recordSet,\n    });\n\n    await Api.collectionUpsert({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids: preparedRecordSet.ids,\n        embeddings: preparedRecordSet.embeddings,\n        metadatas: serializeMetadatas(preparedRecordSet.metadatas),\n        uris: preparedRecordSet.uris,\n        documents: preparedRecordSet.documents,\n      },\n    });\n  }\n\n  public async delete({\n    ids,\n    where,\n    whereDocument,\n  }: {\n    ids?: string[];\n    where?: Where;\n    whereDocument?: WhereDocument;\n  }): Promise<void> {\n    this.validateDelete(ids, where, whereDocument);\n\n    await Api.collectionDelete({\n      client: this.apiClient,\n      path: await this.path(),\n      body: {\n        ids,\n        where,\n        where_document: whereDocument,\n      },\n    });\n  }\n}\n","export function withChroma(userNextConfig: any = {}): any {\n  const originalWebpackFunction = userNextConfig.webpack;\n\n  const newWebpackFunction = (config: any, options: any): any => {\n    if (!Array.isArray(config.externals)) {\n      config.externals = [];\n    }\n\n    const externalsToAdd = [\"@huggingface/transformers\", \"chromadb\"];\n    for (const ext of externalsToAdd) {\n      if (!config.externals.includes(ext)) {\n        config.externals.push(ext);\n      }\n    }\n\n    if (typeof originalWebpackFunction === \"function\") {\n      return originalWebpackFunction(config, options);\n    }\n    return config;\n  };\n\n  return {\n    ...userNextConfig,\n    webpack: newWebpackFunction,\n  };\n}\n","import {\n  ChromaClientError,\n  ChromaConnectionError,\n  ChromaError,\n  ChromaForbiddenError,\n  ChromaNotFoundError,\n  ChromaQuotaExceededError,\n  ChromaRateLimitError,\n  ChromaServerError,\n  ChromaUnauthorizedError,\n  ChromaUniqueError,\n} from \"./errors\";\n\nconst offlineError = (error: any): boolean => {\n  return Boolean(\n    (error?.name === \"TypeError\" || error?.name === \"FetchError\") &&\n    (error.message?.includes(\"fetch failed\") ||\n      error.message?.includes(\"Failed to fetch\") ||\n      error.message?.includes(\"ENOTFOUND\")),\n  );\n};\n\nconst getErrorMessage = async (response: Response): Promise<string> => {\n  try {\n    const body = await response.clone().json();\n    return body.message || body.error || `${response.status}: ${response.statusText}`;\n  } catch {\n    return `${response.status}: ${response.statusText}`;\n  }\n};\n\nexport const chromaFetch: typeof fetch = async (input, init) => {\n  let response: Response;\n  try {\n    response = await fetch(input, init);\n  } catch (err) {\n    if (offlineError(err)) {\n      throw new ChromaConnectionError(\n        \"Failed to connect to chromadb. Make sure your server is running and try again. If you are running from a browser, make sure that your chromadb instance is configured to allow requests from the current origin using the CHROMA_SERVER_CORS_ALLOW_ORIGINS environment variable.\",\n      );\n    }\n    throw new ChromaConnectionError(\"Failed to connect to Chroma\");\n  }\n\n  if (response.ok) {\n    return response;\n  }\n\n  switch (response.status) {\n    case 400:\n      let status = \"Bad Request\";\n      try {\n        const responseBody = await response.json();\n        status = responseBody.message || status;\n      } catch { }\n      throw new ChromaClientError(\n        `Bad request to ${(input as Request).url || \"Chroma\"\n        } with status: ${status}`,\n      );\n    case 401:\n      throw new ChromaUnauthorizedError(`Unauthorized`);\n    case 403:\n      throw new ChromaForbiddenError(\n        `You do not have permission to access the requested resource.`,\n      );\n    case 404:\n      throw new ChromaNotFoundError(\n        `The requested resource could not be found`,\n      );\n    case 409:\n      throw new ChromaUniqueError(\"The resource already exists\");\n    case 422:\n      try {\n        const body = await response.json();\n        if (\n          body &&\n          body.message &&\n          (body.message.startsWith(\"Quota exceeded\") ||\n            body.message.startsWith(\"Billing limit exceeded\"))\n        ) {\n          throw new ChromaQuotaExceededError(body?.message);\n        }\n        throw new ChromaClientError(body?.message || \"Unprocessable Entity\");\n      } catch (error) {\n        if (error instanceof ChromaQuotaExceededError || error instanceof ChromaClientError) {\n          throw error;\n        }\n        throw new ChromaClientError(`Unprocessable Entity: ${response.statusText}`);\n      }\n    case 429:\n      throw new ChromaRateLimitError(\"Rate limit exceeded\");\n  }\n\n  const errorMessage = await getErrorMessage(response);\n  throw new ChromaServerError(errorMessage);\n};\n","import { defaultAdminClientArgs, HttpMethod, normalizeMethod } from \"./utils\";\nimport { createClient, createConfig } from \"@hey-api/client-fetch\";\nimport { Database, DefaultService as Api } from \"./api\";\nimport { chromaFetch } from \"./chroma-fetch\";\n\n/**\n * Configuration options for the AdminClient.\n */\nexport interface AdminClientArgs {\n  /** The host address of the Chroma server */\n  host: string;\n  /** The port number of the Chroma server */\n  port: number;\n  /** Whether to use SSL/HTTPS for connections */\n  ssl: boolean;\n  /** Additional HTTP headers to send with requests */\n  headers?: Record<string, string>;\n  /** Additional fetch options for HTTP requests */\n  fetchOptions?: RequestInit;\n}\n\n/**\n * Arguments for listing databases within a tenant.\n */\nexport interface ListDatabasesArgs {\n  /** The tenant name to list databases for */\n  tenant: string;\n  /** Maximum number of databases to return (default: 100) */\n  limit?: number;\n  /** Number of databases to skip (default: 0) */\n  offset?: number;\n}\n\n/**\n * Administrative client for managing ChromaDB tenants and databases.\n * Provides methods for creating, deleting, and listing tenants and databases.\n */\nexport class AdminClient {\n  private readonly apiClient: ReturnType<typeof createClient>;\n\n  /**\n   * Creates a new AdminClient instance.\n   * @param args - Optional configuration for the admin client\n   */\n  constructor(args?: AdminClientArgs) {\n    const { host, port, ssl, headers, fetchOptions } =\n      args || defaultAdminClientArgs;\n\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method) as HttpMethod,\n      baseUrl,\n      headers,\n    };\n\n    this.apiClient = createClient(createConfig(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n\n  /**\n   * Creates a new database within a tenant.\n   * @param options - Database creation options\n   * @param options.name - Name of the database to create\n   * @param options.tenant - Tenant that will own the database\n   */\n  public async createDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<void> {\n    await Api.createDatabase({\n      client: this.apiClient,\n      path: { tenant },\n      body: { name },\n    });\n  }\n\n  /**\n   * Retrieves information about a specific database.\n   * @param options - Database retrieval options\n   * @param options.name - Name of the database to retrieve\n   * @param options.tenant - Tenant that owns the database\n   * @returns Promise resolving to database information\n   */\n  public async getDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<Database> {\n    const { data } = await Api.getDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name },\n    });\n\n    return data;\n  }\n\n  /**\n   * Deletes a database and all its data.\n   * @param options - Database deletion options\n   * @param options.name - Name of the database to delete\n   * @param options.tenant - Tenant that owns the database\n   * @warning This operation is irreversible and will delete all data\n   */\n  public async deleteDatabase({\n    name,\n    tenant,\n  }: {\n    name: string;\n    tenant: string;\n  }): Promise<void> {\n    await Api.deleteDatabase({\n      client: this.apiClient,\n      path: { tenant, database: name },\n    });\n  }\n\n  /**\n   * Lists all databases within a tenant.\n   * @param args - Listing parameters including tenant and pagination\n   * @returns Promise resolving to an array of database information\n   */\n  public async listDatabases(args: ListDatabasesArgs): Promise<Database[]> {\n    const { limit = 100, offset = 0, tenant } = args;\n    const { data } = await Api.listDatabases({\n      client: this.apiClient,\n      path: { tenant },\n      query: { limit, offset },\n    });\n\n    return data;\n  }\n\n  /**\n   * Creates a new tenant.\n   * @param options - Tenant creation options\n   * @param options.name - Name of the tenant to create\n   */\n  public async createTenant({ name }: { name: string }): Promise<void> {\n    await Api.createTenant({\n      client: this.apiClient,\n      body: { name },\n    });\n  }\n\n  /**\n   * Retrieves information about a specific tenant.\n   * @param options - Tenant retrieval options\n   * @param options.name - Name of the tenant to retrieve\n   * @returns Promise resolving to the tenant name\n   */\n  public async getTenant({ name }: { name: string }): Promise<string> {\n    const { data } = await Api.getTenant({\n      client: this.apiClient,\n      path: { tenant_name: name },\n    });\n\n    return data.name;\n  }\n}\n","import { createClient, createConfig } from \"@hey-api/client-fetch\";\nimport {\n  defaultChromaClientArgs as defaultArgs,\n  HttpMethod,\n  normalizeMethod,\n  parseConnectionPath,\n  deserializeMetadata,\n  serializeMetadata,\n} from \"./utils\";\nimport { DefaultService as Api, ChecklistResponse } from \"./api\";\nimport { CollectionMetadata, UserIdentity } from \"./types\";\nimport { Collection, CollectionImpl } from \"./collection\";\nimport { EmbeddingFunction, getEmbeddingFunction } from \"./embedding-function\";\nimport { chromaFetch } from \"./chroma-fetch\";\nimport * as process from \"node:process\";\nimport {\n  ChromaConnectionError,\n  ChromaUnauthorizedError,\n  ChromaValueError,\n} from \"./errors\";\nimport {\n  CreateCollectionConfiguration,\n  processCreateCollectionConfig,\n} from \"./collection-configuration\";\nimport { EMBEDDING_KEY, Schema } from \"./schema\";\nimport { client } from \"./api/client.gen\";\n\nconst resolveSchemaEmbeddingFunction = (\n  schema: Schema | undefined,\n): EmbeddingFunction | undefined => {\n  if (!schema) {\n    return undefined;\n  }\n\n  const embeddingOverride =\n    schema.keys[EMBEDDING_KEY]?.floatList?.vectorIndex?.config\n      .embeddingFunction ?? undefined;\n  if (embeddingOverride) {\n    return embeddingOverride;\n  }\n\n  return (\n    schema.defaults.floatList?.vectorIndex?.config.embeddingFunction ??\n    undefined\n  );\n};\n\n/**\n * Configuration options for the ChromaClient.\n */\nexport interface ChromaClientArgs {\n  /** The host address of the Chroma server. Defaults to 'localhost' */\n  host?: string;\n  /** The port number of the Chroma server. Defaults to 8000 */\n  port?: number;\n  /** Whether to use SSL/HTTPS for connections. Defaults to false */\n  ssl?: boolean;\n  /** The tenant name in the Chroma server to connect to */\n  tenant?: string;\n  /** The database name to connect to */\n  database?: string;\n  /** Additional HTTP headers to send with requests */\n  headers?: Record<string, string>;\n  /** Additional fetch options for HTTP requests */\n  fetchOptions?: RequestInit;\n  /** @deprecated Use host, port, and ssl instead */\n  path?: string;\n  /** @deprecated */\n  auth?: Record<string, string>;\n}\n\n/**\n * Main client class for interacting with ChromaDB.\n * Provides methods for managing collections and performing operations on them.\n */\nexport class ChromaClient {\n  private _tenant: string | undefined;\n  private _database: string | undefined;\n  private _preflightChecks: ChecklistResponse | undefined;\n  private _headers: Record<string, string> | undefined;\n  private readonly apiClient: ReturnType<typeof createClient>;\n\n  /**\n   * Creates a new ChromaClient instance.\n   * @param args - Configuration options for the client\n   */\n  constructor(args: Partial<ChromaClientArgs> = {}) {\n    let {\n      host = defaultArgs.host,\n      port = defaultArgs.port,\n      ssl = defaultArgs.ssl,\n      tenant = defaultArgs.tenant,\n      database = defaultArgs.database,\n      headers = defaultArgs.headers,\n      fetchOptions = defaultArgs.fetchOptions,\n    } = args;\n\n    if (args.path) {\n      console.warn(\n        \"The 'path' argument is deprecated. Please use 'ssl', 'host', and 'port' instead\",\n      );\n      const parsedPath = parseConnectionPath(args.path);\n      ssl = parsedPath.ssl;\n      host = parsedPath.host;\n      port = parsedPath.port;\n    }\n\n    if (args.auth) {\n      console.warn(\n        \"The 'auth' argument is deprecated. Please use 'headers' instead\",\n      );\n      if (!headers) {\n        headers = {};\n      }\n      if (\n        !headers[\"x-chroma-token\"] &&\n        args.auth.tokenHeaderType === \"X_CHROMA_TOKEN\" &&\n        args.auth.credentials\n      ) {\n        headers[\"x-chroma-token\"] = args.auth.credentials;\n      }\n    }\n\n    const baseUrl = `${ssl ? \"https\" : \"http\"}://${host}:${port}`;\n\n    this._tenant = tenant || process.env.CHROMA_TENANT;\n    this._database = database || process.env.CHROMA_DATABASE;\n\n    this._headers = headers;\n\n    const configOptions = {\n      ...fetchOptions,\n      method: normalizeMethod(fetchOptions?.method) as HttpMethod,\n      baseUrl,\n      headers,\n    };\n\n    this.apiClient = createClient(createConfig(configOptions));\n    this.apiClient.setConfig({ fetch: chromaFetch });\n  }\n\n  /**\n   * Gets the current tenant name.\n   * @returns The tenant name or undefined if not set\n   */\n  public get tenant(): string | undefined {\n    return this._tenant;\n  }\n\n  protected set tenant(tenant: string | undefined) {\n    this._tenant = tenant;\n  }\n\n  /**\n   * Gets the current database name.\n   * @returns The database name or undefined if not set\n   */\n  public get database(): string | undefined {\n    return this._database;\n  }\n\n  protected set database(database: string | undefined) {\n    this._database = database;\n  }\n\n  /**\n   * Gets the preflight checks\n   * @returns The preflight checks or undefined if not set\n   */\n  public get preflightChecks(): ChecklistResponse | undefined {\n    return this._preflightChecks;\n  }\n\n  protected set preflightChecks(\n    preflightChecks: ChecklistResponse | undefined,\n  ) {\n    this._preflightChecks = preflightChecks;\n  }\n\n  public get headers(): Record<string, string> | undefined {\n    return this._headers;\n  }\n\n  /** @ignore */\n  public async _path(): Promise<{ tenant: string; database: string }> {\n    if (!this._tenant || !this._database) {\n      const { tenant, databases } = await this.getUserIdentity();\n      const uniqueDBs = [...new Set(databases)];\n      this._tenant = tenant;\n      if (uniqueDBs.length === 0) {\n        throw new ChromaUnauthorizedError(\n          `Your API key does not have access to any DBs for tenant ${this.tenant}`,\n        );\n      }\n      if (uniqueDBs.length > 1 || uniqueDBs[0] === \"*\") {\n        throw new ChromaValueError(\n          \"Your API key is scoped to more than 1 DB. Please provide a DB name to the CloudClient constructor\",\n        );\n      }\n      this._database = uniqueDBs[0];\n    }\n    return { tenant: this._tenant, database: this._database };\n  }\n\n  /**\n   * Gets the user identity information including tenant and accessible databases.\n   * @returns Promise resolving to user identity data\n   */\n  public async getUserIdentity(): Promise<UserIdentity> {\n    const { data } = await Api.getUserIdentity({\n      client: this.apiClient,\n    });\n    return data;\n  }\n\n  /**\n   * Sends a heartbeat request to check server connectivity.\n   * @returns Promise resolving to the server's nanosecond heartbeat timestamp\n   */\n  public async heartbeat(): Promise<number> {\n    const { data } = await Api.heartbeat({\n      client: this.apiClient,\n    });\n    return data[\"nanosecond heartbeat\"];\n  }\n\n  /**\n   * Lists all collections in the current database.\n   * @param args - Optional pagination parameters\n   * @param args.limit - Maximum number of collections to return (default: 100)\n   * @param args.offset - Number of collections to skip (default: 0)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  public async listCollections(\n    args?: Partial<{\n      limit: number;\n      offset: number;\n    }>,\n  ): Promise<Collection[]> {\n    const { limit = 100, offset = 0 } = args || {};\n\n    const { data } = await Api.listCollections({\n      client: this.apiClient,\n      path: await this._path(),\n      query: { limit, offset },\n    });\n\n    return Promise.all(\n      data.map(async (collection) => {\n        const schema = await Schema.deserializeFromJSON(\n          collection.schema ?? null,\n          this,\n        );\n        const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n        const resolvedEmbeddingFunction =\n          (await getEmbeddingFunction({\n            collectionName: collection.name,\n            client: this,\n            efConfig:\n              collection.configuration_json.embedding_function ?? undefined,\n          })) ?? schemaEmbeddingFunction;\n\n        return new CollectionImpl({\n          chromaClient: this,\n          apiClient: this.apiClient,\n          tenant: collection.tenant,\n          database: collection.database,\n          name: collection.name,\n          id: collection.id,\n          embeddingFunction: resolvedEmbeddingFunction,\n          configuration: collection.configuration_json,\n          metadata:\n            deserializeMetadata(collection.metadata ?? undefined) ?? undefined,\n          schema,\n        });\n      }),\n    );\n  }\n\n  /**\n   * Gets the total number of collections in the current database.\n   * @returns Promise resolving to the collection count\n   */\n  public async countCollections(): Promise<number> {\n    const { data } = await Api.countCollections({\n      client: this.apiClient,\n      path: await this._path(),\n    });\n\n    return data;\n  }\n\n  /**\n   * Creates a new collection with the specified configuration.\n   * @param options - Collection creation options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration\n   * @param options.metadata - Optional metadata for the collection\n   * @param options.embeddingFunction - Optional embedding function to use. Defaults to `DefaultEmbeddingFunction` from @chroma-core/default-embed\n   * @returns Promise resolving to the created Collection instance\n   * @throws Error if a collection with the same name already exists\n   */\n  public async createCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema,\n  }: {\n    name: string;\n    configuration?: CreateCollectionConfiguration;\n    metadata?: CollectionMetadata;\n    embeddingFunction?: EmbeddingFunction | null;\n    schema?: Schema;\n  }): Promise<Collection> {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema,\n    });\n\n    const { data } = await Api.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: false,\n        schema: schema ? schema.serializeToJSON() : undefined,\n      },\n    });\n\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this,\n    );\n    const schemaEmbeddingFunction =\n      resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        client: this,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema,\n    });\n  }\n\n  /**\n   * Retrieves an existing collection by name.\n   * @param options - Collection retrieval options\n   * @param options.name - The name of the collection to retrieve\n   * @param options.embeddingFunction - Optional embedding function. Should match the one used to create the collection.\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  public async getCollection({\n    name,\n    embeddingFunction,\n  }: {\n    name: string;\n    embeddingFunction?: EmbeddingFunction;\n  }): Promise<Collection> {\n    const { data } = await Api.getCollection({\n      client: this.apiClient,\n      path: { ...(await this._path()), collection_id: name },\n    });\n\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        client: this,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema,\n    });\n  }\n\n  /**\n   * Retrieves an existing collection by its Chroma Resource Name (CRN).\n   * @param crn - The Chroma Resource Name of the collection to retrieve\n   * @returns Promise resolving to the Collection instance\n   * @throws Error if the collection does not exist\n   */\n  public async getCollectionByCrn(crn: string): Promise<Collection> {\n    const { data } = await Api.getCollectionByCrn({\n      client: this.apiClient,\n      path: { crn },\n    });\n    const schema = await Schema.deserializeFromJSON(data.schema ?? null, this);\n    const schemaEmbeddingFunction = resolveSchemaEmbeddingFunction(schema);\n    const resolvedEmbeddingFunction =\n      (await getEmbeddingFunction({\n        collectionName: data.name,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n        client: this,\n      })) ?? schemaEmbeddingFunction;\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name: data.name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema,\n    });\n  }\n\n  /**\n   * Retrieves multiple collections by name.\n   * @param items - Array of collection names or objects with name and optional embedding function (should match the ones used to create the collections)\n   * @returns Promise resolving to an array of Collection instances\n   */\n  public async getCollections(\n    items: string[] | { name: string; embeddingFunction?: EmbeddingFunction }[],\n  ): Promise<Collection[]> {\n    if (items.length === 0) return [];\n\n    let requestedCollections = items;\n    if (typeof items[0] === \"string\") {\n      requestedCollections = (items as string[]).map((item) => {\n        return { name: item, embeddingFunction: undefined };\n      });\n    }\n\n    let collections = requestedCollections as {\n      name: string;\n      embeddingFunction?: EmbeddingFunction;\n    }[];\n\n    return Promise.all(\n      collections.map(async (collection) => {\n        return this.getCollection({ ...collection });\n      }),\n    );\n  }\n\n  /**\n   * Gets an existing collection or creates it if it doesn't exist.\n   * @param options - Collection options\n   * @param options.name - The name of the collection\n   * @param options.configuration - Optional collection configuration (used only if creating)\n   * @param options.metadata - Optional metadata for the collection (used only if creating)\n   * @param options.embeddingFunction - Optional embedding function to use\n   * @returns Promise resolving to the Collection instance\n   */\n  public async getOrCreateCollection({\n    name,\n    configuration,\n    metadata,\n    embeddingFunction,\n    schema,\n  }: {\n    name: string;\n    configuration?: CreateCollectionConfiguration;\n    metadata?: CollectionMetadata;\n    embeddingFunction?: EmbeddingFunction | null;\n    schema?: Schema;\n  }): Promise<Collection> {\n    const collectionConfig = await processCreateCollectionConfig({\n      configuration,\n      embeddingFunction,\n      metadata,\n      schema,\n    });\n\n    const { data } = await Api.createCollection({\n      client: this.apiClient,\n      path: await this._path(),\n      body: {\n        name,\n        configuration: collectionConfig,\n        metadata: serializeMetadata(metadata),\n        get_or_create: true,\n        schema: schema ? schema.serializeToJSON() : undefined,\n      },\n    });\n\n    const serverSchema = await Schema.deserializeFromJSON(\n      data.schema ?? null,\n      this,\n    );\n    const schemaEmbeddingFunction =\n      resolveSchemaEmbeddingFunction(serverSchema);\n    const resolvedEmbeddingFunction =\n      embeddingFunction ??\n      (await getEmbeddingFunction({\n        collectionName: name,\n        efConfig: data.configuration_json.embedding_function ?? undefined,\n        client: this,\n      })) ??\n      schemaEmbeddingFunction;\n\n    return new CollectionImpl({\n      chromaClient: this,\n      apiClient: this.apiClient,\n      name,\n      tenant: data.tenant,\n      database: data.database,\n      configuration: data.configuration_json,\n      metadata: deserializeMetadata(data.metadata ?? undefined) ?? undefined,\n      embeddingFunction: resolvedEmbeddingFunction,\n      id: data.id,\n      schema: serverSchema,\n    });\n  }\n\n  /**\n   * Deletes a collection and all its data.\n   * @param options - Deletion options\n   * @param options.name - The name of the collection to delete\n   */\n  public async deleteCollection({ name }: { name: string }): Promise<void> {\n    await Api.deleteCollection({\n      client: this.apiClient,\n      path: { ...(await this._path()), collection_id: name },\n    });\n  }\n\n  /**\n   * Resets the entire database, deleting all collections and data.\n   * @returns Promise that resolves when the reset is complete\n   * @warning This operation is irreversible and will delete all data\n   */\n  public async reset(): Promise<void> {\n    await Api.reset({\n      client: this.apiClient,\n    });\n  }\n\n  /**\n   * Gets the version of the Chroma server.\n   * @returns Promise resolving to the server version string\n   */\n  public async version(): Promise<string> {\n    const { data } = await Api.version({\n      client: this.apiClient,\n    });\n    return data;\n  }\n\n  /**\n   * Gets the preflight checks\n   * @returns Promise resolving to the preflight checks\n   */\n  public async getPreflightChecks(): Promise<ChecklistResponse> {\n    if (!this.preflightChecks) {\n      const { data } = await Api.preFlightChecks({\n        client: this.apiClient,\n      });\n      this.preflightChecks = data;\n      return this.preflightChecks;\n    }\n    return this.preflightChecks;\n  }\n\n  /**\n   * Gets the max batch size\n   * @returns Promise resolving to the max batch size\n   */\n  public async getMaxBatchSize(): Promise<number> {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.max_batch_size ?? -1;\n  }\n\n  /**\n   * Gets whether base64_encoding is supported by the connected server\n   * @returns Promise resolving to whether base64_encoding is supported\n   */\n  public async supportsBase64Encoding(): Promise<boolean> {\n    const preflightChecks = await this.getPreflightChecks();\n    return preflightChecks.supports_base64_encoding ?? false;\n  }\n}\n","import { ChromaClient } from \"./chroma-client\";\nimport * as process from \"node:process\";\nimport { AdminClient } from \"./admin-client\";\nimport { ChromaUnauthorizedError, ChromaValueError } from \"./errors\";\n\n/**\n * ChromaDB cloud client for connecting to hosted Chroma instances.\n * Extends ChromaClient with cloud-specific authentication and configuration.\n */\nexport class CloudClient extends ChromaClient {\n  /**\n   * Creates a new CloudClient instance for Chroma Cloud.\n   * @param args - Cloud client configuration options\n   */\n  constructor(\n    args: Partial<{\n      /** API key for authentication (or set CHROMA_API_KEY env var) */\n      apiKey?: string;\n      /** Tenant name for multi-tenant deployments */\n      tenant?: string;\n      /** Database name to connect to */\n      database?: string;\n      /** Additional fetch options for HTTP requests */\n      fetchOptions?: RequestInit;\n    }> = {},\n  ) {\n    const apiKey = args.apiKey || process.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\",\n      );\n    }\n\n    const tenant = args.tenant || process.env.CHROMA_TENANT;\n    const database = args.database || process.env.CHROMA_DATABASE;\n\n    super({\n      host: \"api.trychroma.com\",\n      port: 8000,\n      ssl: true,\n      tenant,\n      database,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions,\n    });\n\n    // Override from ChromaClient construction in case undefined. This will trigger auto-resolution in the \"path\" function\n    this.tenant = tenant;\n    this.database = database;\n  }\n}\n\n/**\n * Admin client for Chroma Cloud administrative operations.\n * Extends AdminClient with cloud-specific authentication.\n */\nexport class AdminCloudClient extends AdminClient {\n  /**\n   * Creates a new AdminCloudClient instance for cloud admin operations.\n   * @param args - Admin cloud client configuration options\n   */\n  constructor(\n    args: Partial<{\n      /** API key for authentication (or set CHROMA_API_KEY env var) */\n      apiKey?: string;\n      /** Additional fetch options for HTTP requests */\n      fetchOptions?: RequestInit;\n    }> = {},\n  ) {\n    const apiKey = args.apiKey || process.env.CHROMA_API_KEY;\n    if (!apiKey) {\n      throw new ChromaValueError(\n        \"Missing API key. Please provide it to the CloudClient constructor or set your CHROMA_API_KEY environment variable\",\n      );\n    }\n\n    super({\n      host: \"api.trychroma.com\",\n      port: 8000,\n      ssl: true,\n      headers: { \"x-chroma-token\": apiKey },\n      fetchOptions: args.fetchOptions,\n    });\n  }\n}\n"],"names":["IncludeEnum","q","getAuthToken","auth","callback","token","getAuthToken","jsonBodySerializer","body","key","value","getAuthToken","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","value","joinedValues","v","separator","serializePrimitiveParam","serializeObjectParam","values","key","PATH_PARAM_RE","defaultPathSerializer","path","_url","url","matches","match","h","g","c","replaceValue","createQuerySerializer","array","object","queryParams","search","getParseAs","contentType","cleanContent","type","setAuthParams","security","options","auth","token","x","buildUrl","getUrl","baseUrl","query","querySerializer","pathUrl","mergeConfigs","a","b","config","mergeHeaders","headers","mergedHeaders","header","iterator","Interceptors","fn","index","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","z","createClient","_config","getConfig","setConfig","interceptors","request","opts","requestInit","_fetch","response","result","parseAs","data","error","finalError","_","w","client","client","client","sparseEmbeddings","process"],"mappings":"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"}}]
}
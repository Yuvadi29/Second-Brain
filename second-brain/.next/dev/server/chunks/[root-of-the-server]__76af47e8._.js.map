{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/lib/extractGithubFile.ts"],"sourcesContent":["\"use server\";\n\nimport pdfParse from \"pdf-parse\";\nimport mammoth from \"mammoth\";\n\nconst OWNER = process.env.GITHUB_REPO_OWNER!;\nconst REPO = process.env.GITHUB_REPO_NAME!;\nconst GITHUB_TOKEN = process.env.GITHUB_TOKEN!;\n\nfunction extOf(path: string): string {\n  const parts = path.toLowerCase().split(\".\");\n  return parts.length > 1 ? parts.pop()! : \"\";\n}\n\nexport async function extractTextFromGithubFile(\n  path: string,\n  ref: string\n): Promise<string | null> {\n  const ext = extOf(path);\n\n  const res = await fetch(\n    `https://api.github.com/repos/${OWNER}/${REPO}/contents/${encodeURIComponent(\n      path\n    )}?ref=${ref}`,\n    {\n      headers: {\n        Authorization: `Bearer ${GITHUB_TOKEN}`,\n        Accept: \"application/vnd.github.v3.raw\",\n      },\n    }\n  );\n\n  if (res.status === 404) {\n    console.warn(\"[extractGithubFile] 404 for\", path, \"ref\", ref);\n    return null;\n  }\n\n  if (!res.ok) {\n    console.error(\n      \"[extractGithubFile] GitHub error\",\n      res.status,\n      await res.text()\n    );\n    return null;\n  }\n\n  // Text-ish files: md, txt, code, etc.\n  const textExtensions = [\n    \"md\",\n    \"mdx\",\n    \"txt\",\n    \"ts\",\n    \"tsx\",\n    \"js\",\n    \"jsx\",\n    \"py\",\n    \"json\",\n    \"yml\",\n    \"yaml\"\n  ];\n\n  if (textExtensions.includes(ext)) {\n    return await res.text();\n  }\n\n  // Binary formats\n  const arrayBuffer = await res.arrayBuffer();\n  const buffer = Buffer.from(arrayBuffer);\n\n  if (ext === \"pdf\") {\n    const parsed = await pdfParse(buffer);\n    return parsed.text;\n  }\n\n  if (ext === \"docx\") {\n    const result = await mammoth.extractRawText({ buffer });\n    return result.value;\n  }\n\n  console.warn(\"[extractGithubFile] Unsupported extension:\", ext, \"for\", path);\n  return null;\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;AAEA,MAAM,QAAQ,QAAQ,GAAG,CAAC,iBAAiB;AAC3C,MAAM,OAAO,QAAQ,GAAG,CAAC,gBAAgB;AACzC,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY;AAE7C,SAAS,MAAM,IAAY;IACzB,MAAM,QAAQ,KAAK,WAAW,GAAG,KAAK,CAAC;IACvC,OAAO,MAAM,MAAM,GAAG,IAAI,MAAM,GAAG,KAAM;AAC3C;AAEO,eAAe,0BACpB,IAAY,EACZ,GAAW;IAEX,MAAM,MAAM,MAAM;IAElB,MAAM,MAAM,MAAM,MAChB,CAAC,6BAA6B,EAAE,MAAM,CAAC,EAAE,KAAK,UAAU,EAAE,mBACxD,MACA,KAAK,EAAE,KAAK,EACd;QACE,SAAS;YACP,eAAe,CAAC,OAAO,EAAE,cAAc;YACvC,QAAQ;QACV;IACF;IAGF,IAAI,IAAI,MAAM,KAAK,KAAK;QACtB,QAAQ,IAAI,CAAC,+BAA+B,MAAM,OAAO;QACzD,OAAO;IACT;IAEA,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,QAAQ,KAAK,CACX,oCACA,IAAI,MAAM,EACV,MAAM,IAAI,IAAI;QAEhB,OAAO;IACT;IAEA,sCAAsC;IACtC,MAAM,iBAAiB;QACrB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,IAAI,eAAe,QAAQ,CAAC,MAAM;QAChC,OAAO,MAAM,IAAI,IAAI;IACvB;IAEA,iBAAiB;IACjB,MAAM,cAAc,MAAM,IAAI,WAAW;IACzC,MAAM,SAAS,OAAO,IAAI,CAAC;IAE3B,IAAI,QAAQ,OAAO;QACjB,MAAM,SAAS,MAAM,IAAA,kJAAQ,EAAC;QAC9B,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,QAAQ,QAAQ;QAClB,MAAM,SAAS,MAAM,oJAAO,CAAC,cAAc,CAAC;YAAE;QAAO;QACrD,OAAO,OAAO,KAAK;IACrB;IAEA,QAAQ,IAAI,CAAC,8CAA8C,KAAK,OAAO;IACvE,OAAO;AACT;;;IAnEsB;;AAAA,iPAAA"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/lib/chromaClient.ts"],"sourcesContent":["\nimport { CloudClient } from \"chromadb\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst apiKey = process.env.CHROMA_API_KEY!;\nconst tenant = process.env.CHROMA_TENANT!;\nconst database = process.env.CHROMA_DATABASE!;\n\nif (!apiKey || !tenant || !database) {\n  throw new Error(\"CHROMA_API_KEY, CHROMA_TENANT, CHROMA_DATABASE must be set\");\n}\n\nexport const chroma = new CloudClient({\n  apiKey,\n  tenant,\n  database,\n})\n\nexport async function getOrCreateCollection(name: string) {\n  return chroma.getOrCreateCollection({\n    name,\n  });\n}\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAEA,kJAAM,CAAC,MAAM;AAEb,MAAM,SAAS,QAAQ,GAAG,CAAC,cAAc;AACzC,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa;AACxC,MAAM,WAAW,QAAQ,GAAG,CAAC,eAAe;AAE5C,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,UAAU;IACnC,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,SAAS,IAAI,+HAAW,CAAC;IACpC;IACA;IACA;AACF;AAEO,eAAe,sBAAsB,IAAY;IACtD,OAAO,OAAO,qBAAqB,CAAC;QAClC;IACF;AACF"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/lib/chunkAndIngest.ts"],"sourcesContent":["\"use server\";\n\nimport { RecursiveCharacterTextSplitter } from \"@langchain/textsplitters\";\nimport { getOrCreateCollection } from \"./chromaClient\";\n\nexport async function ingestTextIntoChroma(\n    collectionName: string,\n    filePath: string,\n    text: string,\n    metadata: Record<string, any> = {}\n) {\n    const splitter = new RecursiveCharacterTextSplitter({\n        chunkSize: 1200,\n        chunkOverlap: 200,\n    });\n\n    const chunks = await splitter.splitText(text);\n    const collection = await getOrCreateCollection(collectionName);\n\n    await collection?.add({\n        ids: chunks?.map((_, i) => `${filePath}::${i}`),\n        documents: chunks,\n        metadatas: chunks?.map((_, i) => ({\n            ...metadata,\n            filePath,\n            chunkIndex: i\n        })),\n    });\n\n    console.log(`Ingested ${chunks?.length} chunks from ${filePath}`);\n\n\n}"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;;;;;;;;;AAEO,eAAe,qBAClB,cAAsB,EACtB,QAAgB,EAChB,IAAY,EACZ,WAAgC,CAAC,CAAC;IAElC,MAAM,WAAW,IAAI,yMAA8B,CAAC;QAChD,WAAW;QACX,cAAc;IAClB;IAEA,MAAM,SAAS,MAAM,SAAS,SAAS,CAAC;IACxC,MAAM,aAAa,MAAM,IAAA,8IAAqB,EAAC;IAE/C,MAAM,YAAY,IAAI;QAClB,KAAK,QAAQ,IAAI,CAAC,GAAG,IAAM,GAAG,SAAS,EAAE,EAAE,GAAG;QAC9C,WAAW;QACX,WAAW,QAAQ,IAAI,CAAC,GAAG,IAAM,CAAC;gBAC9B,GAAG,QAAQ;gBACX;gBACA,YAAY;YAChB,CAAC;IACL;IAEA,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,QAAQ,OAAO,aAAa,EAAE,UAAU;AAGpE;;;IA3BsB;;AAAA,iPAAA"}},
    {"offset": {"line": 290, "column": 0}, "map": {"version":3,"sources":["file:///Users/adityatrivedi/Desktop/Dev/Second-Brain/second-brain/app/api/github/webhook/route.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport { NextRequest } from \"next/server\";\nimport { extractTextFromGithubFile } from \"@/lib/extractGithubFile\";\nimport { ingestTextIntoChroma } from \"@/lib/chunkAndIngest\";\n\nexport const runtime = \"nodejs\";\n\nconst GH_SECRET = process.env.GITHUB_WEBHOOK_SECRET!;\n\nfunction verifySignature(payload: string, signature: string | null) {\n    if (!signature) return false;\n    const hmac = crypto.createHmac(\"sha256\", GH_SECRET);\n    const digest = `sha256=${hmac.update(payload).digest(\"hex\")}`;\n    try {\n        return crypto.timingSafeEqual(Buffer.from(digest), Buffer.from(signature));\n    } catch {\n        return false;\n    }\n}\n\nexport async function POST(req: NextRequest) {\n    const rawBody = await req.text();\n    const signature = req.headers.get(\"x-hub-signature-256\");\n\n    if (!verifySignature(rawBody, signature)) {\n        return new Response(\"Invalid signature\", { status: 401 });\n    }\n\n    const event = req.headers.get(\"x-github-event\");\n    if (event !== \"push\") {\n        return new Response(\"Ignored\", { status: 204 });\n    }\n\n    const payload = JSON.parse(rawBody);\n    const afterSha = payload.after as string;\n    const commits = payload.commits ?? [];\n\n    const touchedFiles: string[] = [];\n\n    for (const c of commits) {\n        const files = [...(c.added ?? []), ...(c.modified ?? [])];\n        for (const f of files) {\n            if (typeof f === \"string\" && f.startsWith(\"knowledge/\")) {\n                touchedFiles.push(f);\n            }\n        }\n    }\n\n    if (touchedFiles.length === 0) {\n        return new Response(\"No knowledge files changed\", { status: 200 });\n    }\n\n    for (const path of touchedFiles) {\n        const text = await extractTextFromGithubFile(path, afterSha);\n        if (!text) {\n            console.warn(\"[webhook] No text extracted for\", path);\n            continue;\n        }\n\n        await ingestTextIntoChroma(\"secondbrain\", path, text, {\n            ref: afterSha,\n        });\n    }\n\n    return new Response(\"OK\", { status: 200 });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAEA;AACA;;;;;;;;AAEO,MAAM,UAAU;AAEvB,MAAM,YAAY,QAAQ,GAAG,CAAC,qBAAqB;AAEnD,SAAS,gBAAgB,OAAe,EAAE,SAAwB;IAC9D,IAAI,CAAC,WAAW,OAAO;IACvB,MAAM,OAAO,gHAAM,CAAC,UAAU,CAAC,UAAU;IACzC,MAAM,SAAS,CAAC,OAAO,EAAE,KAAK,MAAM,CAAC,SAAS,MAAM,CAAC,QAAQ;IAC7D,IAAI;QACA,OAAO,gHAAM,CAAC,eAAe,CAAC,OAAO,IAAI,CAAC,SAAS,OAAO,IAAI,CAAC;IACnE,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAEO,eAAe,KAAK,GAAgB;IACvC,MAAM,UAAU,MAAM,IAAI,IAAI;IAC9B,MAAM,YAAY,IAAI,OAAO,CAAC,GAAG,CAAC;IAElC,IAAI,CAAC,gBAAgB,SAAS,YAAY;QACtC,OAAO,IAAI,SAAS,qBAAqB;YAAE,QAAQ;QAAI;IAC3D;IAEA,MAAM,QAAQ,IAAI,OAAO,CAAC,GAAG,CAAC;IAC9B,IAAI,UAAU,QAAQ;QAClB,OAAO,IAAI,SAAS,WAAW;YAAE,QAAQ;QAAI;IACjD;IAEA,MAAM,UAAU,KAAK,KAAK,CAAC;IAC3B,MAAM,WAAW,QAAQ,KAAK;IAC9B,MAAM,UAAU,QAAQ,OAAO,IAAI,EAAE;IAErC,MAAM,eAAyB,EAAE;IAEjC,KAAK,MAAM,KAAK,QAAS;QACrB,MAAM,QAAQ;eAAK,EAAE,KAAK,IAAI,EAAE;eAAO,EAAE,QAAQ,IAAI,EAAE;SAAE;QACzD,KAAK,MAAM,KAAK,MAAO;YACnB,IAAI,OAAO,MAAM,YAAY,EAAE,UAAU,CAAC,eAAe;gBACrD,aAAa,IAAI,CAAC;YACtB;QACJ;IACJ;IAEA,IAAI,aAAa,MAAM,KAAK,GAAG;QAC3B,OAAO,IAAI,SAAS,8BAA8B;YAAE,QAAQ;QAAI;IACpE;IAEA,KAAK,MAAM,QAAQ,aAAc;QAC7B,MAAM,OAAO,MAAM,IAAA,uJAAyB,EAAC,MAAM;QACnD,IAAI,CAAC,MAAM;YACP,QAAQ,IAAI,CAAC,mCAAmC;YAChD;QACJ;QAEA,MAAM,IAAA,+IAAoB,EAAC,eAAe,MAAM,MAAM;YAClD,KAAK;QACT;IACJ;IAEA,OAAO,IAAI,SAAS,MAAM;QAAE,QAAQ;IAAI;AAC5C"}}]
}